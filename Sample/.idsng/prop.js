var idsprop={"cheader.name_format":"to remove bursting in avalon widget","explicit_name":"give the complete hierarchy from top","is_rsv":"marks all the fields of the register as reserved","output_file_name":"Creates the output file in the name assigned to this property","repeat":"Repeat a template N number of times","variant":"The name of the Variant that the template is in","vhdl.arch":"Used to change the architecture name of the block/chip","byte_addressing":"Used for creatin addresses in generated outputs according to selected addressUnits","rtl.name_format":"to remove bursting in avalon widget","unaligned_error":"to provide unaligned errors","rtl.bmax":"to compare the value stored in the register and data from hw","rtl.bmin":"to compare the value stored in the register and data from hw","rtl.hw_latch":"to latch the data from hw side","rtl.sw_read":"in case of sw read, it assign data from hw side","rtl.sw_write":"in case of sw write, it assign 0 in next cycle","avalon_noburst":"to remove bursting in avalon widget","clock_edge":"Clock edge used for implementing registers","tmr":"to reduce redundancy","rtl.axi4_prot":"to assign the protection signal '0'","external_intf_stages":"To remove the flops from the external output signal in vhdl","module_name":"Changes the name of the module in the verilog output","default_clock_name":"Changes the name of the clock in the verilog output","default_reset_name":"Changes the name of the reset in the verilog output","rtl.byte_enable":"To exclude bytenable signal in case of Proprietary","reset_level":"Specifies the level of the reset for the registers","reset_type":"Type of reset for the registers","rtl.bit_enable":"Bit enabled addressing refers to ability to read and write to an individual 					bit field in a register via software bus interface(Proprietary bus). A 'bitenable' signal is 					introduced which is a vector of length equal to regwidth","rtl.byte_enable":"If a design does not support single bits writes, using this property,it generates RTL without reg_enb signal.","rtl.response_tree":"Specifies whether the rd_wait and request signal for read and write 					transaction are ANDed or ORed","rtl.precedence":"To prioritize the hw or sw for write operation","undefined_rd_val":"To set the undefined (reserved) bits of the register ","page_select":"To specify the select signal for 'n' number of Paged Block, where count is according to size of the select field or reg'","addressing":"Align register, which have RegWidth less than BusWidth","vertical_reuse":"relocatable RTL","lock_bitmask":"It is used to mask the bits of a lock, an output lock_bitmask is generated","bus.domain":"The bus domain name on which the register exists","uvm.base_class":"To change the base class in UVM Regmodel","uvm.class":"Class name in the Regmodel","uvm.field_class":"The field class name instance is replaced with the value in this property","uvm.inst_class":"The name of the variable that has the instance of the class","uvm.map":"To specify a user-defined name for the default map in the UVM regmodel","uvm.name_format":"used to change the class name","uvm.package":"The name of the package that is being generated","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","uvm.user_coverage":"Specify all the identifiers globally at the top level of the register 					specification in the block description. This will generate an enum of type 					“uvm_reg_cvr_t”","uvm.coverpoint.b":"to customize the coverpoint for register group coverpoint in uvm","uvm.coverpoint.b_wr":"to customize the coverpoint for register group coverpoint in uvm","uvm.coverpoint.b_rd":"to customize the coverpoint for register group coverpoint in uvm","uvm_add_regmap":"Create additional maps in UVM","vertical_reuse":"relocatable UVM","coverage":"Generates appropriate coverage code in the output","coverage.at_least":" ","coverage.auto_bin_max":" ","coverage.comment":" ","coverage.cross_num_print_missing":" ","coverage.detect_overlap":" ","coverage.get_inst_coverage":" ","coverage.goal":" ","coverage.per_instance":" ","coverage.weight":" ","library":"Name of the library of the IP-XACT model","vendor":"Vendor name of the IP-XACT model","version":"Version number of the IP-XACT model","ipxact.topdesign":"To mention top design's path while importing","ipxact.buscomp":"To mention all bus component files path while importing to capture remap addresses","ipxact_ignore":"To remove Models and busInterfaces in IP-XACT","cheader.name_format":"used to customize the name of macros and structs","cheader.mask_endianess":"Used to choose endianess for mask values","compiler.arrayindex.maxvalue":"Maximum value of the array index","header.field_mask":"To suffix 'MASK' in field name of macro illustrating mask value for single bit fields","header.frwd_declr":"For forward declaration of the structs and unions","header.struct_guard":"Used to generate C header's struct within ifndef, to avoid assembler's errors","doc.default_padding":"Generates default value with padding in HTML output","is_rsv":"marks all the fields of the register as reserved","output_file_name":"Creates the output file in the name assigned to this property","repeat":"Repeat a template N number of times","variant":"The name of the Variant that the template is in","vhdl.arch":"Used to change the architecture name of the block/chip","alias":"creates an alias of register or field","lock":"locks the software access of a register depending on the value of the locking 					field","reg_default":"Specify the default value for register","reg_hw":"Specify the hw access for register","reg_sw":"Specify the sw access for register","rwpair":"Creates RO_WO pair register at same address","lock_bitmask":"It is used to mask the bits of a lock, an output lock_bitmask is generate","addr_decode_stages":"Additional register stages to be added to the decode signal","clock_edge":"Clock edge used for implementing registers","external_intf_stages":"To remove the flops from the external output signal in vhdl","module_name":"Changes the name of the module in the verilog output","page_count":"To specify number of copies of a Paged register","page_select":"To specify the select signal for 'n' number of Paged Block and Registers, where 'n' is value of 'page_count'","reset_level":"Specifies the level of the reset for the registers","reset_type":"Type of reset for the registers","rtl.bit_enable":"Bit enabled addressing refers to ability to read and write to an individual 					bit field in a register via software bus interface(Proprietary bus). A 'bitenable' signal is 					introduced which is a vector of length equal to regwidth","rtl.response_tree":"Specifies whether the rd_wait and request signal for read and write 					transaction are ANDed or ORed","undefined_rd_val":"To set the undefined (reserved) bits of the register ","rb_data_stages":"Additional register stages to be added to the data signal (rd_data) on the 					read back path from the generated block","rb_valid_stages":"Register stages to be added to the valid signal (rd_data_valid) on 					the read back path from the generated block","rd_stb_stages":"To add the stages in read strobe","vhdl.entity":"To change the name of the entity in the VHDL output","vhdl.package":"Changes the name of the generated VHDL package ","wr_stb_stages":"To add the stages in write strobe","buffer_trig":"used to specify a field of any register as a trigger","buffer_trig_reg":"used to specify a register as a trigger for another register","cdc.clock":"Add Clock Domain Crossing synchronizers to the field signals","reg_prot":"To protect the register from the SW (APB bus) side","reg_rprot":"To protect the register to read its value from the SW (AXI bus) side","reg_wprot":"To protect the register from the SW ( AXI bus) side","registered":"Indicates whether to register the signal coming into the generated module from 					the hardware side. Hardware access must be set to writeable","rtl.hw_clear":"A field can be cleared whenever a signal from the application logic or 					hardware interface is asserted high","rtl.hw_rp":"A pulse is generated whenever a field is read through the bus interface","rtl.hw_w1p":"A pulse is generated whenever 1 is written to a field through the bus 					interface","rtl.hw_w0p":"A pulse is generated whenever 1 is written to a field through the bus 					interface","rtl.hw_wp":"A pulse is generated whenever a write happens to a field through the bus 					interface","shadow_address":"Address of the register that is to be 'shadowed'. More than one register can 					shadow a single register","shadow_reg":"Name of the register that is to be 'shadowed'. More than one register can 					shadow a single register","undefined_rd_val":"To set the undefined (reserved) bits of the register ","next":"It describes next input value of field","resetsignal":"External input signals to reset the field(soft reset)","we":" To change write enable of specific field. ","bus.domain":"The bus domain name on which the register exists","counter":"This specifies whether the counter will be incrementing or decrementing","counter.decr.sat":"This specifies the value after which the decrementing counter will stop 					decrementing","counter.incr.sat":"This specifies the value after which the incrementing counter will not 					increment","counter.decr.thld":"This specifies the value after which the decrementing counter will start 					decrementing","counter.incr.thld":"This specifies the value after which the incrementing counter will start 					incrementing","counter.decr.val":"This specifies the value by which the counter is decremented","counter.incr.val":" ","counter.sw.wr":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","counter.sw.rd":"To specify that the counter is incrementing/decrementing for read operation from SW interface. ","counter.precedence":"Used to change the sequence of precedence for all three type of counters","counter.sat":"This specifies that the counter is saturated and the saturation by default is 					2^(number of bits) if the counter.decr.sat or counter.incr.sat is not 					specified","counter.signal":"Used to specify the signal that controls the increment and decrement events of a counter. It is an Active-High event.","counter.hw.enb":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","counter.sw.wr.enb":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","counter.sw.rd.enb":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","intr.in":"intr.in is used to specify name of one or multi bit interrupt input signal 					that needs to be simply ORed ,not registered in flip flops ","intr.out":"intr.out specifies the name of the output interrupt signal,to translate it 					into RTL","halt.enable":"enables the halt signal to propagate to CPU","uvm.field_class":"The field class name instance is replaced with the value in this property","halt.mask":"Halt mask bit corresponding to Status register bit decides that those halt signals will not be allowed to propagate to main halt signal","intr.detect":"intr.detect is used to specify the detection circuitry for input interupt 					signal registered in any of register/field identified as status or 					pending","intr.enable":"Identifies the enable register for the interrupt logic","intr.irq_bit":"The ored value of all the interrupt channel after enable control logic can be 					registered and is stored in a field.Output interrupt signal specified in 					property intr.out is registered in this field","intr.mask":"intr.mask is used to specify the mask register for the interrupt logic","intr.pending":"Identifies the pending register for the interrupt logic","intr.post":"int.post is used to register software driven interrupts","intr.status":"Identifies the status register for the interrupt logic","halt.enable":"enables the halt signal to propagate to CPU","halt.mask":"Halt mask bit corresponding to Status register bit decides that those halt signals will not be allowed to propagate to main halt signal","intr.nonsticky":"intr.nonsticky property defines a nonsticky interrupt. The associated interrupt field shall not ne locked","uvm.base_class":"To change the base class in UVM Regmodel","uvm.class":"Class name in the Regmodel","uvm.field_class":"The field class name instance is replaced with the value in this property","uvm.inst_class":"The name of the variable that has the instance of the class","uvm.map":"To specify a user-defined name for the default map in the UVM regmodel","uvm.name_format":"used to change the class name","uvm.package":"The name of the package that is being generated","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","uvm.user_coverage":"Specify all the identifiers globally at the top level of the register 					specification in the block description. This will generate an enum of type 					“uvm_reg_cvr_t”","uvm.handle_name_format":"used to change handle's name","hdl_path_internal":"To prepend the value in it, to the hdl_path value.It prepend the value on internal registers only","uvm.reg_class":"The register classes will be extendedd by the class mentioned using this 					property","hdl_path":" ","constraint":"Specifies the constraint on the value","depth":"Depth of the index register","dontcompare":"Eliminates the specified reg or field from verification. It adds compare 					(UVM_NO_CHECK) on the specified fields","index_reg":"Name of the index register","has_reset":"A value of 1 indicates a hard reset, a value of 0 indicates that the reset is 					ignored by the UVM model","is_acc":"Specifies if the field can be individually accessible","is_rand":"Specifies if the field is randomizable","volatile":"Used to set the volatility of the field.","vertical_reuse":"relocatable UVM","ignore_prop":"It ignores the property 'hdl_path_internal' at reg/field/section","coverage":"Generates appropriate coverage code in the output","coverage.at_least":" ","coverage.auto_bin_max":" ","coverage.comment":" ","coverage.cross_num_print_missing":" ","coverage.detect_overlap":" ","coverage.get_inst_coverage":" ","coverage.goal":" ","coverage.per_instance":" ","coverage.weight":" ","library":"Name of the library of the IP-XACT model","vendor":"Vendor name of the IP-XACT model","version":"Version number of the IP-XACT model","cheader.mask_endianess":"Used to choose endianess for mask values","compiler.arrayindex.maxvalue":"Maximum value of the array index","header.frwd_declr":"For forward declaration of the structs and unions","no_reg_access_test":"Do default access tests","no_reg_bit_bash_test":"Do default bit bash tests","no_reg_hw_reset_test":"Do default hw reset tests","no_reg_tests":"Do default register tests","no_mem_tests":"Do default memory tests","no_mem_walk_test":"Do default memory walk tests","clock_name":"This specifies the clock name on which the register exists","default":" ","desc":" ","size":"specify size","external":"","sniffer_error":"to specify the error generated by the sniffer engine","ecc_sniffer":"to give the sniffer counter value","cheader.name_format":"to remove bursting in avalon widget","explicit_name":"give the complete hierarchy from top","is_rsv":"marks all the fields of the register as reserved","output_file_name":"Creates the output file in the name assigned to this property","repeat":"Repeat a template N number of times","variant":"The variant that the template is in","byte_addressing":"Used for creatin addresses in generated outputs according to selected addressUnits","parity":" to check parity for all registers in a block","parity_error":" to check the parity bit error for all registers in a block","rtl.name_format":"to remove bursting in avalon widget","unaligned_error":"to provide unaligned errors","avalon_noburst":"to remove bursting in avalon widget","tmr":"to reduce redundancy","rtl.byte_enable":"If a design does not support single bits writes, using this property,it generates RTL without reg_enb signal.","addr_decode_stages":"Additional register stages to be added to the decode signal","clock_edge":"Clock edge used for implementing registers","external_intf_stages":"To remove the flops from the external output signal in vhdl","module_name":"Changes the name of the module in the verilog output","default_clock_name":"Changes the name of the clock in the verilog output","default_reset_name":"Changes the name of the reset in the verilog output","rb_data_stages":"Additional register stages to be added to the data signal (rd_data) on the 					read back path from the generated block","rb_valid_stages":"Register stages to be added to the valid signal (rd_data_valid) on 					the read back path from the generated block","rd_stb_stages":"To add the stages in read strobe","out_enb_stages":"To add the stages in out enb port","reset_level":"Specifies the level of the reset for the registers","rtl.axi4_prot":"to assign the protection signal '0'","reset_type":"Type of reset for the registers","rtl.bit_enable":"Bit enabled addressing refers to ability to read and write to an individual 					bit field in a register via software bus interface(Proprietary bus). A 'bitenable' signal is 					introduced which is a vector of length equal to regwidth","rtl.response_tree":"Specifies whether the rd_wait and request signal for read and write 					transaction are ANDed or ORed","rtl.precedence":"To prioritize the hw or sw for write operation","undefined_rd_val":"To set the undefined (reserved) bits of the register ","vhdl.arch":"Used to change the architecture name of the block/chip","vhdl.entity":"To change the name of the entity in the VHDL output","vhdl.package":"Changes the name of the generated VHDL package ","wr_stb_stages":"To add the stages in write strobe","lock_bitmask":"It is used to mask the bits of a lock, an output lock_bitmask is generated","bus.domain":"The bus domain name on which the register exists","intr.detect":"intr.detect is used to specify the detection circuitry for input interupt 					signal registered in any of register/field identified as status or 					pending","intr.in":"intr.in is used to specify name of one or multi bit interrupt input signal 					that needs to be simply ORed ,not registered in flip flops ","intr.irq_per_channel":"To generate per channel Interrupt output","intr.out":"intr.out specifies the name of the output interrupt signal,to translate it 					into RTL","uvm_regmodel_container":"to know the hierarchy of regmodel and user hierarchy","uvm_sequencer":"to change the ARV sequencer","arv_setup_seq":"to configure the block/register before ARV sequences","uvm.base_class":"To change the base class in UVM Regmodel","uvm.class":"Register class name in the Regmodel","uvm.field_class":"The field class name instance is replaced with the value in this property","uvm.handle_name_format":"used to change handle's name","uvm.inst_class":"The name of the variable that has the instance of the class","uvm.map":"Changes the name of the default map in the UVM output.","uvm.name_format":"used to change the class name","uvm.package":"The name of the package that is being generated","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","hdl_path_internal":"To prepend the value in it, to the hdl_path value.It prepend the value on internal registers only","uvm.reg_class":"The register classes will be extendedd by the class mentioned using this 					property","uvm.user_coverage":"Specify all the identifiers globally at the top level of the register 					specification in the block description. This will generate an enum of type 					“uvm_reg_cvr_t”","coverage":"Generates appropriate coverage code in the output","coverage.at_least":" ","coverage.auto_bin_max":" ","coverage.comment":" ","coverage.cross_num_print_missing":" ","coverage.detect_overlap":" ","coverage.get_inst_coverage":" ","coverage.goal":" ","coverage.per_instance":" ","coverage.weight":" ","no_reg_access_test":"Do default access tests","no_reg_bit_bash_test":"Do default bit bash tests","no_reg_hw_reset_test":"Do default hw reset tests","no_reg_tests":"Do default register tests","library":"Name of the library of the IP-XACT model","vendor":"Name of the vendor of the IP-XACT model","version":"Version number of the IP-XACT model","ipxact_ignore":"To remove Models and busInterfaces in IP-XACT","cheader.name_format":"used to customize the name of macros and structs","cheader.mask_endianess":"Used to choose endianess for mask values","compiler.arrayindex.maxvalue":"Maximum value of the array index","header.field_mask":"To suffix 'MASK' in field name of macro illustrating mask value for single bit fields","header.frwd_declr":"For forward declaration of the structs and unions","header.struct_guard":"Used to generate C header's struct within ifndef, to avoid assembler's errors","doc.default_padding":"Generates default value with padding in HTML output","default":" ","desc":" ","is_rsv":"marks all the fields of the register as reserved","repeat":"Repeat a template N number of times","variant":"Specifies the name of the Variant that the template is in","parity":" to check parity for all registers in a section","parity_error":" to check the parity bit error for all registers in a section","rtl.precedence":"To prioritize the hw or sw for write operation","virtual":"To prioritize the hw or sw for write operation","arv_setup_seq":"to configure the block/register before ARV sequences","uvm.base_class":"To change the base class in UVM Regmodel","uvm.class":"Register class name in the Regmodel","uvm.handle_name_format":"used to change handle's name","uvm.inst_class":"The name of the variable that has the instance of the class","uvm.name_format":"used to change the class name","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","coverage":"Generates appropriate coverage code in the output","no_reg_access_test":"Do default access tests","no_reg_bit_bash_test":"Do default bit bash tests","no_reg_hw_reset_test":"Do default hw reset tests","no_reg_tests":"Do default register tests","bus.domain":"The bus domain name on which the register exists","alias":"creates an alias of register or field","is_rsv":"marks all the fields of the register as reserved","lock":"locks the software access of a register depending on the value of the locking 					field","sw_bit_enable":" 					enable the bit masking of one refister from the other register 				","lock.set":"locks the software set access of a register depending on the value of the locking 					field","lock.clear":"locks the software clear access of a register depending on the value of the locking 					field","lock.toggle":"locks the software toggle access of a register depending on the value of the locking 					field","reg_default":"Specify the default value for register","reg_hw":"Specify the hw access for register","reg_sw":"Specify the sw access for register","repeat":"Repeat a template N number of times","rwpair":"Creates RO_WO pair register at same address","variant":"Specifies the name of the Variant that the template is in","alt_reg":"Declares Deafualt register in virtual register array","alt_mode":"Declares alternate view registers of Default register depending on the value of a signal in virtual register array","parity":" to check parity for a register","parity_error":" to check the parity bit error for a register","tmr":"to reduce redundancy","buffer_trig":"used to specify a field of any register as a trigger","buffer_trig_reg":"used to specify a register as a trigger for another register","cdc.clock":"Add Clock Domain Crossing synchronizers to the field signals","clock_edge":"Clock edge used for implementing registers","hard_reset":"To remove hard reset from the generated RTL","page_count":"To specify number of copies of a Paged register","page_select":"To specify the select signal for 'n' number of Paged Registers, where 'n' is value of 'page_count'","rd_stb_stages":"To add the stages in read strobe","reg_prot":"To protect the register from the SW (APB bus) side","reg_rprot":"To protect the register to read its value from the SW (AXI bus) side","reg_wprot":"To protect the register from the SW ( AXI bus) side","registered":"Indicates whether to register the signal coming into the generated module from 					the hardware side. Hardware access must be set to writeable","reset_level":"Specifies the level of the reset for the registers","resetsignal":"External input signals to reset the field(soft reset)","reset_type":"Specifies the type of reset for generated registers","rtl.default":"Default value through signals","rtl.hw_clear":"A field can be cleared whenever a signal from the application logic or 					hardware interface is asserted high","rtl.hw_enb":"Used to disable the register's field enable signal for hardware write interface","rtl.hw_rp":"A pulse is generated whenever a field is read through the bus interface","rtl.hw_w1p":"A pulse is generated whenever 1 is written to a field through the bus 					interface","rtl.hw_w0p":"A pulse is generated whenever 1 is written to a field through the bus 					interface","rtl.hw_wp":"A pulse is generated whenever a write happens to a field through the bus 					interface","rtl.reg_enb":"Used to enable/disable 'reg_enb', to check if register has been written from software interface or not","rtl.precedence":"To prioritize the hw or sw for write operation","shadow_address":"Address of the register that is to be 'shadowed'. More than one register can 					shadow a single register","undefined_rd_val":"To set the undefined (reserved) bits of the register ","wr_stb_stages":"To add the stages in write strobe","aliased":"To alias registers in different blocks","halt.enable":"enables the halt signal to propagate to CPU","uvm.field_class":"The field class name instance is replaced with the value in this property","halt.mask":"Halt mask bit corresponding to Status register bit decides that those halt signals will not be allowed to propagate to main halt signal","intr.detect":"intr.detect is used to specify the detection circuitry for input interupt 					signal registered in any of register/field identified as status or 					pending","intr.enable":"Identifies the enable register for the interrupt logic","intr.irq_bit":"The ored value of all the interrupt channel after enable control logic can be 					registered and is stored in a field.Output interrupt signal specified in 					property intr.out is registered in this field","intr.mask":"intr.mask is used to specify the mask register for the interrupt logic","intr.pending":"Identifies the pending register for the interrupt logic","intr.post":"int.post is used to register software driven interrupts","intr.status":"Identifies the status register for the interrupt logic","bus.domain":"The bus domain name on which the register exists","clock_name":"This specifies the clock name on which the register exists","arv_setup_seq":"to configure the block/register before ARV sequences","constraint":"Specifies the constraint on the value","depth":"Depth of the index register","dontcompare":"Eliminates the specified reg or field from verification. It adds compare 					(UVM_NO_CHECK) on the specified fields","index_reg":"Name of the index register","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","uvm.base_class":"The class which is extended by the generated class","uvm.class":"The name of the generated class","uvm.handle_name_format":"used to change handle's name","uvm.inst_class":"The name of the variable that has the instance of the class","uvm.name_format":"used to change the class name","format":" Changes Real Numbers to Fixed Integers","coverage":"Generates appropriate coverage code in the output","coverage.at_least":" ","coverage.auto_bin_max":" ","coverage.comment":" ","coverage.cross_num_print_missing":" ","coverage.detect_overlap":" ","coverage.get_inst_coverage":" ","coverage.goal":" ","coverage.per_instance":" ","coverage.weight":" ","no_reg_access_test":"Do default access tests","no_reg_bit_bash_test":"Do default bit bash tests","no_reg_hw_reset_test":"Do default hw reset tests","no_reg_tests":"Do default register tests","repeat":"Repeat a template N number of times","hw":" ","sw":" ","alias":"creates an alias of register or field","is_rsv":"marks all the fields of the register as reserved","lock":"locks the software access of a register depending on the value of the locking 					field","lock.set":"locks the software set access of a register depending on the value of the locking 					field","lock.clear":"locks the software clear access of a register depending on the value of the locking 					field","lock.toggle":"locks the software toggle access of a register depending on the value of the locking 					field","variant":"Specifies the name of the Variant that the template is in","hard_reset":"To remove hard reset from the generated RTL","reset_level":"Specifies the level of the reset for the registers","reset_type":"Type of reset for the registers","tmr":"to reduce redundancy","cdc.clock":"Add Clock Domain Crossing synchronizers to the field signals","next":"It describes next input value of field","registered":"Indicates whether to register the signal coming into the generated module from 					the hardware side. Hardware access must be set to writeable.","resetsignal":"External input signals to reset the field(soft reset)","rtl.default":"Default value through signals","rtl.hw_clear":"A field can be cleared whenever a signal from the application logic or 					hardware interface is asserted high","rtl.hw_enb":"Used to disable the register's field enable signal for hardware write interface","rtl.hw_rp":"A pulse is generated whenever a field is read through the bus interface","rtl.hw_w1p":"A pulse is generated whenever 1 is written to a field through the bus 					interface","rtl.hw_wp":"A pulse is generated whenever a write happens to a field through the bus 					interface","rtl.hw_w0p":"A pulse is generated whenever a write happens to a field through the bus 					interface","we":" To change write enable of specific field. ","aliased":"To alias registers in different blocks","counter":"This specifies whether the counter will be incrementing or decrementing","counter.decr.sat":"This specifies the value after which the decrementing counter will stop 					decrementing","counter.incr.sat":"This specifies the value after which the incrementing counter will not 					increment","counter.decr.thld":"This specifies the value after which the decrementing counter will start 					decrementing","counter.incr.thld":"This specifies the value after which the incrementing counter will start 					incrementing","counter.decr.val":"This specifies the value by which the counter is decremented","counter.incr.val":" ","counter.sw.wr":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","counter.sw.rd":"To specify that the counter is incrementing/decrementing for read operation from SW interface. ","counter.precedence":"Used to change the sequence of precedence for all three type of counters","counter.sat":"This specifies that the counter is saturated and the saturation by default is 					2^(number of bits) if the counter.decr.sat or counter.incr.sat is not 					specified","counter.signal":"Used to specify the signal that controls the increment and decrement events of a counter. It is an Active-High event.","counter.hw.enb":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","counter.sw.wr.enb":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","counter.sw.rd.enb":"To specify that the counter is incrementing/decrementing for write operation from SW interface. ","halt.enable":"enables the halt signal to propagate to CPU","halt.mask":"Halt mask bit corresponding to Status register bit decides that those halt signals will not be allowed to propagate to main halt signal","intr.detect":"intr.detect is used to specify the detection circuitry for input interupt 					signal registered in any of register/field identified as status or 					pending","intr.enable":"Identifies the enable register for the interrupt logic","intr.mask":"intr.mask is used to specify the mask register for the interrupt logic","intr.nonsticky":"intr.nonsticky property defines a nonsticky interrupt. The associated interrupt field shall not ne locked","intr.pending":"Identifies the pending register for the interrupt logic","intr.post":"int.post is used to register software driven interrupts","intr.status":"Identifies the status register for the interrupt logic","constraint":"Specifies the constraint on the value","no_field_tests":"no enable/disable the sequence on fields","dontcompare":"Eliminates the specified reg or field from verification. It adds compare 					(UVM_NO_CHECK) on the specified fields","has_reset":"A value of 1 indicates a hard reset, a value of 0 indicates that the reset is 					ignored by the UVM model","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","is_acc":"Specifies if the field can be individually accessible","is_rand":"Specifies if the field is randomizable","uvm.handle_name_format":"used to change handle's name","volatile":"Used to set the volatility of the field.","format":" Changes Real Numbers to Fixed Integers","sw":"Changes the software access of memory from default 'ro' to 'rw'","clock":"To specify separate clock for hardware side clock port","hw_access":"Specifies the hardware side port access","rd_enb":"specifying read enable for hardware side read","read_access":"Specify the read access of the hardware port","reg_rd_addr":"Specifying that the address of the memory is from hardware side","sw_access":"Specifies the software side port access","sync_reset":"For specifying the synchronous behavior of the reset","wr_enb":"specifying write enable for hardware side write","coverage":"Generates appropriate coverage code in the output","coverage.at_least":" ","coverage.auto_bin_max":" ","coverage.comment":" ","coverage.cross_num_print_missing":" ","coverage.detect_overlap":" ","coverage.get_inst_coverage":" ","coverage.goal":" ","coverage.per_instance":" ","coverage.weight":" ","no_mem_access_test":"Do default memory access tests","no_mem_tests":"Do default memory tests","no_mem_walk_test":"Do default memory walk tests","uvm.name_format":"used to change the class name","uvm.handle_name_format":"used to change handle's name","hdl_path":"Hierarchical path to the RTL storage of the element","hdl_path_gates":"Hierarchical path to the RTL storage of the element","type":" describe the type of FIFO (sync/async)","fifo.empty":" describe the empty flag assignment ","fifo.full":" describe the full flag assignment ","fifo.almost_empty_val":" used to specify the value of almost empty flag","fifo.almost_full_val":" used to specify the value of almost full flag","fifo.almost_empty":" describe the almost empty flag assignment","fifo.almost_full":" describe the almost full flag assignment","desc":" ","desc":" ","desc":" ","desc":" ","desc":" ","desc":" ","export":"False value to this property, does not create signal at IP level in IPXACT","field_reset":"Used to make a signal, default soft reset for the block ","level":"To change the level of signal to active high or active low, this property can be used ","ref":"To reference the signals present in other blocks"};