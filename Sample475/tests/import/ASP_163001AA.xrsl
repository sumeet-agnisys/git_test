<?xml version="1.0" encoding="ISO-8859-1"?><block name="reg_map" offset="4295000064" id="2:2" coverage="on" module_name="reg_map" output_file_name="reg_map" reset_type="async" rtl.bit_enable="true" rtl.byte_enable="true" u_field_names="true" u_use_eeprom="true" gen_pin_complex_functions="false" u_use_cp="true" lock_bitmask="true"><config>
      <blocksize>448</blocksize>
   <regwidth>32</regwidth><buswidth>32</buswidth><regbits>7</regbits><blockbits>0</blockbits><chipbits>0</chipbits><addressunit>32</addressunit><variants><variant name="none" isselected="true">
         <doc>'none' variant states including all templates which are not assigned any variant property.</doc>
      </variant></variants></config>
   
   <doc> </doc>
<section name="volatile" id="3:2" ><reg name="status0" external="true" id="4:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="3:0" name="dsc_major" id="4:10" hdl_path="dsc_major">
      <doc>Die Source Code for full-level revisions\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
   <field offset="7:4" name="dsc_minor" id="4:11" hdl_path="dsc_minor">
      <doc>Die Source Code for metal revisions\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="cfg0" id="5:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_cfg0_" no_reg_tests="true" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc>     </doc>
   <field offset="0" name="pdiff_we" id="5:10" hdl_path="pdiff_we_q" u_override="true">
      <doc>Freezes pdiff signal and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="diff_we" id="5:11" hdl_path="diff_we_q" u_override="true">
      <doc>Freezes diff signal and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="2" name="tdiff_we" id="5:12" hdl_path="tdiff_we_q" u_override="true">
      <doc>Freezes tdiff signal and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="3" name="hallphase_we" id="5:13" hdl_path="hallphase_we_q" u_override="true">
      <doc>Freezes hallphase signal and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="4" name="state_we" id="5:14" hdl_path="state_we_q" u_override="true">
      <doc>Freezes state register and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="5" name="temperature_we" id="5:15" hdl_path="temperature_we_q" u_override="true">
      <doc>Freezes temperature signal and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="6" name="out_we" id="5:16" hdl_path="out_we_q" u_override="true">
      <doc>Freezes out signal and makes it writeable.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="7" name="samp_dis" id="5:17" hdl_path="samp_dis_q">
      <doc>Disables samp outputs.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="8" name="conv_dis" id="5:18" hdl_path="conv_dis_q">
      <doc>Disables conv outputs.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="10:9" name="eforce_mode" id="5:19" hdl_path="eforce_mode_q">
      <doc>EFORCE phase mode.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="11" name="force_hallshort" id="5:20" hdl_path="force_hallshort_q">
      <doc>Short Hallplate.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="12" name="out_risetime" id="5:21" hdl_path="out_risetime_q">
      <doc>Obsolete. Currently unused.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="13" name="force_timeout" id="5:22" hdl_path="force_timeout_q">
      <doc>Forces a watchdog timeout event.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="14" name="tpo_auto_update" id="5:23" hdl_path="tpo_auto_update_q" u_ids_external="true">
      <doc>Write '1' to copy the value of TDIFF into the FACT_TPO field in the EEPROM. This bit is a self-clearing one-shot.  </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="15" name="force_tpo" id="5:24" hdl_path="force_tpo_q">
      <doc>Force TPO state regardless of the current state of the controller.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="16" name="cpump_load" id="5:25" hdl_path="cpump_load_q">
      <doc>Adds excess load to the regulator charge pump to test its load margin.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="17" name="out_prog_en" id="5:26" hdl_path="out_prog_en_q">
      <doc>Controls whether programming is performed via the VCC or output pins:\n0 = VCC programming.\n1 = Output programming.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="20:18" name="spare_cfg0" id="5:27" hdl_path="spare_cfg0_q">
      <doc>Spare bits\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
</reg><reg name="cfg1" id="6:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_cfg1_" lock="(shadow_a.lock_o &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="eol_diag_en" id="6:10" hdl_path="eol_diag_en_q">
      <doc>Write '1' to enable EOL diagnostic function\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x00</default>
   </field>
</reg><reg name="cfg2" id="7:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_cfg2_" no_reg_tests="true" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="adc_test_start" id="7:10" hdl_path="adc_test_start_q" u_ids_external_write="true">
      <doc>Start ADC self test (clears when finished).\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="auto_hall_start" id="7:11" hdl_path="auto_hall_start_q" u_ids_external_write="true">
      <doc>Start Hall Automatic Trim (clears when finished).\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="14:8" name="auto_hall_target" id="7:12" hdl_path="auto_hall_target_q">
      <doc>User settable Hall Automatic Trim target\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
</reg><reg name="test_result" external="true" id="8:2" coverage="on" no_reg_tests="true" ignore_prop="hdl_path">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="7:0" name="seq_conv_result" id="8:10" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_test_adc_sar.seq_conv_result">
      <doc>Results from ADC self test.  The maximum difference seen between sequential conversions:\n\n </doc>
      <sw>ro</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="15:8" name="sar_result" id="8:11" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_test_adc_sar.sar_result">
      <doc>Results from ADC Self Test.  The maximum difference seen between corrected SAR results:\n\n </doc>
      <sw>ro</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="hallphase" external="true" id="9:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_scheduler.hallphase" no_reg_tests="true" lock="!cfg0.hallphase_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="3:0" name="hallphase" id="9:10">
      <doc>Hallphase value in the ADC. Can be overwritten only when hallphase_we is previously set.</doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0</default>
   </field>
</reg><reg name="state" external="true" id="10:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.state" no_reg_tests="true" lock="!cfg0.state_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="2:0" name="state" id="10:10">
      <doc>Controller State Machine state value.\n0 = RESET \n1 = WAIT\n2 = IDLE\n3 = HYST\n4 = CAL\n5 = CAL4\n6 = Running Mode\n7 = Reserved\nCan be overwritten only when state_we is previously set.</doc>
      <sw>rw</sw>
      <hw>wo</hw>
      <default>0</default>
   </field>
</reg><reg name="temperature" external="true" id="11:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_temp_filter.temperature" no_reg_tests="true" lock="!cfg0.temperature_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="15:0" name="temperature" id="11:10">
      <doc>Temperature sensor output result. Can be overwritten only when temperature_we is previously set. </doc>
      <sw>rw</sw>
      <hw>wo</hw>
      <default>0x8000</default>
   </field>
</reg><reg name="pdiff" external="true" id="12:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_adc.pdiff" no_reg_tests="true" lock="!cfg0.pdiff_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="13:0" name="pdiff" id="12:10">
      <doc>PDIFF value (output of ADC). Can be overwritten only when pdiff_we is previously set. </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="diff" external="true" id="13:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_filter.diff" no_reg_tests="true" lock="!cfg0.diff_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff" id="13:10">
      <doc>DIFF value (output of filter). Can be overwritten only when diff_we is previously set. </doc>
      <sw>rw</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="tdiff" external="true" id="14:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_temp_compensate.tdiff" no_reg_tests="true" lock="!cfg0.tdiff_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="tdiff" id="14:10">
      <doc>TDIFF value (output of temperature compensation block). </doc>
      <sw>rw</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="out" external="true" id="15:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.out" no_reg_tests="true" lock="!cfg0.out_we">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="out" id="15:10">
      <doc>Out value (output of controller block). </doc>
      <sw>rw</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="ppeak" external="true" id="16:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.ppeak" no_reg_tests="true">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="ppeak" id="16:10">
      <doc>PPEAK register from CSM block.  Read Only.</doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="plast" external="true" id="17:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.plast" no_reg_tests="true">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="plast" id="17:10">
      <doc>PLAST register from CSM block.  Read Only.</doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="npeak" external="true" id="18:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.npeak" no_reg_tests="true">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="npeak" id="18:10">
      <doc>NPEAK register from CSM block.  Read Only.</doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="stored_tpo" external="true" id="19:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_tpo_read_write.stored_tpo" no_reg_tests="true">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="stored_tpo" id="19:10">
      <doc>Calculated TPO threshold value. Read Only.</doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="ee_cfg" offset="192" id="20:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_ee_cfg_" no_reg_tests="true">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="ee_erase" id="20:10" hdl_path="ee_erase_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Setting this bit will perform an ERASE operation only on the EEPROM the next time an EEPROM address is written. It is self-clearing when the ERASE operation is complete.  </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="ee_prog" id="20:11" hdl_path="ee_prog_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Setting this bit will perform a PROGRAM operation only on the EEPROM the next time and EEPROM address is written. If ERASE is set, this bit is ignored. It is self-clearing when the PROGRAM operation is complete.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="3:2" name="ee_block_mode" id="20:12" hdl_path="ee_block_mode_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>00: Single Word Write Access\n01: Odd Word Write Access (address ignored)\n10: Even Word Write Access (address ignored)\n11: All Word Write Access  (address ignored)\nThis field only affects write operations.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="6:4" name="ee_vread" id="20:13" hdl_path="ee_vread_q">
      <doc>VREAD EEPROM setting per EEPROM V3.0 spec  \nAvailable post lock</doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="7" name="ee_force_sbe" id="20:14" hdl_path="ee_force_sbe_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Forces a single bit error \n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="8" name="ee_force_dbe" id="20:15" hdl_path="ee_force_dbe_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Forces a multi bit error\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="9" name="ee_dis_ecc" id="20:16" hdl_path="ee_dis_ecc_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)" u_ids_external_write="true">
      <doc>0: Correct Single bit errors when they occur\n1: Do not correct single bit errors when they occur  </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="10" name="ee_no_ecc" id="20:17" hdl_path="ee_no_ecc_q" u_ids_external_write="true">
      <doc>0: Upper bits of EEPROM is written with ECC bits. \n1: EEPROM is written with all bits of raw data. During a read, all bits of raw data is returned.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="11" name="ee_raw_ecc" id="20:18" hdl_path="ee_raw_ecc_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)" u_ids_external_write="true">
      <doc>0 0: Bits [31:26] of an EEPROM READ return the following read status information. \nBit 31 = 0\nBit 30 = 0\nBit 29 = 1 if double bit error, 0 if not\nBit 28 = 1 if single bit error, 0 if not\nBit 27 = 0\nBit 26 = 0\n\n1: Bits [31:26] of an EEPROM READ return the 6 bit ECC code\n\s </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="12" name="ee_en_override" id="20:19" hdl_path="ee_en_override_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>0: Normal operation\n1: Force ee_en output high\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="14:13" name="ee_override" id="20:20" hdl_path="ee_override_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>00: Normal operation\n01: Force ee_rd output high\n10: Force ee_er output high\n11: Force ee_pr output high\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="15" name="ee_force_reload" id="20:21" hdl_path="ee_force_reload_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Write to a 1 to reload all shadow registers with EEPROM values. If the noload test pad or ee_noload is set the reload will not occur.  </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="16" name="ee_noload" id="20:22" hdl_path="ee_noload_q" lock="(shadow_a.lock_c &amp; shadow_a.lock_o &amp; !unlock.unlock)">
      <doc>When set shadow will not update when eeprom is written  </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="17" name="ee_abort" id="20:23" hdl_path="ee_abort_q" lock="(shadow_a.lock_t  &amp; !unlock.unlock)">
      <doc>When set the eeprom controller will abort the current action return to idle\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="cp_cfg" id="21:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_cp_cfg_" no_reg_tests="true" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="cp_force_en" id="21:10" hdl_path="cp_force_en_q">
      <doc>0: Normal operation\n1: Force cp_en output high\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="cp_use_dac" id="21:11" hdl_path="cp_use_dac_q">
      <doc>0: Normal operation\n1: The value in CP_DAC drives the cp_dac[5:0] output\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="7:2" name="cp_dac" id="21:12" hdl_path="cp_dac_q">
      <doc>This value is driven on cp_dac[5:0] ouput when cp_use_dac is set\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="8" name="cp_dis_abort" id="21:13" hdl_path="cp_dis_abort_q">
      <doc>0: Normal operation\n1: EEPROM write (or erase, program) will not abort if ee_prog_pulse is not at correct value\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="9" name="cp_err" id="21:14" hdl_path="cp_err_q">
      <doc>High to indicate an error occurred during charge pump ramp. ee_err_status stores information about the error. \n </doc>
      <sw>rc</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
   <field offset="11:10" name="cp_cntrl" id="21:15" hdl_path="cp_cntrl_q">
      <doc>Directly drives cp_cntrl[7:0] ouputs to control charge pump.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="13:12" name="cp_rup_sel" id="21:16" hdl_path="cp_rup_sel_q">
      <doc>Selects the ramp up time for the charge pump. Values are TBD.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="15:14" name="cp_hv_sel" id="21:17" hdl_path="cp_hv_sel_q">
      <doc>Selects the time the cp_dac remains at its max value (0x3F). Values are TBD.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="17:16" name="cp_rdn_sel" id="21:18" hdl_path="cp_rdn_sel_q">
      <doc>Selects the ramp down time for the charge pump. Values are TBD.\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
</reg><reg name="ee_status" id="22:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_ee_status_" no_reg_tests="true">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="ee_dbe_flag" id="22:10" hdl_path="ee_dbe_flag_q" lock="shadow_a.lock_t" u_ids_external="true">
      <doc>Set if a dual bit error has occurred. This bit is clear on read. Cannot be unlocked with unlock pad.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="ee_sbe_flag" id="22:11" hdl_path="ee_sbe_flag_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Set if a single bit error has occurred. This bit is clear on read.  </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="2" name="ee_err" id="22:12" hdl_path="ee_err_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Error flag, goes high when an error occurs during an eeprom write  </doc>
      <sw>rc</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
   <field offset="7:3" name="ee_err_status" id="22:13" hdl_path="ee_err_status_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Status of when the last eeprom error.\nBit 4: 0 - error occurred during erase, 1 - error occurred during program.\nBit 3: 0 - error occurred during Ramp Up, 1 - error occurred during Ramp Down.\nBit 2: Program Pulse value.\nBit 1: hlat value.\nBit 0: llat value.\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
   <field offset="11:8" name="ee_addr" id="22:14" hdl_path="ee_addr_q">
      <doc>Contains the address for an EEPROM access. On a write or a read to EEPROM this register is updated with the access address. This address is the first read on powerup and the default should point to the row containing the oscillator trim.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x9</default>
   </field>
   <field offset="17:12" name="ee_ecc" id="22:15" hdl_path="ee_ecc_q">
      <doc>Contains the ecc for an eeprom access. On a write this register contains the written ecc, on a read this register contains the read ecc.  </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="ee_data" id="23:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_ee_data_" no_reg_tests="true" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="25:0" name="ee_data" id="23:10" hdl_path="ee_data_q">
      <doc>Contains the data for an eeprom access. On a write this register contains the written data, on a read this register contains the read data.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="pat_test" id="24:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_pat_test_" no_reg_tests="true" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="pat_test_start" id="24:10" hdl_path="pat_test_start_q">
      <doc>Write to 1 to start pattern check testing. If EE_LOOP is low, this bit will self clear when the last address is reached. If EE_LOOP is high, this bit must be written to 0 to stop test. This bit always clears on a fail.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="2:1" name="pat_test_status" id="24:11" hdl_path="pat_test_status_q">
      <doc>Bits are cleared after a read or reset.\n\s\s00: Reset condition (no result from pat testing)\n\s\s01: Pass, no failure detected during pat testing\n\s\s10: Fail, failure detected during pat testing\n\s\s11: Running, pat test is still running\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
   <field offset="4:3" name="pat_test_pattern" id="24:12" hdl_path="pat_test_pattern_q">
      <doc>Defines the pattern that will be checked when reading the EEPROM.\n00: All 0s\n01: All 1s\n10: Checker board starting at 0x0 with '010101.'\n11: Checker board starting at 0x0 with '101010.'  </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
</reg><reg name="marg_test" id="25:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_marg_test_" no_reg_tests="true" lock="(shadow_a.lock_c &amp; shadow_a.lock_o &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="margin_start" id="25:10" hdl_path="margin_start_q" u_ids_external_read="true">
      <doc>Write to 1 to start margin testing. If EE_LOOP is low, this bit will self clear when address 0xB is reached. If EE_LOOP is high, this bit must be written to 0 to stop test. This bit always clears on a fail.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="margin_no_max" id="25:11" hdl_path="margin_no_max_q">
      <doc>0: Max reference voltage will be used during margin testing\n1: Max voltage reference will be skiped during margin testing\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="2" name="margin_no_min" id="25:12" hdl_path="margin_no_min_q">
      <doc>0: Min reference voltage will be used during margin testing\n1: Min voltage reference will be skiped during margin testing\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="4:3" name="margin_status" id="25:13" hdl_path="margin_status_q" u_ids_external_read="true">
      <doc>Bits are cleared after a read or reset.\n\s\s00: Reset condition (no result from margin testing)\n\s\s01: Pass, no failure detected during margin testing\n\s\s10: Fail, failure detected during margin testing\n\s\s11: Running, margin test is still running\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
   <field offset="5" name="margin_min_max_fail" id="25:14" hdl_path="margin_min_max_fail_q">
      <doc>If margining fails, this bit indicates if the min or max reference failed.\n0: Min margining failed.\n1: Max margining failed.\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg><reg name="test_cfg" id="26:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.volatile_test_cfg_" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="ee_loop" id="26:10" hdl_path="ee_loop_q">
      <doc>0: Test completes at final address or fail\n1: Test loops until MARGIN_START is written low or fail.   </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="ee_use_test_addr" id="26:11" hdl_path="ee_use_test_addr_q">
      <doc>0: No effect\n1: Uses EE_TST_ADDR as the start address for margining. \nIf EE_LOOP is set, this bit is ignored and the starting address is always 0x0\n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
   <field offset="5:2" name="ee_test_addr" id="26:12" hdl_path="ee_test_addr_q">
      <doc>If USE_TST_ADDR is set, then margining or check testing will start at this address. If the test fails, this will contain the failing address. \n </doc>
      <sw>rw</sw>
      <hw>ro</hw>
      <default>0x0</default>
   </field>
</reg><reg name="unlock" external="true" id="27:2" coverage="on" no_reg_hw_reset_test="true" ignore_prop="hdl_path">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="unlock" id="27:10" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.unlock">
      <doc>Unlock\n </doc>
      <sw>ro</sw>
      <hw>wo</hw>
      <default>0x0</default>
   </field>
</reg></section><section name="shadow" offset="272" id="29:2" ><reg name="shadow_4" id="30:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.shadow_shadow_4_" u_shadow_address="0x64" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="2:0" name="spare_4" id="30:10" hdl_path="spare_4_q">
      <doc>Spare bits.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="5:3" name="rmt" id="30:11" hdl_path="rmt_q">
      <doc>Running Mode Transition. \nDetermines the conditions to transition from the output controlled by TPO (at power on) to output controlled by threshold POSCOMP\n3'd0 = Fast Swap (as soon as P/N PEAKs separate)\n3'd1 = Qualified Swap (after one tooth)\n3'd2 = Always TPO\n3'd3 = Fastish Swap (like Fast, but requires larger separation)\n3'd4 = TBD (stays in TPO for teeth?)\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="6" name="pol" id="30:12" hdl_path="pol_q">
      <doc>Polarity.\nInverts the polarity of the analog output driver operation.  No effect on internal signals.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="7" name="aggr" id="30:13" hdl_path="aggr_q">
      <doc>Aggressive Update.\nEnables NPEAK aggressive update. (Default is conservative)\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="11:8" name="teeth" id="30:14" hdl_path="teeth_q">
      <doc>Number of Teeth sequences.\nThe sensor will remember peak levels for the indicated number of theeth. This should be set to match the number of target teeth.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="12" name="wdog_en" id="30:15" hdl_path="wdog_en_q">
      <doc>Watchdog Enable.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="fact_tpo" id="30:16" hdl_path="fact_tpo_q">
      <doc>Factory TPO value.\nDefault switching threshold for device from power on to RMT.  May be superseded by thresh_a/b/c.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="shadow_5" id="31:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.shadow_shadow_5_" u_shadow_address="0x65" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="3:0" name="thrr" id="31:10" hdl_path="thrr_q">
      <doc>Threshold for the rising edge.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="7:4" name="thrf" id="31:11" hdl_path="thrf_q">
      <doc>Threshold for the falling edge.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="8" name="ffall" id="31:12" hdl_path="ffall_q">
      <doc>Obsolete. Currently unused.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="9" name="fb_test" id="31:13" hdl_path="fb_test_q">
      <doc>ADC Feedback test mode.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="10" name="dem_test" id="31:14" hdl_path="dem_test_q">
      <doc>SAR DEM test mode.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="11" name="fe_cal_dis" id="31:15" hdl_path="fe_cal_dis_q">
      <doc>FE Calibration disable, holds segment and chop weights at 0.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="12" name="variable_chop" id="31:16" hdl_path="variable_chop_q">
      <doc>Enables variable chopping.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="13" name="adc_filter_sel" id="31:17" hdl_path="adc_filter_sel_q">
      <doc>Selects filter settings.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="14" name="tpoself_dis" id="31:18" hdl_path="tpoself_dis_q">
      <doc>Disables TPO self write.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="15" name="tpoself_lvl" id="31:19" hdl_path="tpoself_lvl_q">
      <doc>Level for TPO self write.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="19:16" name="temp_comp" id="31:20" hdl_path="temp_comp_q">
      <doc>Temperature compensation value.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="shadow_6" id="32:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.shadow_shadow_6_" u_shadow_address="0x66" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff_baseline_40" id="32:10" hdl_path="diff_baseline_40_q">
      <doc>The DIFF value to be offset to mid scale at -40 ºC.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="diff_tpo_40" id="32:11" hdl_path="diff_tpo_40_q">
      <doc>The TPO level at cold to be gain corrected to match 25 ºC.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="shadow_7" id="33:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.shadow_shadow_7_" u_shadow_address="0x67" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff_baseline_25" id="33:10" hdl_path="diff_baseline_25_q">
      <doc>The DIFF value to be offset to mid scale at 25 ºC.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="diff_tpo_25" id="33:11" hdl_path="diff_tpo_25_q">
      <doc>The reference TPO level.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="shadow_8" id="34:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ids_top.u_reg_map.shadow_shadow_8_" u_shadow_address="0x68" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff_baseline_165" id="34:10" hdl_path="diff_baseline_165_q">
      <doc>The DIFF value to be offset to mid scale at 165 ºC.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="diff_tpo_165" id="34:11" hdl_path="diff_tpo_165_q">
      <doc>The TPO level at hot to be gain corrected to match 25 ºC.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="shadow_9" id="35:2" coverage="on" u_shadow_address="0x69" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="6:0" name="halltrim" id="35:10" registered="false" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_halltrim.register">
      <doc>Hall Plate Trim (available at reset).\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x7F</default>
   </field>
   <field offset="11:7" name="osc_trim" id="35:11" registered="false" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_osc_trim.register">
      <doc>Oscillator Trim (available at reset).\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="16:12" name="ref_bg_trim" id="35:12" registered="false" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ref_bg_trim.register">
      <doc>Reference Bandgap Trim (available at reset).\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="17" name="out_fastfall" id="35:13" registered="false" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_out_fastfall.register">
      <doc>Output fall time trim.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="shadow_a" id="36:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top." u_shadow_address="0x6a">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="lock_t" id="36:10" hdl_path="lock_t_in" registered="false" ignore_prop="hdl_path" lock="(shadow_a.lock_t &amp; (shadow_a.lock_bd | !unlock.unlock))">
      <doc>See EEPROM Section\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="lock_a" id="36:11" hdl_path="lock_a_in" registered="false" ignore_prop="hdl_path" lock="shadow_a.lock_a | (shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>See EEPROM Section\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="2" name="lock_c" id="36:12" hdl_path="lock_c_in" registered="false" ignore_prop="hdl_path" lock="shadow_a.lock_c | (shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>See EEPROM Section\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="3" name="lock_o" id="36:13" hdl_path="lock_o_in" registered="false" ignore_prop="hdl_path" lock="shadow_a.lock_o | (shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>See EEPROM Section\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="4" name="lock_s" id="36:14" hdl_path="lock_s_in" registered="false" ignore_prop="hdl_path" lock="shadow_a.lock_s | (shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>See EEPROM Section\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="5" name="lock_bd" id="36:15" hdl_path="u_ids_top.u_reg_map.shadow_shadow_a_lock_bd_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>See EEPROM Section\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="8:6" name="spare_a_1" id="36:16" hdl_path="u_ids_top.u_reg_map.shadow_shadow_a_spare_a_1_q" lock="(shadow_a.lock_t &amp; !unlock.unlock)">
      <doc>Spare bits\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg></section><section name="eeprom" offset="384" external="true" id="38:2" u_ids_external="true" wr_rd_valids="true" >
   <doc> </doc>
<reg name="eeprom_0" id="39:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[0]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="25:0" name="factory_0" id="39:10">
      <doc>Reserved for factory production use.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="39:11">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_1" id="40:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[1]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="25:0" name="factory_1" id="40:10">
      <doc>Reserved for factory production use.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="40:11">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_2" id="41:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[2]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="25:0" name="factory_2" id="41:10">
      <doc>Reserved for factory production use.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="41:11">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_3" id="42:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[3]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="25:0" name="factory_3" id="42:10">
      <doc>Reserved for factory production use.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="42:11">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_4" id="43:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[4]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="2:0" name="spare_4" id="43:10">
      <doc>Spare bits. Shadowed.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="5:3" name="rmt" id="43:11">
      <doc>Running Mode Transition.\nDetermines the conditions to transition from the output controlled by TPO (at power on) to output controlled by threshold POSCOMP\n3'd0 = Fast Swap (as soon as P/N PEAKs separate)\n3'd1 = Qualified Swap (after one tooth)\n3'd2 = Always TPO\n3'd3 = Fastish Swap (like Fast, but requires larger separation)\n3'd4 = TBD (stays in TPO for teeth?)</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="6" name="pol" id="43:12">
      <doc>Polarity.\nInverts the polarity of the analog output driver operation.  No effect on internal signals.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="7" name="aggr" id="43:13">
      <doc>Aggressive Update.\nEnables NPEAK aggressive update. (Default is conservative) </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="11:8" name="teeth" id="43:14">
      <doc>Number of Teeth.\nThe sensor will remember peak levels for the indicated number of theeth. This should be set to match the number of target teeth.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="12" name="wdog_en" id="43:15">
      <doc>Watchdog Enable.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="fact_tpo" id="43:16">
      <doc>Default tpo value.\nDefault switching threshold for device from power on to RMT.  May be superseded by thresh_a/b/c</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="43:17">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_5" id="44:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[5]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="3:0" name="thrr" id="44:10">
      <doc>Threshold for the rising edge</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="7:4" name="thrf" id="44:11">
      <doc>Threshold for the falling edge.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="8" name="ffall" id="44:12">
      <doc>Obsolete. Currently unused.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="9" name="fb_test" id="44:13">
      <doc>ADC Feedback test mode.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="10" name="dem_test" id="44:14">
      <doc>SAR DEM test mode.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="11" name="fe_cal_dis" id="44:15">
      <doc>FE Calibration disable, holds segment and chop weights at 0.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="12" name="variable_chop" id="44:16">
      <doc>Enables variable chopping.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="13" name="adc_filter_sel" id="44:17">
      <doc>Selects filter settings.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="14" name="tpoself_dis" id="44:18">
      <doc>Disables TPO self write.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="15" name="tpoself_lvl" id="44:19">
      <doc>Level for TPO self write.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="19:16" name="temp_comp" id="44:20">
      <doc>Temperature compensation value.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:20" name="spare_5" id="44:21">
      <doc>Spare bits.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="44:22">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_6" id="45:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[6]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff_baseline_40" id="45:10">
      <doc>The DIFF value to be offset to mid scale at -40 ºC.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="diff_tpo_40" id="45:11">
      <doc>The TPO level at cold to be gain corrected to match 25 ºC.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="45:12">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_7" id="46:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[7]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff_baseline_25" id="46:10">
      <doc>The DIFF value to be offset to mid scale at 25 ºC.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="diff_tpo_25" id="46:11">
      <doc>The reference TPO level.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="46:12">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_8" id="47:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[8]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="diff_baseline_165" id="47:10">
      <doc>The DIFF value to be offset to mid scale at 165 ºC.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="diff_tpo_165" id="47:11">
      <doc>The TPO level at hot to be gain corrected to match 25 ºC.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="47:12">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_9" id="48:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[9]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="6:0" name="halltrim" id="48:10">
      <doc>Hall Plate Trim.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="11:7" name="osc_trim" id="48:11">
      <doc>Oscillator Trim (available at reset).</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="16:12" name="ref_bg_trim" id="48:12">
      <doc>Reference Bandgap Trim.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="17" name="out_fastfall" id="48:13">
      <doc>Output fall time trim.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:18" name="spare_9" id="48:14">
      <doc>Spare bits. These are external, don't shadow.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="48:15">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_a" id="49:2" coverage="on" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[10]" ignore_prop="hdl_path">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="lock_t" id="49:10" lock="shadow_a.lock_t &amp; (shadow_a.lock_bd | !unlock.unlock)">
      <doc>Disable Test Modes.\nDisables access to the Allegro Test Modes.\nNote: does not lock the customer diagnostic test mode. See lock_o field.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="lock_a" id="49:11" lock="shadow_a.lock_a">
      <doc>Allegro EEPROM Lock.\nLocks access to: \nAllegro factory traceability registers.\nAllegro factory trim registers.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="2" name="lock_c" id="49:12" lock="shadow_a.lock_c">
      <doc>Customer EEPROM Lock.\nLocks access to the customer portion of the EEPROM.\nNote: Does not include the other customer accessible lock bits or the customer scratch register.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="3" name="lock_o" id="49:13" lock="shadow_a.lock_o">
      <doc>Disable OEM End-of-Line Target Profiling Test Mode Access.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="4" name="lock_s" id="49:14" lock="shadow_a.lock_s">
      <doc>Lock Customer Scratch Area.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="5" name="lock_bd" id="49:15" lock="shadow_a.lock_a">
      <doc>Lock Backdoor Unlock.\nDisables the backdoor unlock (makes all locks final).\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="8:6" name="spare_a_1" id="49:16">
      <doc>Spare bits. Shadowed.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:9" name="spare_a_2" id="49:17" lock="shadow_a.lock_a">
      <doc>Spare bits.\n </doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="49:18">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_b" id="50:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[11]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="thresh_a" id="50:10">
      <doc>Self Programmed Threshold value.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="self_count_a" id="50:11">
      <doc>Self programmed counter.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="50:12">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_c" id="51:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[12]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="thresh_b" id="51:10">
      <doc>Self Programmed Threshold value.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="self_count_b" id="51:11">
      <doc>Self programmed counter.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="51:12">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_d" id="52:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[13]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="12:0" name="thresh_c" id="52:10">
      <doc>Self Programmed Threshold value.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:13" name="self_count_c" id="52:11">
      <doc>Self programmed counter.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="52:12">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_e" id="53:2" coverage="on" lock="shadow_a.lock_a" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[14]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="0" name="match_err" id="53:10">
      <doc>The three stored tpos did not match when read back.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="1" name="read_err" id="53:11">
      <doc>dual bit error (at least one) occurred during read back.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="2" name="write_err" id="53:12">
      <doc>Error occurred while writing data.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="5:3" name="read_err_loc" id="53:13">
      <doc>dbe status flags for read back\nbit 0: dbe occurred during read of  A\nbit1: dbe occurred during read of  B\nbit2: dbe occurred during read of C\nThis field is updated anytime a read error occurs</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="7:6" name="write_err_loc" id="53:14">
      <doc>write error fail address\n00: A\n01: B\n10: C</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="23:8" name="temp" id="53:15">
      <doc>Temperature value (output temperature of the temperature filter block).</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="25:24" name="spare_e" id="53:16">
      <doc>Spare bits. As eeprom_e is a TPO register, don't shadow.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="53:17">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg><reg name="eeprom_f" id="54:2" coverage="on" lock="shadow_a.lock_s" ignore_prop="hdl_path" hdl_path="wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[15]">
   <config>
      <regwidth>32</regwidth>
   </config>
   <doc> </doc>
   <field offset="25:0" name="spare_f" id="54:10">
      <doc>Spare bits.</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
   <field offset="31:26" name="ecc" id="54:11">
      <doc>Error Correction Code (ECC) value for bits [25:0]</doc>
      <sw>rw</sw>
      <hw>rw</hw>
      <default>0x0</default>
   </field>
</reg></section></block>