//Allegro Microsystems LLC ***** Copyright 2017 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Saurabh
// generated from    : F:\testGit\git_test\Sample467\test514\163001_AutoHdlPath.idsng
// IDesignSpec rev   : idsbatch v 6.16.4.7

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 32
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : true
// LittleEndian               : true
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------
/*----------------------------------------------------------------------
Class       : reg_map_volatile_status0
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_status0
`define CLASS_reg_map_volatile_status0
class reg_map_volatile_status0 extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_status0)

    /*
    Die Source Code for full-level revisions
    */
    rand uvm_reg_field dsc_major;

    /*
    Die Source Code for metal revisions
    */
    rand uvm_reg_field dsc_minor;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);

    endgroup

    covergroup rd_cg_vals;

        dsc_major: coverpoint dsc_major.value[3:0];
        dsc_minor: coverpoint dsc_minor.value[3:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_status0");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.dsc_major = uvm_reg_field::type_id::create("dsc_major");
        this.dsc_minor = uvm_reg_field::type_id::create("dsc_minor");

        this.dsc_major.configure(this, 4,  0, "RO", 0, 4'd0, 1, 1, 0);
        this.dsc_minor.configure(this, 4,  4, "RO", 0, 4'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_cfg0
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_cfg0
`define CLASS_reg_map_volatile_cfg0
class reg_map_volatile_cfg0 extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_cfg0)

    /*
    Allows MUX on the output when set. Must be set prior to DMA or RMA read accesses.
    */
    rand uvm_reg_field outmode;

    /*
    Freezes pdiff signal and makes it writeable.
    */
    rand uvm_reg_field pdiff_we;

    /*
    Freezes diff signal and makes it writeable.
    */
    rand uvm_reg_field diff_we;

    /*
    Freezes tdiff signal and makes it writeable.
    */
    rand uvm_reg_field tdiff_we;

    /*
    Freezes hallphase signal and makes it writeable.
    */
    rand uvm_reg_field hallphase_we;

    /*
    Freezes state register and makes it writeable.
    */
    rand uvm_reg_field state_we;

    /*
    Freezes temperature signal and makes it writeable.
    */
    rand uvm_reg_field temperature_we;

    /*
    Freezes out signal and makes it writeable.
    */
    rand uvm_reg_field out_we;

    /*
    Disables samp outputs.
    */
    rand uvm_reg_field samp_dis;

    /*
    Disables conv outputs.
    */
    rand uvm_reg_field conv_dis;

    /*
    EFORCE phase mode.
    */
    rand uvm_reg_field eforce_mode;

    /*
    Short Hallplate.
    */
    rand uvm_reg_field force_hallshort;

    /*
    Write '1' to revert to traditional non-limited output rise time.*/
    rand uvm_reg_field out_risetime;

    /*
    Forces a watchdog timeout event.
    */
    rand uvm_reg_field force_timeout;

    /*
    Write '1' to copy the value of CDIFF into the FACT_TPO field in the EEPROM. This bit is a self-clearing one-shot.*/
    rand uvm_reg_field tpo_auto_update;

    /*
    Force TPO state regardless of the current state of the controller.
    */
    rand uvm_reg_field force_tpo;

    /*
    Adds excess load to the regulator charge pump to test its load margin.
    */
    rand uvm_reg_field cpump_load;

    /*
    Controls whether programming is performed via the VCC or output pins:
    0 = VCC programming.
    1 = Output programming.
    */
    rand uvm_reg_field out_prog_en;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);

    endgroup

    covergroup wr_cg_vals;

        outmode: coverpoint outmode.value[0:0];
        pdiff_we: coverpoint pdiff_we.value[0:0];
        diff_we: coverpoint diff_we.value[0:0];
        tdiff_we: coverpoint tdiff_we.value[0:0];
        hallphase_we: coverpoint hallphase_we.value[0:0];
        state_we: coverpoint state_we.value[0:0];
        temperature_we: coverpoint temperature_we.value[0:0];
        out_we: coverpoint out_we.value[0:0];
        samp_dis: coverpoint samp_dis.value[0:0];
        conv_dis: coverpoint conv_dis.value[0:0];
        eforce_mode: coverpoint eforce_mode.value[1:0];
        force_hallshort: coverpoint force_hallshort.value[0:0];
        out_risetime: coverpoint out_risetime.value[0:0];
        force_timeout: coverpoint force_timeout.value[0:0];
        tpo_auto_update: coverpoint tpo_auto_update.value[0:0];
        force_tpo: coverpoint force_tpo.value[0:0];
        cpump_load: coverpoint cpump_load.value[0:0];
        out_prog_en: coverpoint out_prog_en.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        outmode: coverpoint outmode.value[0:0];
        pdiff_we: coverpoint pdiff_we.value[0:0];
        diff_we: coverpoint diff_we.value[0:0];
        tdiff_we: coverpoint tdiff_we.value[0:0];
        hallphase_we: coverpoint hallphase_we.value[0:0];
        state_we: coverpoint state_we.value[0:0];
        temperature_we: coverpoint temperature_we.value[0:0];
        out_we: coverpoint out_we.value[0:0];
        samp_dis: coverpoint samp_dis.value[0:0];
        conv_dis: coverpoint conv_dis.value[0:0];
        eforce_mode: coverpoint eforce_mode.value[1:0];
        force_hallshort: coverpoint force_hallshort.value[0:0];
        out_risetime: coverpoint out_risetime.value[0:0];
        force_timeout: coverpoint force_timeout.value[0:0];
        tpo_auto_update: coverpoint tpo_auto_update.value[0:0];
        force_tpo: coverpoint force_tpo.value[0:0];
        cpump_load: coverpoint cpump_load.value[0:0];
        out_prog_en: coverpoint out_prog_en.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_cfg0");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.outmode = uvm_reg_field::type_id::create("outmode");
        this.pdiff_we = uvm_reg_field::type_id::create("pdiff_we");
        this.diff_we = uvm_reg_field::type_id::create("diff_we");
        this.tdiff_we = uvm_reg_field::type_id::create("tdiff_we");
        this.hallphase_we = uvm_reg_field::type_id::create("hallphase_we");
        this.state_we = uvm_reg_field::type_id::create("state_we");
        this.temperature_we = uvm_reg_field::type_id::create("temperature_we");
        this.out_we = uvm_reg_field::type_id::create("out_we");
        this.samp_dis = uvm_reg_field::type_id::create("samp_dis");
        this.conv_dis = uvm_reg_field::type_id::create("conv_dis");
        this.eforce_mode = uvm_reg_field::type_id::create("eforce_mode");
        this.force_hallshort = uvm_reg_field::type_id::create("force_hallshort");
        this.out_risetime = uvm_reg_field::type_id::create("out_risetime");
        this.force_timeout = uvm_reg_field::type_id::create("force_timeout");
        this.tpo_auto_update = uvm_reg_field::type_id::create("tpo_auto_update");
        this.force_tpo = uvm_reg_field::type_id::create("force_tpo");
        this.cpump_load = uvm_reg_field::type_id::create("cpump_load");
        this.out_prog_en = uvm_reg_field::type_id::create("out_prog_en");

        this.outmode.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.pdiff_we.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.diff_we.configure(this, 1,  2, "RW", 0, 1'd0, 1, 1, 0);
        this.tdiff_we.configure(this, 1,  3, "RW", 0, 1'd0, 1, 1, 0);
        this.hallphase_we.configure(this, 1,  4, "RW", 0, 1'd0, 1, 1, 0);
        this.state_we.configure(this, 1,  5, "RW", 0, 1'd0, 1, 1, 0);
        this.temperature_we.configure(this, 1,  6, "RW", 0, 1'd0, 1, 1, 0);
        this.out_we.configure(this, 1,  7, "RW", 0, 1'd0, 1, 1, 0);
        this.samp_dis.configure(this, 1,  8, "RW", 0, 1'd0, 1, 1, 0);
        this.conv_dis.configure(this, 1,  9, "RW", 0, 1'd0, 1, 1, 0);
        this.eforce_mode.configure(this, 2,  10, "RW", 0, 2'd0, 1, 1, 0);
        this.force_hallshort.configure(this, 1,  12, "RW", 0, 1'd0, 1, 1, 0);
        this.out_risetime.configure(this, 1,  13, "RW", 0, 1'd0, 1, 1, 0);
        this.force_timeout.configure(this, 1,  14, "RW", 0, 1'd0, 1, 1, 0);
        this.tpo_auto_update.configure(this, 1,  15, "RW", 0, 1'd0, 1, 1, 0);
        this.force_tpo.configure(this, 1,  16, "RW", 0, 1'd0, 1, 1, 0);
        this.cpump_load.configure(this, 1,  17, "RW", 0, 1'd0, 1, 1, 0);
        this.out_prog_en.configure(this, 1,  18, "RW", 0, 1'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_cfg1
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_cfg1
`define CLASS_reg_map_volatile_cfg1
class reg_map_volatile_cfg1 extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_cfg1)

    /*
    Write '1' to enable EOL diagnostic function
    */
    rand uvm_reg_field eol_diag_en;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);

    endgroup

    covergroup wr_cg_vals;

        eol_diag_en: coverpoint eol_diag_en.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        eol_diag_en: coverpoint eol_diag_en.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_cfg1");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.eol_diag_en = uvm_reg_field::type_id::create("eol_diag_en");

        this.eol_diag_en.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_cfg2
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_cfg2
`define CLASS_reg_map_volatile_cfg2
class reg_map_volatile_cfg2 extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_cfg2)

    /*
    Start ADC self test (clears when finished).
    */
    rand uvm_reg_field adc_test_start;

    /*
    Start Hall Automatic Trim (clears when finished).
    */
    rand uvm_reg_field auto_hall_start;

    /*
    User settable Hall Automatic Trim target
    */
    rand uvm_reg_field auto_hall_target;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);

    endgroup

    covergroup wr_cg_vals;

        adc_test_start: coverpoint adc_test_start.value[0:0];
        auto_hall_start: coverpoint auto_hall_start.value[0:0];
        auto_hall_target: coverpoint auto_hall_target.value[6:0];
    endgroup

    covergroup rd_cg_vals;

        adc_test_start: coverpoint adc_test_start.value[0:0];
        auto_hall_start: coverpoint auto_hall_start.value[0:0];
        auto_hall_target: coverpoint auto_hall_target.value[6:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_cfg2");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.adc_test_start = uvm_reg_field::type_id::create("adc_test_start");
        this.auto_hall_start = uvm_reg_field::type_id::create("auto_hall_start");
        this.auto_hall_target = uvm_reg_field::type_id::create("auto_hall_target");

        this.adc_test_start.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.auto_hall_start.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.auto_hall_target.configure(this, 7,  8, "RW", 0, 7'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_test_result
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_test_result
`define CLASS_reg_map_volatile_test_result
class reg_map_volatile_test_result extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_test_result)

    /*
    Results from ADC self test. The maximum difference seen between sequential conversions:

    */
    rand uvm_reg_field seq_conv_result;

    /*
    Results from ADC Self Test. The maximum difference seen between corrected SAR results:

    */
    rand uvm_reg_field sar_result;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);

    endgroup

    covergroup rd_cg_vals;

        seq_conv_result: coverpoint seq_conv_result.value[7:0];
        sar_result: coverpoint sar_result.value[7:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_test_result");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.seq_conv_result = uvm_reg_field::type_id::create("seq_conv_result");
        this.sar_result = uvm_reg_field::type_id::create("sar_result");

        this.seq_conv_result.configure(this, 8,  0, "RO", 0, 8'd0, 1, 1, 0);
        this.sar_result.configure(this, 8,  8, "RO", 0, 8'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_hallphase
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_hallphase
`define CLASS_reg_map_volatile_hallphase
class reg_map_volatile_hallphase extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_hallphase)

    /*Hallphase value in the ADC. Can be overwritten only when hallphase_we is previously set.*/
    rand uvm_reg_field hallphase;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);

    endgroup

    covergroup wr_cg_vals;

        hallphase: coverpoint hallphase.value[3:0];
    endgroup

    covergroup rd_cg_vals;

        hallphase: coverpoint hallphase.value[3:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_hallphase");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.hallphase = uvm_reg_field::type_id::create("hallphase");

        this.hallphase.configure(this, 4,  0, "RW", 0, 4'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_state
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_state
`define CLASS_reg_map_volatile_state
class reg_map_volatile_state extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_state)

    /*Controller State Machine state value.
    0 = RESET
    1 = WAIT
    2 = IDLE
    3 = HYST
    4 = CAL
    5 = CAL4
    6 = Running Mode
    7 = Reserved
    Can be overwritten only when state_we is previously set.*/
    rand uvm_reg_field state;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);

    endgroup

    covergroup wr_cg_vals;

        state: coverpoint state.value[2:0];
    endgroup

    covergroup rd_cg_vals;

        state: coverpoint state.value[2:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_state");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.state = uvm_reg_field::type_id::create("state");

        this.state.configure(this, 3,  0, "RW", 0, 3'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_temperature
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_temperature
`define CLASS_reg_map_volatile_temperature
class reg_map_volatile_temperature extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_temperature)

    /*Temperature sensor output result. Can be overwritten only when temperature_we is previously set.*/
    rand uvm_reg_field temperature;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);

    endgroup

    covergroup wr_cg_vals;

        temperature: coverpoint temperature.value[15:0];
    endgroup

    covergroup rd_cg_vals;

        temperature: coverpoint temperature.value[15:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_temperature");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.temperature = uvm_reg_field::type_id::create("temperature");

        this.temperature.configure(this, 16,  0, "RW", 0, 16'd32768, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_pdiff
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_pdiff
`define CLASS_reg_map_volatile_pdiff
class reg_map_volatile_pdiff extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_pdiff)

    /*PDIFF value (output of ADC). Can be overwritten only when pdiff_we is previously set.*/
    rand uvm_reg_field pdiff;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);

    endgroup

    covergroup wr_cg_vals;

        pdiff: coverpoint pdiff.value[13:0];
    endgroup

    covergroup rd_cg_vals;

        pdiff: coverpoint pdiff.value[13:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_pdiff");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.pdiff = uvm_reg_field::type_id::create("pdiff");

        this.pdiff.configure(this, 14,  0, "RW", 0, 14'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_diff
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_diff
`define CLASS_reg_map_volatile_diff
class reg_map_volatile_diff extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_diff)

    /*DIFF value (output of filter). Can be overwritten only when diff_we is previously set.*/
    rand uvm_reg_field diff;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);

    endgroup

    covergroup wr_cg_vals;

        diff: coverpoint diff.value[12:0];
    endgroup

    covergroup rd_cg_vals;

        diff: coverpoint diff.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_diff");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff = uvm_reg_field::type_id::create("diff");

        this.diff.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_tdiff
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_tdiff
`define CLASS_reg_map_volatile_tdiff
class reg_map_volatile_tdiff extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_tdiff)

    /*TDIFF value (output of temperature compensation block).*/
    rand uvm_reg_field tdiff;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);

    endgroup

    covergroup wr_cg_vals;

        tdiff: coverpoint tdiff.value[12:0];
    endgroup

    covergroup rd_cg_vals;

        tdiff: coverpoint tdiff.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_tdiff");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.tdiff = uvm_reg_field::type_id::create("tdiff");

        this.tdiff.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_out
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_out
`define CLASS_reg_map_volatile_out
class reg_map_volatile_out extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_out)

    /*Out value (output of controller block).*/
    rand uvm_reg_field out;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);

    endgroup

    covergroup wr_cg_vals;

        out: coverpoint out.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        out: coverpoint out.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_out");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.out = uvm_reg_field::type_id::create("out");

        this.out.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_ppeak
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_ppeak
`define CLASS_reg_map_volatile_ppeak
class reg_map_volatile_ppeak extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_ppeak)

    /*PPEAK register from CSM block. Read Only.*/
    rand uvm_reg_field ppeak;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);

    endgroup

    covergroup rd_cg_vals;

        ppeak: coverpoint ppeak.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_ppeak");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.ppeak = uvm_reg_field::type_id::create("ppeak");

        this.ppeak.configure(this, 13,  0, "RO", 0, 13'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_plast
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_plast
`define CLASS_reg_map_volatile_plast
class reg_map_volatile_plast extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_plast)

    /*PLAST register from CSM block. Read Only.*/
    rand uvm_reg_field plast;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);

    endgroup

    covergroup rd_cg_vals;

        plast: coverpoint plast.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_plast");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.plast = uvm_reg_field::type_id::create("plast");

        this.plast.configure(this, 13,  0, "RO", 0, 13'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_npeak
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_npeak
`define CLASS_reg_map_volatile_npeak
class reg_map_volatile_npeak extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_npeak)

    /*NPEAK register from CSM block. Read Only.*/
    rand uvm_reg_field npeak;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);

    endgroup

    covergroup rd_cg_vals;

        npeak: coverpoint npeak.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_npeak");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.npeak = uvm_reg_field::type_id::create("npeak");

        this.npeak.configure(this, 13,  0, "RO", 0, 13'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_stored_tpo
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_stored_tpo
`define CLASS_reg_map_volatile_stored_tpo
class reg_map_volatile_stored_tpo extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_stored_tpo)

    /*Calculated TPO threshold value. Read Only.*/
    rand uvm_reg_field stored_tpo;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);

    endgroup

    covergroup rd_cg_vals;

        stored_tpo: coverpoint stored_tpo.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_stored_tpo");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.stored_tpo = uvm_reg_field::type_id::create("stored_tpo");

        this.stored_tpo.configure(this, 13,  0, "RO", 0, 13'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_HW_RESET_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_ee_cfg
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_ee_cfg
`define CLASS_reg_map_volatile_ee_cfg
class reg_map_volatile_ee_cfg extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_ee_cfg)

    /*
    Setting this bit will perform an ERASE operation only on the EEPROM the next time an EEPROM address is written. It is self-clearing when the ERASE operation is complete.*/
    rand uvm_reg_field ee_erase;

    /*
    Setting this bit will perform a PROGRAM operation only on the EEPROM the next time and EEPROM address is written. If ERASE is set, this bit is ignored. It is self-clearing when the PROGRAM operation is complete.
    */
    rand uvm_reg_field ee_prog;

    /*
    00: Single Word Write Access
    01: Odd Word Write Access (address ignored)
    10: Even Word Write Access (address ignored)
    11: All Word Write Access (address ignored)
    This field only affects write operations.
    */
    rand uvm_reg_field ee_block_mode;

    /*
    VREAD EEPROM setting per EEPROM V3.0 spec
    Available post lock*/
    rand uvm_reg_field ee_vread;

    /*
    Forces a single bit error
    */
    rand uvm_reg_field ee_force_sbe;

    /*
    Forces a multi bit error
    */
    rand uvm_reg_field ee_force_dbe;

    /*
    0: Correct Single bit errors when they occur
    1: Do not correct single bit errors when they occur*/
    rand uvm_reg_field ee_dis_ecc;

    /*
    0: Upper bits of EEPROM is written with ECC bits.
    1: EEPROM is written with all bits of raw data. During a read, all bits of raw data is returned.
    */
    rand uvm_reg_field ee_no_ecc;

    /*
    0 0: Bits [31:26] of an EEPROM READ return the following read status information.
    Bit 31 = 0
    Bit 30 = 0
    Bit 29 = 1 if double bit error, 0 if not
    Bit 28 = 1 if single bit error, 0 if not
    Bit 27 = 0
    Bit 26 = 0

    1: Bits [31:26] of an EEPROM READ return the 6 bit ECC code
    */
    rand uvm_reg_field ee_raw_ecc;

    /*
    0: Normal operation
    1: Force ee_en output high
    */
    rand uvm_reg_field ee_en_override;

    /*
    00: Normal operation
    01: Force ee_rd output high
    10: Force ee_er output high
    11: Force ee_pr output high
    */
    rand uvm_reg_field ee_override;

    /*
    Write to a 1 to reload all shadow registers with EEPROM values. If the noload test pad or ee_noload is set the reload will not occur.*/
    rand uvm_reg_field ee_force_reload;

    /*
    When set shadow will not update when eeprom is written*/
    rand uvm_reg_field ee_noload;

    /*
    When set the eeprom controller will abort the current action return to idle
    */
    rand uvm_reg_field ee_abort;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);

    endgroup

    covergroup wr_cg_vals;

        ee_erase: coverpoint ee_erase.value[0:0];
        ee_prog: coverpoint ee_prog.value[0:0];
        ee_block_mode: coverpoint ee_block_mode.value[1:0];
        ee_vread: coverpoint ee_vread.value[2:0];
        ee_force_sbe: coverpoint ee_force_sbe.value[0:0];
        ee_force_dbe: coverpoint ee_force_dbe.value[0:0];
        ee_dis_ecc: coverpoint ee_dis_ecc.value[0:0];
        ee_no_ecc: coverpoint ee_no_ecc.value[0:0];
        ee_raw_ecc: coverpoint ee_raw_ecc.value[0:0];
        ee_en_override: coverpoint ee_en_override.value[0:0];
        ee_override: coverpoint ee_override.value[1:0];
        ee_force_reload: coverpoint ee_force_reload.value[0:0];
        ee_noload: coverpoint ee_noload.value[0:0];
        ee_abort: coverpoint ee_abort.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        ee_erase: coverpoint ee_erase.value[0:0];
        ee_prog: coverpoint ee_prog.value[0:0];
        ee_block_mode: coverpoint ee_block_mode.value[1:0];
        ee_vread: coverpoint ee_vread.value[2:0];
        ee_force_sbe: coverpoint ee_force_sbe.value[0:0];
        ee_force_dbe: coverpoint ee_force_dbe.value[0:0];
        ee_dis_ecc: coverpoint ee_dis_ecc.value[0:0];
        ee_no_ecc: coverpoint ee_no_ecc.value[0:0];
        ee_raw_ecc: coverpoint ee_raw_ecc.value[0:0];
        ee_en_override: coverpoint ee_en_override.value[0:0];
        ee_override: coverpoint ee_override.value[1:0];
        ee_force_reload: coverpoint ee_force_reload.value[0:0];
        ee_noload: coverpoint ee_noload.value[0:0];
        ee_abort: coverpoint ee_abort.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_ee_cfg");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.ee_erase = uvm_reg_field::type_id::create("ee_erase");
        this.ee_prog = uvm_reg_field::type_id::create("ee_prog");
        this.ee_block_mode = uvm_reg_field::type_id::create("ee_block_mode");
        this.ee_vread = uvm_reg_field::type_id::create("ee_vread");
        this.ee_force_sbe = uvm_reg_field::type_id::create("ee_force_sbe");
        this.ee_force_dbe = uvm_reg_field::type_id::create("ee_force_dbe");
        this.ee_dis_ecc = uvm_reg_field::type_id::create("ee_dis_ecc");
        this.ee_no_ecc = uvm_reg_field::type_id::create("ee_no_ecc");
        this.ee_raw_ecc = uvm_reg_field::type_id::create("ee_raw_ecc");
        this.ee_en_override = uvm_reg_field::type_id::create("ee_en_override");
        this.ee_override = uvm_reg_field::type_id::create("ee_override");
        this.ee_force_reload = uvm_reg_field::type_id::create("ee_force_reload");
        this.ee_noload = uvm_reg_field::type_id::create("ee_noload");
        this.ee_abort = uvm_reg_field::type_id::create("ee_abort");

        this.ee_erase.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_prog.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_block_mode.configure(this, 2,  2, "RW", 0, 2'd0, 1, 1, 0);
        this.ee_vread.configure(this, 3,  4, "RW", 0, 3'd0, 1, 1, 0);
        this.ee_force_sbe.configure(this, 1,  7, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_force_dbe.configure(this, 1,  8, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_dis_ecc.configure(this, 1,  9, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_no_ecc.configure(this, 1,  10, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_raw_ecc.configure(this, 1,  11, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_en_override.configure(this, 1,  12, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_override.configure(this, 2,  13, "RW", 0, 2'd0, 1, 1, 0);
        this.ee_force_reload.configure(this, 1,  15, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_noload.configure(this, 1,  16, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_abort.configure(this, 1,  17, "RW", 0, 1'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_ACCESS_TEST",1,this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_cp_cfg
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_cp_cfg
`define CLASS_reg_map_volatile_cp_cfg
class reg_map_volatile_cp_cfg extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_cp_cfg)

    /*
    0: Normal operation
    1: Force cp_en output high
    */
    rand uvm_reg_field cp_force_en;

    /*
    0: Normal operation
    1: The value in CP_DAC drives the cp_dac [5:0] output
    */
    rand uvm_reg_field cp_use_dac;

    /*
    This value is driven on cp_dac [5:0] ouput when cp_use_dac is set
    */
    rand uvm_reg_field cp_dac;

    /*
    0: Normal operation
    1: EEPROM write (or erase, program) will not abort if ee_prog_pulse is not at correct value
    */
    rand uvm_reg_field cp_dis_abort;

    /*
    High to indicate an error occurred during charge pump ramp. ee_err_status stores information about the error.
    */
    rand uvm_reg_field cp_err;

    /*
    Directly drives cp_cntrl [7:0] ouputs to control charge pump.
    */
    rand uvm_reg_field cp_cntrl;

    /*
    Selects the ramp up time for the charge pump. Values are TBD.
    */
    rand uvm_reg_field cp_rup_sel;

    /*
    Selects the time the cp_dac remains at its max value (0x3F). Values are TBD.
    */
    rand uvm_reg_field cp_hv_sel;

    /*
    Selects the ramp down time for the charge pump. Values are TBD.
    */
    rand uvm_reg_field cp_rdn_sel;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);

    endgroup

    covergroup wr_cg_vals;

        cp_force_en: coverpoint cp_force_en.value[0:0];
        cp_use_dac: coverpoint cp_use_dac.value[0:0];
        cp_dac: coverpoint cp_dac.value[5:0];
        cp_dis_abort: coverpoint cp_dis_abort.value[0:0];
        cp_cntrl: coverpoint cp_cntrl.value[1:0];
        cp_rup_sel: coverpoint cp_rup_sel.value[1:0];
        cp_hv_sel: coverpoint cp_hv_sel.value[1:0];
        cp_rdn_sel: coverpoint cp_rdn_sel.value[1:0];
    endgroup

    covergroup rd_cg_vals;

        cp_force_en: coverpoint cp_force_en.value[0:0];
        cp_use_dac: coverpoint cp_use_dac.value[0:0];
        cp_dac: coverpoint cp_dac.value[5:0];
        cp_dis_abort: coverpoint cp_dis_abort.value[0:0];
        cp_err: coverpoint cp_err.value[0:0];
        cp_cntrl: coverpoint cp_cntrl.value[1:0];
        cp_rup_sel: coverpoint cp_rup_sel.value[1:0];
        cp_hv_sel: coverpoint cp_hv_sel.value[1:0];
        cp_rdn_sel: coverpoint cp_rdn_sel.value[1:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_cp_cfg");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.cp_force_en = uvm_reg_field::type_id::create("cp_force_en");
        this.cp_use_dac = uvm_reg_field::type_id::create("cp_use_dac");
        this.cp_dac = uvm_reg_field::type_id::create("cp_dac");
        this.cp_dis_abort = uvm_reg_field::type_id::create("cp_dis_abort");
        this.cp_err = uvm_reg_field::type_id::create("cp_err");
        this.cp_cntrl = uvm_reg_field::type_id::create("cp_cntrl");
        this.cp_rup_sel = uvm_reg_field::type_id::create("cp_rup_sel");
        this.cp_hv_sel = uvm_reg_field::type_id::create("cp_hv_sel");
        this.cp_rdn_sel = uvm_reg_field::type_id::create("cp_rdn_sel");

        this.cp_force_en.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.cp_use_dac.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.cp_dac.configure(this, 6,  2, "RW", 0, 6'd0, 1, 1, 0);
        this.cp_dis_abort.configure(this, 1,  8, "RW", 0, 1'd0, 1, 1, 0);
        this.cp_err.configure(this, 1,  9, "RC", 0, 1'd0, 1, 1, 0);
        this.cp_cntrl.configure(this, 2,  10, "RW", 0, 2'd0, 1, 1, 0);
        this.cp_rup_sel.configure(this, 2,  12, "RW", 0, 2'd0, 1, 1, 0);
        this.cp_hv_sel.configure(this, 2,  14, "RW", 0, 2'd0, 1, 1, 0);
        this.cp_rdn_sel.configure(this, 2,  16, "RW", 0, 2'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_ACCESS_TEST",1,this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_ee_status
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_ee_status
`define CLASS_reg_map_volatile_ee_status
class reg_map_volatile_ee_status extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_ee_status)

    /*
    Set if a dual bit error has occurred. This bit is clear on read.
    Cannot be unlocked with unlock pad.*/
    rand uvm_reg_field ee_dbe_flag;

    /*
    Set if a single bit error has occurred. This bit is clear on read.*/
    rand uvm_reg_field ee_sbe_flag;

    /*
    Error flag, goes high when an error occurs during an eeprom write*/
    rand uvm_reg_field ee_err;

    /*
    Status of when the last eeprom error.
    Bit 4: 0 - error occurred during erase, 1 - error occurred during program.
    Bit 3: 0 - error occurred during Ramp Up, 1 - error occurred during Ramp Down.
    Bit 2: Program Pulse value.
    Bit 1: hlat value.
    Bit 0: llat value.
    */
    rand uvm_reg_field ee_err_status;

    /*
    Contains the address for an EEPROM access. On a write or a read to EEPROM this register is updated with the access address. This address is the first read on powerup and the default should point to the row containing the oscillator trim.
    */
    rand uvm_reg_field ee_addr;

    /*
    Contains the ecc for an eeprom access. On a write this register contains the written ecc, on a read this register contains the read ecc.*/
    rand uvm_reg_field ee_ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);

    endgroup

    covergroup wr_cg_vals;

        ee_dbe_flag: coverpoint ee_dbe_flag.value[0:0];
        ee_sbe_flag: coverpoint ee_sbe_flag.value[0:0];
        ee_addr: coverpoint ee_addr.value[3:0];
        ee_ecc: coverpoint ee_ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        ee_dbe_flag: coverpoint ee_dbe_flag.value[0:0];
        ee_sbe_flag: coverpoint ee_sbe_flag.value[0:0];
        ee_err: coverpoint ee_err.value[0:0];
        ee_err_status: coverpoint ee_err_status.value[4:0];
        ee_addr: coverpoint ee_addr.value[3:0];
        ee_ecc: coverpoint ee_ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_ee_status");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.ee_dbe_flag = uvm_reg_field::type_id::create("ee_dbe_flag");
        this.ee_sbe_flag = uvm_reg_field::type_id::create("ee_sbe_flag");
        this.ee_err = uvm_reg_field::type_id::create("ee_err");
        this.ee_err_status = uvm_reg_field::type_id::create("ee_err_status");
        this.ee_addr = uvm_reg_field::type_id::create("ee_addr");
        this.ee_ecc = uvm_reg_field::type_id::create("ee_ecc");

        this.ee_dbe_flag.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_sbe_flag.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_err.configure(this, 1,  2, "RC", 0, 1'd0, 1, 1, 0);
        this.ee_err_status.configure(this, 5,  3, "RO", 0, 5'd0, 1, 1, 0);
        this.ee_addr.configure(this, 4,  8, "RW", 0, 4'd9, 1, 1, 0);
        this.ee_ecc.configure(this, 6,  12, "RW", 0, 6'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_ACCESS_TEST",1,this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_ee_data
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_ee_data
`define CLASS_reg_map_volatile_ee_data
class reg_map_volatile_ee_data extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_ee_data)

    /*
    Contains the data for an eeprom access. On a write this register contains the written data, on a read this register contains the read data.*/
    rand uvm_reg_field ee_data;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);

    endgroup

    covergroup wr_cg_vals;

        ee_data: coverpoint ee_data.value[25:0];
    endgroup

    covergroup rd_cg_vals;

        ee_data: coverpoint ee_data.value[25:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_ee_data");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.ee_data = uvm_reg_field::type_id::create("ee_data");

        this.ee_data.configure(this, 26,  0, "RW", 0, 26'd0, 1, 1, 0);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_BIT_BASH_TEST", 1, this);

        uvm_resource_db#(bit)::set({"REG::", this.get_full_name()}, "NO_REG_ACCESS_TEST",1,this);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_pat_test
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_pat_test
`define CLASS_reg_map_volatile_pat_test
class reg_map_volatile_pat_test extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_pat_test)

    /*
    Write to 1 to start pattern check testing. If EE_LOOP is low, this bit will self clear when the last address is reached. If EE_LOOP is high, this bit must be written to 0 to stop test. This bit always clears on a fail.
    */
    rand uvm_reg_field pat_test_start;

    /*
    Bits are cleared after a read or reset.
    00: Reset condition (no result from pat testing)
    01: Pass, no failure detected during pat testing
    10: Fail, failure detected during pat testing
    11: Running, pat test is still running
    */
    rand uvm_reg_field pat_test_status;

    /*
    Defines the pattern that will be checked when reading the EEPROM.
    00: All 0s
    01: All 1s
    10: Checker board starting at 0x0 with '010101.'
    11: Checker board starting at 0x0 with '101010.'*/
    rand uvm_reg_field pat_test_pattern;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);

    endgroup

    covergroup wr_cg_vals;

        pat_test_start: coverpoint pat_test_start.value[0:0];
        pat_test_pattern: coverpoint pat_test_pattern.value[1:0];
    endgroup

    covergroup rd_cg_vals;

        pat_test_start: coverpoint pat_test_start.value[0:0];
        pat_test_status: coverpoint pat_test_status.value[1:0];
        pat_test_pattern: coverpoint pat_test_pattern.value[1:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_pat_test");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.pat_test_start = uvm_reg_field::type_id::create("pat_test_start");
        this.pat_test_status = uvm_reg_field::type_id::create("pat_test_status");
        this.pat_test_pattern = uvm_reg_field::type_id::create("pat_test_pattern");

        this.pat_test_start.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.pat_test_status.configure(this, 2,  1, "RO", 0, 2'd0, 1, 1, 0);
        this.pat_test_pattern.configure(this, 2,  3, "RW", 0, 2'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_marg_test
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_marg_test
`define CLASS_reg_map_volatile_marg_test
class reg_map_volatile_marg_test extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_marg_test)

    /*
    Write to 1 to start margin testing. If EE_LOOP is low, this bit will self clear when address 0xB is reached. If EE_LOOP is high, this bit must be written to 0 to stop test. This bit always clears on a fail.
    */
    rand uvm_reg_field margin_start;

    /*
    0: Max reference voltage will be used during margin testing
    1: Max voltage reference will be skiped during margin testing
    */
    rand uvm_reg_field margin_no_max;

    /*
    0: Min reference voltage will be used during margin testing
    1: Min voltage reference will be skiped during margin testing
    */
    rand uvm_reg_field margin_no_min;

    /*
    Bits are cleared after a read or reset.
    00: Reset condition (no result from margin testing)
    01: Pass, no failure detected during margin testing
    10: Fail, failure detected during margin testing
    11: Running, margin test is still running
    */
    rand uvm_reg_field margin_status;

    /*
    If margining fails, this bit indicates if the min or max reference failed.
    0: Min margining failed.
    1: Max margining failed.
    */
    rand uvm_reg_field margin_min_max_fail;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);

    endgroup

    covergroup wr_cg_vals;

        margin_start: coverpoint margin_start.value[0:0];
        margin_no_max: coverpoint margin_no_max.value[0:0];
        margin_no_min: coverpoint margin_no_min.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        margin_start: coverpoint margin_start.value[0:0];
        margin_no_max: coverpoint margin_no_max.value[0:0];
        margin_no_min: coverpoint margin_no_min.value[0:0];
        margin_status: coverpoint margin_status.value[1:0];
        margin_min_max_fail: coverpoint margin_min_max_fail.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_marg_test");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.margin_start = uvm_reg_field::type_id::create("margin_start");
        this.margin_no_max = uvm_reg_field::type_id::create("margin_no_max");
        this.margin_no_min = uvm_reg_field::type_id::create("margin_no_min");
        this.margin_status = uvm_reg_field::type_id::create("margin_status");
        this.margin_min_max_fail = uvm_reg_field::type_id::create("margin_min_max_fail");

        this.margin_start.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.margin_no_max.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.margin_no_min.configure(this, 1,  2, "RW", 0, 1'd0, 1, 1, 0);
        this.margin_status.configure(this, 2,  3, "RO", 0, 2'd0, 1, 1, 0);
        this.margin_min_max_fail.configure(this, 1,  5, "RO", 0, 1'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile_test_cfg
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_volatile_test_cfg
`define CLASS_reg_map_volatile_test_cfg
class reg_map_volatile_test_cfg extends uvm_reg;
    `uvm_object_utils(reg_map_volatile_test_cfg)

    /*
    0: Test completes at final address or fail
    1: Test loops until MARGIN_START is written low or fail.*/
    rand uvm_reg_field ee_loop;

    /*
    0: No effect
    1: Uses EE_TST_ADDR as the start address for margining.
    If EE_LOOP is set, this bit is ignored and the starting address is always 0x0
    */
    rand uvm_reg_field ee_use_test_addr;

    /*
    If USE_TST_ADDR is set, then margining or check testing will start at this address. If the test fails, this will contain the failing address.
    */
    rand uvm_reg_field ee_test_addr;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);

    endgroup

    covergroup wr_cg_vals;

        ee_loop: coverpoint ee_loop.value[0:0];
        ee_use_test_addr: coverpoint ee_use_test_addr.value[0:0];
        ee_test_addr: coverpoint ee_test_addr.value[3:0];
    endgroup

    covergroup rd_cg_vals;

        ee_loop: coverpoint ee_loop.value[0:0];
        ee_use_test_addr: coverpoint ee_use_test_addr.value[0:0];
        ee_test_addr: coverpoint ee_test_addr.value[3:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_volatile_test_cfg");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.ee_loop = uvm_reg_field::type_id::create("ee_loop");
        this.ee_use_test_addr = uvm_reg_field::type_id::create("ee_use_test_addr");
        this.ee_test_addr = uvm_reg_field::type_id::create("ee_test_addr");

        this.ee_loop.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_use_test_addr.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.ee_test_addr.configure(this, 4,  2, "RW", 0, 4'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_4
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_4
`define CLASS_reg_map_shadow_shadow_4
class reg_map_shadow_shadow_4 extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_4)

    /*
    Running Mode Transition
    Determines the conditions to transition from the output controlled by TPO (at power on) to output controlled by threshold POSCOMP
    3'd0 = Fast Swap (as soon as P/N PEAKs separate)
    3'd1 = Qualified Swap (after one tooth)
    3'd2 = Always TPO
    3'd3 = Fastish Swap (like Fast, but requires larger separation)
    3'd4 = TBD (stays in TPO for teeth?)*/
    rand uvm_reg_field rmt;

    /*
    Polarity
    Inverts the polarity of the analog output driver operation. No effect on internal signals.*/
    rand uvm_reg_field pol;

    /*
    Aggressive Update
    Enables NPEAK aggressive update. (Default is conservative)*/
    rand uvm_reg_field aggr;

    /*
    Number of Teeth sequences
    The sensor will remember peak levels for the indicated number of theeth. This should be set to match the number of target teeth.*/
    rand uvm_reg_field teeth;

    /*
    Factory TPO value
    Default switching threshold for device from power on to RMT. May be superseded by thresh_a/b/c*/
    rand uvm_reg_field fact_tpo;

    /*
    Watchdog Enable*/
    rand uvm_reg_field wdog_en;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);

    endgroup

    covergroup rd_cg_bits;

        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);

    endgroup

    covergroup wr_cg_vals;

        rmt: coverpoint rmt.value[2:0];
        pol: coverpoint pol.value[0:0];
        aggr: coverpoint aggr.value[0:0];
        teeth: coverpoint teeth.value[3:0];
        fact_tpo: coverpoint fact_tpo.value[12:0];
        wdog_en: coverpoint wdog_en.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        rmt: coverpoint rmt.value[2:0];
        pol: coverpoint pol.value[0:0];
        aggr: coverpoint aggr.value[0:0];
        teeth: coverpoint teeth.value[3:0];
        fact_tpo: coverpoint fact_tpo.value[12:0];
        wdog_en: coverpoint wdog_en.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_4");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.rmt = uvm_reg_field::type_id::create("rmt");
        this.pol = uvm_reg_field::type_id::create("pol");
        this.aggr = uvm_reg_field::type_id::create("aggr");
        this.teeth = uvm_reg_field::type_id::create("teeth");
        this.fact_tpo = uvm_reg_field::type_id::create("fact_tpo");
        this.wdog_en = uvm_reg_field::type_id::create("wdog_en");

        this.rmt.configure(this, 3,  3, "RW", 0, 3'd0, 1, 1, 0);
        this.pol.configure(this, 1,  6, "RW", 0, 1'd0, 1, 1, 0);
        this.aggr.configure(this, 1,  7, "RW", 0, 1'd0, 1, 1, 0);
        this.teeth.configure(this, 4,  8, "RW", 0, 4'd0, 1, 1, 0);
        this.fact_tpo.configure(this, 13,  12, "RW", 0, 13'd0, 1, 1, 0);
        this.wdog_en.configure(this, 1,  25, "RW", 0, 1'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_5
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_5
`define CLASS_reg_map_shadow_shadow_5
class reg_map_shadow_shadow_5 extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_5)

    /*
    Threshold for the rising edge*/
    rand uvm_reg_field thrr;

    /*
    Threshold for the falling edge*/
    rand uvm_reg_field thrf;

    /*
    Fast Fall mode on output enable*/
    rand uvm_reg_field ffall;

    /*
    ADC Feedback test mode*/
    rand uvm_reg_field fb_test;

    /*
    SAR DEM test mode*/
    rand uvm_reg_field dem_test;

    /*
    FE Calibration disable, holds segment and chop weights at 0
    */
    rand uvm_reg_field fe_cal_dis;

    /*
    Enables variable chopping*/
    rand uvm_reg_field variable_chop;

    /*
    selects filter settings*/
    rand uvm_reg_field adc_filter_sel;

    /*
    Disables TPO self write*/
    rand uvm_reg_field tpoself_dis;

    /*
    Level for TPO self write*/
    rand uvm_reg_field tpoself_lvl;

    /*
    Temperature compensation value*/
    rand uvm_reg_field temp_comp;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);

    endgroup

    covergroup wr_cg_vals;

        thrr: coverpoint thrr.value[3:0];
        thrf: coverpoint thrf.value[3:0];
        ffall: coverpoint ffall.value[0:0];
        fb_test: coverpoint fb_test.value[0:0];
        dem_test: coverpoint dem_test.value[0:0];
        fe_cal_dis: coverpoint fe_cal_dis.value[0:0];
        variable_chop: coverpoint variable_chop.value[0:0];
        adc_filter_sel: coverpoint adc_filter_sel.value[0:0];
        tpoself_dis: coverpoint tpoself_dis.value[0:0];
        tpoself_lvl: coverpoint tpoself_lvl.value[0:0];
        temp_comp: coverpoint temp_comp.value[3:0];
    endgroup

    covergroup rd_cg_vals;

        thrr: coverpoint thrr.value[3:0];
        thrf: coverpoint thrf.value[3:0];
        ffall: coverpoint ffall.value[0:0];
        fb_test: coverpoint fb_test.value[0:0];
        dem_test: coverpoint dem_test.value[0:0];
        fe_cal_dis: coverpoint fe_cal_dis.value[0:0];
        variable_chop: coverpoint variable_chop.value[0:0];
        adc_filter_sel: coverpoint adc_filter_sel.value[0:0];
        tpoself_dis: coverpoint tpoself_dis.value[0:0];
        tpoself_lvl: coverpoint tpoself_lvl.value[0:0];
        temp_comp: coverpoint temp_comp.value[3:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_5");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.thrr = uvm_reg_field::type_id::create("thrr");
        this.thrf = uvm_reg_field::type_id::create("thrf");
        this.ffall = uvm_reg_field::type_id::create("ffall");
        this.fb_test = uvm_reg_field::type_id::create("fb_test");
        this.dem_test = uvm_reg_field::type_id::create("dem_test");
        this.fe_cal_dis = uvm_reg_field::type_id::create("fe_cal_dis");
        this.variable_chop = uvm_reg_field::type_id::create("variable_chop");
        this.adc_filter_sel = uvm_reg_field::type_id::create("adc_filter_sel");
        this.tpoself_dis = uvm_reg_field::type_id::create("tpoself_dis");
        this.tpoself_lvl = uvm_reg_field::type_id::create("tpoself_lvl");
        this.temp_comp = uvm_reg_field::type_id::create("temp_comp");

        this.thrr.configure(this, 4,  0, "RW", 0, 4'd0, 1, 1, 0);
        this.thrf.configure(this, 4,  4, "RW", 0, 4'd0, 1, 1, 0);
        this.ffall.configure(this, 1,  8, "RW", 0, 1'd0, 1, 1, 0);
        this.fb_test.configure(this, 1,  9, "RW", 0, 1'd0, 1, 1, 0);
        this.dem_test.configure(this, 1,  10, "RW", 0, 1'd0, 1, 1, 0);
        this.fe_cal_dis.configure(this, 1,  11, "RW", 0, 1'd0, 1, 1, 0);
        this.variable_chop.configure(this, 1,  12, "RW", 0, 1'd0, 1, 1, 0);
        this.adc_filter_sel.configure(this, 1,  13, "RW", 0, 1'd0, 1, 1, 0);
        this.tpoself_dis.configure(this, 1,  14, "RW", 0, 1'd0, 1, 1, 0);
        this.tpoself_lvl.configure(this, 1,  15, "RW", 0, 1'd0, 1, 1, 0);
        this.temp_comp.configure(this, 4,  16, "RW", 0, 4'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_6
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_6
`define CLASS_reg_map_shadow_shadow_6
class reg_map_shadow_shadow_6 extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_6)

    /*
    The DIFF value to be offset to mid scale at -40 ?C.
    */
    rand uvm_reg_field diff_baseline_40;

    /*
    The TPO level at cold to be gain corrected to match 25 ?C.
    */
    rand uvm_reg_field diff_tpo_40;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);

    endgroup

    covergroup wr_cg_vals;

        diff_baseline_40: coverpoint diff_baseline_40.value[12:0];
        diff_tpo_40: coverpoint diff_tpo_40.value[12:0];
    endgroup

    covergroup rd_cg_vals;

        diff_baseline_40: coverpoint diff_baseline_40.value[12:0];
        diff_tpo_40: coverpoint diff_tpo_40.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_6");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff_baseline_40 = uvm_reg_field::type_id::create("diff_baseline_40");
        this.diff_tpo_40 = uvm_reg_field::type_id::create("diff_tpo_40");

        this.diff_baseline_40.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.diff_tpo_40.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_7
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_7
`define CLASS_reg_map_shadow_shadow_7
class reg_map_shadow_shadow_7 extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_7)

    /*
    The DIFF value to be offset to mid scale at 25 ?C.
    */
    rand uvm_reg_field diff_baseline_25;

    /*
    The reference TPO level.
    */
    rand uvm_reg_field diff_tpo_25;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);

    endgroup

    covergroup wr_cg_vals;

        diff_baseline_25: coverpoint diff_baseline_25.value[12:0];
        diff_tpo_25: coverpoint diff_tpo_25.value[12:0];
    endgroup

    covergroup rd_cg_vals;

        diff_baseline_25: coverpoint diff_baseline_25.value[12:0];
        diff_tpo_25: coverpoint diff_tpo_25.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_7");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff_baseline_25 = uvm_reg_field::type_id::create("diff_baseline_25");
        this.diff_tpo_25 = uvm_reg_field::type_id::create("diff_tpo_25");

        this.diff_baseline_25.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.diff_tpo_25.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_8
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_8
`define CLASS_reg_map_shadow_shadow_8
class reg_map_shadow_shadow_8 extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_8)

    /*
    The DIFF value to be offset to mid scale at 165 ?C.
    */
    rand uvm_reg_field diff_baseline_165;

    /*
    The TPO level at hot to be gain corrected to match 25 ?C.
    */
    rand uvm_reg_field diff_tpo_165;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);

    endgroup

    covergroup wr_cg_vals;

        diff_baseline_165: coverpoint diff_baseline_165.value[12:0];
        diff_tpo_165: coverpoint diff_tpo_165.value[12:0];
    endgroup

    covergroup rd_cg_vals;

        diff_baseline_165: coverpoint diff_baseline_165.value[12:0];
        diff_tpo_165: coverpoint diff_tpo_165.value[12:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_8");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff_baseline_165 = uvm_reg_field::type_id::create("diff_baseline_165");
        this.diff_tpo_165 = uvm_reg_field::type_id::create("diff_tpo_165");

        this.diff_baseline_165.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.diff_tpo_165.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_9
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_9
`define CLASS_reg_map_shadow_shadow_9
class reg_map_shadow_shadow_9 extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_9)

    /*
    Hall Plate Trim (available at reset).
    */
    rand uvm_reg_field halltrim;

    /*
    Oscillator Trim (available at reset).
    */
    rand uvm_reg_field osc_trim;

    /*
    Reference Bandgap Trim (available at reset).
    */
    rand uvm_reg_field ref_bg_trim;

    /*
    Output fall time trim.
    */
    rand uvm_reg_field out_fastfall;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);

    endgroup

    covergroup wr_cg_vals;

        halltrim: coverpoint halltrim.value[6:0];
        osc_trim: coverpoint osc_trim.value[4:0];
        ref_bg_trim: coverpoint ref_bg_trim.value[4:0];
        out_fastfall: coverpoint out_fastfall.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        halltrim: coverpoint halltrim.value[6:0];
        osc_trim: coverpoint osc_trim.value[4:0];
        ref_bg_trim: coverpoint ref_bg_trim.value[4:0];
        out_fastfall: coverpoint out_fastfall.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_9");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.halltrim = uvm_reg_field::type_id::create("halltrim");
        this.osc_trim = uvm_reg_field::type_id::create("osc_trim");
        this.ref_bg_trim = uvm_reg_field::type_id::create("ref_bg_trim");
        this.out_fastfall = uvm_reg_field::type_id::create("out_fastfall");

        this.halltrim.configure(this, 7,  0, "RW", 0, 7'd112, 1, 1, 0);
        this.osc_trim.configure(this, 5,  7, "RW", 0, 5'd0, 1, 1, 0);
        this.ref_bg_trim.configure(this, 5,  12, "RW", 0, 5'd0, 1, 1, 0);
        this.out_fastfall.configure(this, 1,  17, "RW", 0, 1'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow_shadow_a
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_shadow_shadow_a
`define CLASS_reg_map_shadow_shadow_a
class reg_map_shadow_shadow_a extends uvm_reg;
    `uvm_object_utils(reg_map_shadow_shadow_a)

    /*
    See EEPROM Section
    */
    rand uvm_reg_field lock_t;

    /*
    See EEPROM Section
    */
    rand uvm_reg_field lock_a;

    /*
    See EEPROM Section
    */
    rand uvm_reg_field lock_c;

    /*
    See EEPROM Section
    */
    rand uvm_reg_field lock_o;

    /*
    See EEPROM Section
    */
    rand uvm_reg_field lock_s;

    /*
    See EEPROM Section
    */
    rand uvm_reg_field lock_bd;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);

    endgroup

    covergroup wr_cg_vals;

        lock_t: coverpoint lock_t.value[0:0];
        lock_a: coverpoint lock_a.value[0:0];
        lock_c: coverpoint lock_c.value[0:0];
        lock_o: coverpoint lock_o.value[0:0];
        lock_s: coverpoint lock_s.value[0:0];
        lock_bd: coverpoint lock_bd.value[0:0];
    endgroup

    covergroup rd_cg_vals;

        lock_t: coverpoint lock_t.value[0:0];
        lock_a: coverpoint lock_a.value[0:0];
        lock_c: coverpoint lock_c.value[0:0];
        lock_o: coverpoint lock_o.value[0:0];
        lock_s: coverpoint lock_s.value[0:0];
        lock_bd: coverpoint lock_bd.value[0:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_shadow_shadow_a");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.lock_t = uvm_reg_field::type_id::create("lock_t");
        this.lock_a = uvm_reg_field::type_id::create("lock_a");
        this.lock_c = uvm_reg_field::type_id::create("lock_c");
        this.lock_o = uvm_reg_field::type_id::create("lock_o");
        this.lock_s = uvm_reg_field::type_id::create("lock_s");
        this.lock_bd = uvm_reg_field::type_id::create("lock_bd");

        this.lock_t.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_a.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_c.configure(this, 1,  2, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_o.configure(this, 1,  3, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_s.configure(this, 1,  4, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_bd.configure(this, 1,  5, "RW", 0, 1'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_0
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_0
`define CLASS_reg_map_eeprom_eeprom_0
class reg_map_eeprom_eeprom_0 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_0)

    /*reserved for factory production use*/
    rand uvm_reg_field factory_0;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        factory_0: coverpoint factory_0.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        factory_0: coverpoint factory_0.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_0");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.factory_0 = uvm_reg_field::type_id::create("factory_0");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.factory_0.configure(this, 26,  0, "RW", 0, 26'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_1
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_1
`define CLASS_reg_map_eeprom_eeprom_1
class reg_map_eeprom_eeprom_1 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_1)

    /*reserved for factory production use*/
    rand uvm_reg_field factory_1;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        factory_1: coverpoint factory_1.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        factory_1: coverpoint factory_1.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_1");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.factory_1 = uvm_reg_field::type_id::create("factory_1");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.factory_1.configure(this, 26,  0, "RW", 0, 26'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_2
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_2
`define CLASS_reg_map_eeprom_eeprom_2
class reg_map_eeprom_eeprom_2 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_2)

    /*reserved for factory production use*/
    rand uvm_reg_field factory_2;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        factory_2: coverpoint factory_2.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        factory_2: coverpoint factory_2.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_2");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.factory_2 = uvm_reg_field::type_id::create("factory_2");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.factory_2.configure(this, 26,  0, "RW", 0, 26'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_3
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_3
`define CLASS_reg_map_eeprom_eeprom_3
class reg_map_eeprom_eeprom_3 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_3)

    /*reserved for factory production use*/
    rand uvm_reg_field factory_3;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        factory_3: coverpoint factory_3.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        factory_3: coverpoint factory_3.value[25:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_3");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.factory_3 = uvm_reg_field::type_id::create("factory_3");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.factory_3.configure(this, 26,  0, "RW", 0, 26'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_4
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_4
`define CLASS_reg_map_eeprom_eeprom_4
class reg_map_eeprom_eeprom_4 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_4)

    /*Running Mode Transition
    Determines the conditions to transition from the output controlled by TPO (at power on) to output controlled by threshold POSCOMP
    3'd0 = Fast Swap (as soon as P/N PEAKs separate)
    3'd1 = Qualified Swap (after one tooth)
    3'd2 = Always TPO
    3'd3 = Fastish Swap (like Fast, but requires larger separation)
    3'd4 = TBD (stays in TPO for teeth?)*/
    rand uvm_reg_field rmt;

    /*Polarity
    Inverts the polarity of the analog output driver operation. No effect on internal signals.*/
    rand uvm_reg_field pol;

    /*Aggressive Update
    Enables NPEAK aggressive update. (Default is conservative)*/
    rand uvm_reg_field aggr;

    /*Number of Teeth
    The sensor will remember peak levels for the indicated number of theeth. This should be set to match the number of target teeth.*/
    rand uvm_reg_field teeth;

    /*Default tpo value
    Default switching threshold for device from power on to RMT. May be superseded by thresh_a/b/c*/
    rand uvm_reg_field fact_tpo;

    /*Watchdog Enable*/
    rand uvm_reg_field wdog_en;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        rmt: coverpoint rmt.value[2:0];
        pol: coverpoint pol.value[0:0];
        aggr: coverpoint aggr.value[0:0];
        teeth: coverpoint teeth.value[3:0];
        fact_tpo: coverpoint fact_tpo.value[12:0];
        wdog_en: coverpoint wdog_en.value[0:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        rmt: coverpoint rmt.value[2:0];
        pol: coverpoint pol.value[0:0];
        aggr: coverpoint aggr.value[0:0];
        teeth: coverpoint teeth.value[3:0];
        fact_tpo: coverpoint fact_tpo.value[12:0];
        wdog_en: coverpoint wdog_en.value[0:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_4");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.rmt = uvm_reg_field::type_id::create("rmt");
        this.pol = uvm_reg_field::type_id::create("pol");
        this.aggr = uvm_reg_field::type_id::create("aggr");
        this.teeth = uvm_reg_field::type_id::create("teeth");
        this.fact_tpo = uvm_reg_field::type_id::create("fact_tpo");
        this.wdog_en = uvm_reg_field::type_id::create("wdog_en");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.rmt.configure(this, 3,  3, "RW", 0, 3'd0, 1, 1, 0);
        this.pol.configure(this, 1,  6, "RW", 0, 1'd0, 1, 1, 0);
        this.aggr.configure(this, 1,  7, "RW", 0, 1'd0, 1, 1, 0);
        this.teeth.configure(this, 4,  8, "RW", 0, 4'd0, 1, 1, 0);
        this.fact_tpo.configure(this, 13,  12, "RW", 0, 13'd0, 1, 1, 0);
        this.wdog_en.configure(this, 1,  25, "RW", 0, 1'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_5
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_5
`define CLASS_reg_map_eeprom_eeprom_5
class reg_map_eeprom_eeprom_5 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_5)

    /*Threshold for the rising edge*/
    rand uvm_reg_field thrr;

    /*Threshold for the falling edge*/
    rand uvm_reg_field thrf;

    /*Fast Fall mode on output enable*/
    rand uvm_reg_field ffall;

    /*ADC Feedback test mode*/
    rand uvm_reg_field fb_test;

    /*SAR DEM test mode*/
    rand uvm_reg_field dem_test;

    /*FE Calibration disable, holds segment and chop weights at 0*/
    rand uvm_reg_field fe_cal_dis;

    /*Enables variable chopping*/
    rand uvm_reg_field variable_chop;

    /*selects filter settings*/
    rand uvm_reg_field adc_filter_sel;

    /*Disables TPO self write*/
    rand uvm_reg_field tpoself_dis;

    /*Level for TPO self write*/
    rand uvm_reg_field tpoself_lvl;

    /*Temperature compensation value*/
    rand uvm_reg_field temp_comp;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        thrr: coverpoint thrr.value[3:0];
        thrf: coverpoint thrf.value[3:0];
        ffall: coverpoint ffall.value[0:0];
        fb_test: coverpoint fb_test.value[0:0];
        dem_test: coverpoint dem_test.value[0:0];
        fe_cal_dis: coverpoint fe_cal_dis.value[0:0];
        variable_chop: coverpoint variable_chop.value[0:0];
        adc_filter_sel: coverpoint adc_filter_sel.value[0:0];
        tpoself_dis: coverpoint tpoself_dis.value[0:0];
        tpoself_lvl: coverpoint tpoself_lvl.value[0:0];
        temp_comp: coverpoint temp_comp.value[3:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        thrr: coverpoint thrr.value[3:0];
        thrf: coverpoint thrf.value[3:0];
        ffall: coverpoint ffall.value[0:0];
        fb_test: coverpoint fb_test.value[0:0];
        dem_test: coverpoint dem_test.value[0:0];
        fe_cal_dis: coverpoint fe_cal_dis.value[0:0];
        variable_chop: coverpoint variable_chop.value[0:0];
        adc_filter_sel: coverpoint adc_filter_sel.value[0:0];
        tpoself_dis: coverpoint tpoself_dis.value[0:0];
        tpoself_lvl: coverpoint tpoself_lvl.value[0:0];
        temp_comp: coverpoint temp_comp.value[3:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_5");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.thrr = uvm_reg_field::type_id::create("thrr");
        this.thrf = uvm_reg_field::type_id::create("thrf");
        this.ffall = uvm_reg_field::type_id::create("ffall");
        this.fb_test = uvm_reg_field::type_id::create("fb_test");
        this.dem_test = uvm_reg_field::type_id::create("dem_test");
        this.fe_cal_dis = uvm_reg_field::type_id::create("fe_cal_dis");
        this.variable_chop = uvm_reg_field::type_id::create("variable_chop");
        this.adc_filter_sel = uvm_reg_field::type_id::create("adc_filter_sel");
        this.tpoself_dis = uvm_reg_field::type_id::create("tpoself_dis");
        this.tpoself_lvl = uvm_reg_field::type_id::create("tpoself_lvl");
        this.temp_comp = uvm_reg_field::type_id::create("temp_comp");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.thrr.configure(this, 4,  0, "RW", 0, 4'd0, 1, 1, 0);
        this.thrf.configure(this, 4,  4, "RW", 0, 4'd0, 1, 1, 0);
        this.ffall.configure(this, 1,  8, "RW", 0, 1'd0, 1, 1, 0);
        this.fb_test.configure(this, 1,  9, "RW", 0, 1'd0, 1, 1, 0);
        this.dem_test.configure(this, 1,  10, "RW", 0, 1'd0, 1, 1, 0);
        this.fe_cal_dis.configure(this, 1,  11, "RW", 0, 1'd0, 1, 1, 0);
        this.variable_chop.configure(this, 1,  12, "RW", 0, 1'd0, 1, 1, 0);
        this.adc_filter_sel.configure(this, 1,  13, "RW", 0, 1'd0, 1, 1, 0);
        this.tpoself_dis.configure(this, 1,  14, "RW", 0, 1'd0, 1, 1, 0);
        this.tpoself_lvl.configure(this, 1,  15, "RW", 0, 1'd0, 1, 1, 0);
        this.temp_comp.configure(this, 4,  16, "RW", 0, 4'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_6
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_6
`define CLASS_reg_map_eeprom_eeprom_6
class reg_map_eeprom_eeprom_6 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_6)

    /*The DIFF value to be offset to mid scale at -40 ?C.*/
    rand uvm_reg_field diff_baseline_40;

    /*The TPO level at cold to be gain corrected to match 25 ?C.*/
    rand uvm_reg_field diff_tpo_40;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        diff_baseline_40: coverpoint diff_baseline_40.value[12:0];
        diff_tpo_40: coverpoint diff_tpo_40.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        diff_baseline_40: coverpoint diff_baseline_40.value[12:0];
        diff_tpo_40: coverpoint diff_tpo_40.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_6");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff_baseline_40 = uvm_reg_field::type_id::create("diff_baseline_40");
        this.diff_tpo_40 = uvm_reg_field::type_id::create("diff_tpo_40");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.diff_baseline_40.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.diff_tpo_40.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_7
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_7
`define CLASS_reg_map_eeprom_eeprom_7
class reg_map_eeprom_eeprom_7 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_7)

    /*The DIFF value to be offset to mid scale at 25 ?C.*/
    rand uvm_reg_field diff_baseline_25;

    /*The reference TPO level.*/
    rand uvm_reg_field diff_tpo_25;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        diff_baseline_25: coverpoint diff_baseline_25.value[12:0];
        diff_tpo_25: coverpoint diff_tpo_25.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        diff_baseline_25: coverpoint diff_baseline_25.value[12:0];
        diff_tpo_25: coverpoint diff_tpo_25.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_7");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff_baseline_25 = uvm_reg_field::type_id::create("diff_baseline_25");
        this.diff_tpo_25 = uvm_reg_field::type_id::create("diff_tpo_25");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.diff_baseline_25.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.diff_tpo_25.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_8
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_8
`define CLASS_reg_map_eeprom_eeprom_8
class reg_map_eeprom_eeprom_8 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_8)

    /*The DIFF value to be offset to mid scale at 165 ?C.*/
    rand uvm_reg_field diff_baseline_165;

    /*The TPO level at hot to be gain corrected to match 25 ?C.*/
    rand uvm_reg_field diff_tpo_165;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        diff_baseline_165: coverpoint diff_baseline_165.value[12:0];
        diff_tpo_165: coverpoint diff_tpo_165.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        diff_baseline_165: coverpoint diff_baseline_165.value[12:0];
        diff_tpo_165: coverpoint diff_tpo_165.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_8");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.diff_baseline_165 = uvm_reg_field::type_id::create("diff_baseline_165");
        this.diff_tpo_165 = uvm_reg_field::type_id::create("diff_tpo_165");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.diff_baseline_165.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.diff_tpo_165.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_9
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_9
`define CLASS_reg_map_eeprom_eeprom_9
class reg_map_eeprom_eeprom_9 extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_9)

    /*Hall Plate Trim*/
    rand uvm_reg_field halltrim;

    /*Oscillator Trim (available at reset)*/
    rand uvm_reg_field osc_trim;

    /*Reference Bandgap Trim*/
    rand uvm_reg_field ref_bg_trim;

    /*Output fall time trim.*/
    rand uvm_reg_field out_fastfall;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        halltrim: coverpoint halltrim.value[6:0];
        osc_trim: coverpoint osc_trim.value[4:0];
        ref_bg_trim: coverpoint ref_bg_trim.value[4:0];
        out_fastfall: coverpoint out_fastfall.value[0:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        halltrim: coverpoint halltrim.value[6:0];
        osc_trim: coverpoint osc_trim.value[4:0];
        ref_bg_trim: coverpoint ref_bg_trim.value[4:0];
        out_fastfall: coverpoint out_fastfall.value[0:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_9");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.halltrim = uvm_reg_field::type_id::create("halltrim");
        this.osc_trim = uvm_reg_field::type_id::create("osc_trim");
        this.ref_bg_trim = uvm_reg_field::type_id::create("ref_bg_trim");
        this.out_fastfall = uvm_reg_field::type_id::create("out_fastfall");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.halltrim.configure(this, 7,  0, "RW", 0, 7'd0, 1, 1, 0);
        this.osc_trim.configure(this, 5,  7, "RW", 0, 5'd0, 1, 1, 0);
        this.ref_bg_trim.configure(this, 5,  12, "RW", 0, 5'd0, 1, 1, 0);
        this.out_fastfall.configure(this, 1,  17, "RW", 0, 1'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_a
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_a
`define CLASS_reg_map_eeprom_eeprom_a
class reg_map_eeprom_eeprom_a extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_a)

    /*
    Disable Test Modes
    - Disables access to the Allegro Test Modes.
    Note: does not lock the customer diagnostic test mode. See lock_o field.
    */
    rand uvm_reg_field lock_t;

    /*
    Allegro EEPROM Lock
    - Locks access to:
    Allegro factory traceability registers
    Allegro factory trim registers
    */
    rand uvm_reg_field lock_a;

    /*
    Customer EEPROM Lock
    - Locks access to the customer portion of the EEPROM.
    Note: Does not include the other customer accessible lock bits or the customer scratch register.
    */
    rand uvm_reg_field lock_c;

    /*
    Disable OEM End-of-Line Target Profiling Test Mode Access
    */
    rand uvm_reg_field lock_o;

    /*
    Lock Customer Scratch Area
    */
    rand uvm_reg_field lock_s;

    /*
    Lock Backdoor Unlock
    - Disables the backdoor unlock (makes all locks final)
    */
    rand uvm_reg_field lock_bd;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        lock_t: coverpoint lock_t.value[0:0];
        lock_a: coverpoint lock_a.value[0:0];
        lock_c: coverpoint lock_c.value[0:0];
        lock_o: coverpoint lock_o.value[0:0];
        lock_s: coverpoint lock_s.value[0:0];
        lock_bd: coverpoint lock_bd.value[0:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        lock_t: coverpoint lock_t.value[0:0];
        lock_a: coverpoint lock_a.value[0:0];
        lock_c: coverpoint lock_c.value[0:0];
        lock_o: coverpoint lock_o.value[0:0];
        lock_s: coverpoint lock_s.value[0:0];
        lock_bd: coverpoint lock_bd.value[0:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_a");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.lock_t = uvm_reg_field::type_id::create("lock_t");
        this.lock_a = uvm_reg_field::type_id::create("lock_a");
        this.lock_c = uvm_reg_field::type_id::create("lock_c");
        this.lock_o = uvm_reg_field::type_id::create("lock_o");
        this.lock_s = uvm_reg_field::type_id::create("lock_s");
        this.lock_bd = uvm_reg_field::type_id::create("lock_bd");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.lock_t.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_a.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_c.configure(this, 1,  2, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_o.configure(this, 1,  3, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_s.configure(this, 1,  4, "RW", 0, 1'd0, 1, 1, 0);
        this.lock_bd.configure(this, 1,  5, "RW", 0, 1'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_b
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_b
`define CLASS_reg_map_eeprom_eeprom_b
class reg_map_eeprom_eeprom_b extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_b)

    /*Self Programmed Threshold value*/
    rand uvm_reg_field thresh_a;

    /*Self programmed counter*/
    rand uvm_reg_field self_count_a;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        thresh_a: coverpoint thresh_a.value[12:0];
        self_count_a: coverpoint self_count_a.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        thresh_a: coverpoint thresh_a.value[12:0];
        self_count_a: coverpoint self_count_a.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_b");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.thresh_a = uvm_reg_field::type_id::create("thresh_a");
        this.self_count_a = uvm_reg_field::type_id::create("self_count_a");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.thresh_a.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.self_count_a.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_c
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_c
`define CLASS_reg_map_eeprom_eeprom_c
class reg_map_eeprom_eeprom_c extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_c)

    /*Self Programmed Threshold value*/
    rand uvm_reg_field thresh_b;

    /*Self programmed counter*/
    rand uvm_reg_field self_count_b;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        thresh_b: coverpoint thresh_b.value[12:0];
        self_count_b: coverpoint self_count_b.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        thresh_b: coverpoint thresh_b.value[12:0];
        self_count_b: coverpoint self_count_b.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_c");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.thresh_b = uvm_reg_field::type_id::create("thresh_b");
        this.self_count_b = uvm_reg_field::type_id::create("self_count_b");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.thresh_b.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.self_count_b.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_d
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_d
`define CLASS_reg_map_eeprom_eeprom_d
class reg_map_eeprom_eeprom_d extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_d)

    /*Self Programmed Threshold value*/
    rand uvm_reg_field thresh_c;

    /*Self programmed counter*/
    rand uvm_reg_field self_count_c;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (!m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (!m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_24: coverpoint {m_current[24],m_data[24]} iff (m_is_read && m_be[24]);
        field_25: coverpoint {m_current[25],m_data[25]} iff (m_is_read && m_be[25]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        thresh_c: coverpoint thresh_c.value[12:0];
        self_count_c: coverpoint self_count_c.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        thresh_c: coverpoint thresh_c.value[12:0];
        self_count_c: coverpoint self_count_c.value[12:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_d");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.thresh_c = uvm_reg_field::type_id::create("thresh_c");
        this.self_count_c = uvm_reg_field::type_id::create("self_count_c");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.thresh_c.configure(this, 13,  0, "RW", 0, 13'd0, 1, 1, 0);
        this.self_count_c.configure(this, 13,  13, "RW", 0, 13'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_e
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_e
`define CLASS_reg_map_eeprom_eeprom_e
class reg_map_eeprom_eeprom_e extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_e)

    /*The three stored tpos did not match when read back*/
    rand uvm_reg_field match_err;

    /*dual bit error (at least one) occurred during read back*/
    rand uvm_reg_field read_err;

    /*Error occurred while writing data*/
    rand uvm_reg_field write_err;

    /*dbe status flags for read back
    bit 0: dbe occurred during read of A
    bit1: dbe occurred during read of B
    bit2: dbe occurred during read of C
    This field is updated anytime a read error occurs*/
    rand uvm_reg_field read_err_loc;

    /*write error fail address
    00: A
    01: B
    10: C*/
    rand uvm_reg_field write_err_loc;

    /*Temperature value (output temperature of the temperature filter block)*/
    rand uvm_reg_field temp;

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (!m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (!m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (!m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (!m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (!m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (!m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (!m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (!m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (!m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (!m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (!m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (!m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (!m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (!m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (!m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (!m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (!m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (!m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (!m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (!m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (!m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (!m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (!m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (!m_is_read && m_be[23]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_0: coverpoint {m_current[0],m_data[0]} iff (m_is_read && m_be[0]);
        field_1: coverpoint {m_current[1],m_data[1]} iff (m_is_read && m_be[1]);
        field_2: coverpoint {m_current[2],m_data[2]} iff (m_is_read && m_be[2]);
        field_3: coverpoint {m_current[3],m_data[3]} iff (m_is_read && m_be[3]);
        field_4: coverpoint {m_current[4],m_data[4]} iff (m_is_read && m_be[4]);
        field_5: coverpoint {m_current[5],m_data[5]} iff (m_is_read && m_be[5]);
        field_6: coverpoint {m_current[6],m_data[6]} iff (m_is_read && m_be[6]);
        field_7: coverpoint {m_current[7],m_data[7]} iff (m_is_read && m_be[7]);
        field_8: coverpoint {m_current[8],m_data[8]} iff (m_is_read && m_be[8]);
        field_9: coverpoint {m_current[9],m_data[9]} iff (m_is_read && m_be[9]);
        field_10: coverpoint {m_current[10],m_data[10]} iff (m_is_read && m_be[10]);
        field_11: coverpoint {m_current[11],m_data[11]} iff (m_is_read && m_be[11]);
        field_12: coverpoint {m_current[12],m_data[12]} iff (m_is_read && m_be[12]);
        field_13: coverpoint {m_current[13],m_data[13]} iff (m_is_read && m_be[13]);
        field_14: coverpoint {m_current[14],m_data[14]} iff (m_is_read && m_be[14]);
        field_15: coverpoint {m_current[15],m_data[15]} iff (m_is_read && m_be[15]);
        field_16: coverpoint {m_current[16],m_data[16]} iff (m_is_read && m_be[16]);
        field_17: coverpoint {m_current[17],m_data[17]} iff (m_is_read && m_be[17]);
        field_18: coverpoint {m_current[18],m_data[18]} iff (m_is_read && m_be[18]);
        field_19: coverpoint {m_current[19],m_data[19]} iff (m_is_read && m_be[19]);
        field_20: coverpoint {m_current[20],m_data[20]} iff (m_is_read && m_be[20]);
        field_21: coverpoint {m_current[21],m_data[21]} iff (m_is_read && m_be[21]);
        field_22: coverpoint {m_current[22],m_data[22]} iff (m_is_read && m_be[22]);
        field_23: coverpoint {m_current[23],m_data[23]} iff (m_is_read && m_be[23]);
        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        match_err: coverpoint match_err.value[0:0];
        read_err: coverpoint read_err.value[0:0];
        write_err: coverpoint write_err.value[0:0];
        read_err_loc: coverpoint read_err_loc.value[2:0];
        write_err_loc: coverpoint write_err_loc.value[1:0];
        temp: coverpoint temp.value[15:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        match_err: coverpoint match_err.value[0:0];
        read_err: coverpoint read_err.value[0:0];
        write_err: coverpoint write_err.value[0:0];
        read_err_loc: coverpoint read_err_loc.value[2:0];
        write_err_loc: coverpoint write_err_loc.value[1:0];
        temp: coverpoint temp.value[15:0];
        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_e");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.match_err = uvm_reg_field::type_id::create("match_err");
        this.read_err = uvm_reg_field::type_id::create("read_err");
        this.write_err = uvm_reg_field::type_id::create("write_err");
        this.read_err_loc = uvm_reg_field::type_id::create("read_err_loc");
        this.write_err_loc = uvm_reg_field::type_id::create("write_err_loc");
        this.temp = uvm_reg_field::type_id::create("temp");
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.match_err.configure(this, 1,  0, "RW", 0, 1'd0, 1, 1, 0);
        this.read_err.configure(this, 1,  1, "RW", 0, 1'd0, 1, 1, 0);
        this.write_err.configure(this, 1,  2, "RW", 0, 1'd0, 1, 1, 0);
        this.read_err_loc.configure(this, 3,  3, "RW", 0, 3'd0, 1, 1, 0);
        this.write_err_loc.configure(this, 2,  6, "RW", 0, 2'd0, 1, 1, 0);
        this.temp.configure(this, 16,  8, "RW", 0, 16'd0, 1, 1, 0);
        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom_eeprom_f
-----------------------------------------------------------------------*/

`ifndef CLASS_reg_map_eeprom_eeprom_f
`define CLASS_reg_map_eeprom_eeprom_f
class reg_map_eeprom_eeprom_f extends uvm_reg;
    `uvm_object_utils(reg_map_eeprom_eeprom_f)

    /*Error Correction Code (ECC) value for bits [25:0]*/
    rand uvm_reg_field ecc;

    local uvm_reg_data_t m_current;
    local uvm_reg_data_t m_data;
    local uvm_reg_data_t m_be;
    local bit            m_is_read;

    covergroup wr_cg_bits;

        field_26: coverpoint {m_current[26],m_data[26]} iff (!m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (!m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (!m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (!m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (!m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (!m_is_read && m_be[31]);

    endgroup

    covergroup rd_cg_bits;

        field_26: coverpoint {m_current[26],m_data[26]} iff (m_is_read && m_be[26]);
        field_27: coverpoint {m_current[27],m_data[27]} iff (m_is_read && m_be[27]);
        field_28: coverpoint {m_current[28],m_data[28]} iff (m_is_read && m_be[28]);
        field_29: coverpoint {m_current[29],m_data[29]} iff (m_is_read && m_be[29]);
        field_30: coverpoint {m_current[30],m_data[30]} iff (m_is_read && m_be[30]);
        field_31: coverpoint {m_current[31],m_data[31]} iff (m_is_read && m_be[31]);

    endgroup

    covergroup wr_cg_vals;

        ecc: coverpoint ecc.value[5:0];
    endgroup

    covergroup rd_cg_vals;

        ecc: coverpoint ecc.value[5:0];
    endgroup

    // Function : new
    function new(string name = "reg_map_eeprom_eeprom_f");
        super.new(name, 32, build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));
        add_coverage(build_coverage(UVM_CVR_REG_BITS + UVM_CVR_FIELD_VALS));            //Added because build coverage in the line above doesn’t work due to a bug in UVM 1.1 library

        if (has_coverage(UVM_CVR_REG_BITS)) begin
            wr_cg_bits = new();
            rd_cg_bits = new();
        end

        if (has_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals = new();
            rd_cg_vals = new();
        end

    endfunction
    protected virtual function void sample(uvm_reg_data_t data, uvm_reg_data_t byte_en, bit is_read, uvm_reg_map map);
        super.sample(data, byte_en, is_read, map);
        if (get_coverage(UVM_CVR_REG_BITS)) begin
            m_current = get();
            m_data    = data;
            m_be      = byte_en;
            m_is_read = is_read;

            if(!is_read) begin
                wr_cg_bits.sample();
            end

            if(is_read) begin
                rd_cg_bits.sample();
            end

        end
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            if(!is_read) begin
                wr_cg_vals.sample();
            end
            if(is_read) begin
                rd_cg_vals.sample();
            end

        end
    endfunction

    virtual function void sample_values();
        super.sample_values();
        if (get_coverage(UVM_CVR_FIELD_VALS)) begin
            wr_cg_vals.sample();
            rd_cg_vals.sample();
        end
    endfunction

    // Function : build
    virtual function void build();
        this.ecc = uvm_reg_field::type_id::create("ecc");

        this.ecc.configure(this, 6,  26, "RW", 0, 6'd0, 1, 1, 0);

    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_eeprom
-----------------------------------------------------------------------*/
`ifndef CLASS_reg_map_eeprom
`define CLASS_reg_map_eeprom
class reg_map_eeprom extends uvm_reg_file;
    `uvm_object_utils(reg_map_eeprom)

    rand reg_map_eeprom_eeprom_0 eeprom_0;

    rand reg_map_eeprom_eeprom_1 eeprom_1;

    rand reg_map_eeprom_eeprom_2 eeprom_2;

    rand reg_map_eeprom_eeprom_3 eeprom_3;

    rand reg_map_eeprom_eeprom_4 eeprom_4;

    rand reg_map_eeprom_eeprom_5 eeprom_5;

    rand reg_map_eeprom_eeprom_6 eeprom_6;

    rand reg_map_eeprom_eeprom_7 eeprom_7;

    rand reg_map_eeprom_eeprom_8 eeprom_8;

    rand reg_map_eeprom_eeprom_9 eeprom_9;

    rand reg_map_eeprom_eeprom_a eeprom_a;

    rand reg_map_eeprom_eeprom_b eeprom_b;

    rand reg_map_eeprom_eeprom_c eeprom_c;

    rand reg_map_eeprom_eeprom_d eeprom_d;

    rand reg_map_eeprom_eeprom_e eeprom_e;

    rand reg_map_eeprom_eeprom_f eeprom_f;

    // Function : new
    function new(string name = "reg_map_eeprom");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        eeprom_0   =   reg_map_eeprom_eeprom_0::type_id::create("eeprom_0");
        eeprom_1   =   reg_map_eeprom_eeprom_1::type_id::create("eeprom_1");
        eeprom_2   =   reg_map_eeprom_eeprom_2::type_id::create("eeprom_2");
        eeprom_3   =   reg_map_eeprom_eeprom_3::type_id::create("eeprom_3");
        eeprom_4   =   reg_map_eeprom_eeprom_4::type_id::create("eeprom_4");
        eeprom_5   =   reg_map_eeprom_eeprom_5::type_id::create("eeprom_5");
        eeprom_6   =   reg_map_eeprom_eeprom_6::type_id::create("eeprom_6");
        eeprom_7   =   reg_map_eeprom_eeprom_7::type_id::create("eeprom_7");
        eeprom_8   =   reg_map_eeprom_eeprom_8::type_id::create("eeprom_8");
        eeprom_9   =   reg_map_eeprom_eeprom_9::type_id::create("eeprom_9");
        eeprom_a   =   reg_map_eeprom_eeprom_a::type_id::create("eeprom_a");
        eeprom_b   =   reg_map_eeprom_eeprom_b::type_id::create("eeprom_b");
        eeprom_c   =   reg_map_eeprom_eeprom_c::type_id::create("eeprom_c");
        eeprom_d   =   reg_map_eeprom_eeprom_d::type_id::create("eeprom_d");
        eeprom_e   =   reg_map_eeprom_eeprom_e::type_id::create("eeprom_e");
        eeprom_f   =   reg_map_eeprom_eeprom_f::type_id::create("eeprom_f");

        //config
        eeprom_0.configure(get_block(), this, "eeprom_0");
        eeprom_1.configure(get_block(), this, "eeprom_1");
        eeprom_2.configure(get_block(), this, "eeprom_2");
        eeprom_3.configure(get_block(), this, "eeprom_3");
        eeprom_4.configure(get_block(), this, "eeprom_4");
        eeprom_5.configure(get_block(), this, "eeprom_5");
        eeprom_6.configure(get_block(), this, "eeprom_6");
        eeprom_7.configure(get_block(), this, "eeprom_7");
        eeprom_8.configure(get_block(), this, "eeprom_8");
        eeprom_9.configure(get_block(), this, "eeprom_9");
        eeprom_a.configure(get_block(), this, "eeprom_a");
        eeprom_b.configure(get_block(), this, "eeprom_b");
        eeprom_c.configure(get_block(), this, "eeprom_c");
        eeprom_d.configure(get_block(), this, "eeprom_d");
        eeprom_e.configure(get_block(), this, "eeprom_e");
        eeprom_f.configure(get_block(), this, "eeprom_f");

        //build
        eeprom_0.build();
        eeprom_1.build();
        eeprom_2.build();
        eeprom_3.build();
        eeprom_4.build();
        eeprom_5.build();
        eeprom_6.build();
        eeprom_7.build();
        eeprom_8.build();
        eeprom_9.build();
        eeprom_a.build();
        eeprom_b.build();
        eeprom_c.build();
        eeprom_d.build();
        eeprom_e.build();
        eeprom_f.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg(eeprom_0, offset +  'h0, "RW");
        mp.add_reg(eeprom_1, offset +  'h1, "RW");
        mp.add_reg(eeprom_2, offset +  'h2, "RW");
        mp.add_reg(eeprom_3, offset +  'h3, "RW");
        mp.add_reg(eeprom_4, offset +  'h4, "RW");
        mp.add_reg(eeprom_5, offset +  'h5, "RW");
        mp.add_reg(eeprom_6, offset +  'h6, "RW");
        mp.add_reg(eeprom_7, offset +  'h7, "RW");
        mp.add_reg(eeprom_8, offset +  'h8, "RW");
        mp.add_reg(eeprom_9, offset +  'h9, "RW");
        mp.add_reg(eeprom_a, offset +  'hA, "RW");
        mp.add_reg(eeprom_b, offset +  'hB, "RW");
        mp.add_reg(eeprom_c, offset +  'hC, "RW");
        mp.add_reg(eeprom_d, offset +  'hD, "RW");
        mp.add_reg(eeprom_e, offset +  'hE, "RW");
        mp.add_reg(eeprom_f, offset +  'hF, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        eeprom_0.set_offset(mp, offset +  'h0);
        eeprom_1.set_offset(mp, offset +  'h1);
        eeprom_2.set_offset(mp, offset +  'h2);
        eeprom_3.set_offset(mp, offset +  'h3);
        eeprom_4.set_offset(mp, offset +  'h4);
        eeprom_5.set_offset(mp, offset +  'h5);
        eeprom_6.set_offset(mp, offset +  'h6);
        eeprom_7.set_offset(mp, offset +  'h7);
        eeprom_8.set_offset(mp, offset +  'h8);
        eeprom_9.set_offset(mp, offset +  'h9);
        eeprom_a.set_offset(mp, offset +  'hA);
        eeprom_b.set_offset(mp, offset +  'hB);
        eeprom_c.set_offset(mp, offset +  'hC);
        eeprom_d.set_offset(mp, offset +  'hD);
        eeprom_e.set_offset(mp, offset +  'hE);
        eeprom_f.set_offset(mp, offset +  'hF);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_shadow
-----------------------------------------------------------------------*/
`ifndef CLASS_reg_map_shadow
`define CLASS_reg_map_shadow
class reg_map_shadow extends uvm_reg_file;
    `uvm_object_utils(reg_map_shadow)

    rand reg_map_shadow_shadow_4 shadow_4;

    rand reg_map_shadow_shadow_5 shadow_5;

    rand reg_map_shadow_shadow_6 shadow_6;

    rand reg_map_shadow_shadow_7 shadow_7;

    rand reg_map_shadow_shadow_8 shadow_8;

    rand reg_map_shadow_shadow_9 shadow_9;

    rand reg_map_shadow_shadow_a shadow_a;

    // Function : new
    function new(string name = "reg_map_shadow");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        shadow_4   =   reg_map_shadow_shadow_4::type_id::create("shadow_4");
        shadow_5   =   reg_map_shadow_shadow_5::type_id::create("shadow_5");
        shadow_6   =   reg_map_shadow_shadow_6::type_id::create("shadow_6");
        shadow_7   =   reg_map_shadow_shadow_7::type_id::create("shadow_7");
        shadow_8   =   reg_map_shadow_shadow_8::type_id::create("shadow_8");
        shadow_9   =   reg_map_shadow_shadow_9::type_id::create("shadow_9");
        shadow_a   =   reg_map_shadow_shadow_a::type_id::create("shadow_a");

        //config
        shadow_4.configure(get_block(), this, "shadow_4");
        shadow_5.configure(get_block(), this, "shadow_5");
        shadow_6.configure(get_block(), this, "shadow_6");
        shadow_7.configure(get_block(), this, "shadow_7");
        shadow_8.configure(get_block(), this, "shadow_8");
        shadow_9.configure(get_block(), this, "shadow_9");
        shadow_a.configure(get_block(), this, "shadow_a");

        //build
        shadow_4.build();
        shadow_5.build();
        shadow_6.build();
        shadow_7.build();
        shadow_8.build();
        shadow_9.build();
        shadow_a.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg(shadow_4, offset +  'h0, "RW");
        mp.add_reg(shadow_5, offset +  'h1, "RW");
        mp.add_reg(shadow_6, offset +  'h2, "RW");
        mp.add_reg(shadow_7, offset +  'h3, "RW");
        mp.add_reg(shadow_8, offset +  'h4, "RW");
        mp.add_reg(shadow_9, offset +  'h5, "RW");
        mp.add_reg(shadow_a, offset +  'h6, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        shadow_4.set_offset(mp, offset +  'h0);
        shadow_5.set_offset(mp, offset +  'h1);
        shadow_6.set_offset(mp, offset +  'h2);
        shadow_7.set_offset(mp, offset +  'h3);
        shadow_8.set_offset(mp, offset +  'h4);
        shadow_9.set_offset(mp, offset +  'h5);
        shadow_a.set_offset(mp, offset +  'h6);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class       : reg_map_volatile
-----------------------------------------------------------------------*/
`ifndef CLASS_reg_map_volatile
`define CLASS_reg_map_volatile
class reg_map_volatile extends uvm_reg_file;
    `uvm_object_utils(reg_map_volatile)

    rand reg_map_volatile_status0 status0;

    rand reg_map_volatile_cfg0 cfg0;

    rand reg_map_volatile_cfg1 cfg1;

    rand reg_map_volatile_cfg2 cfg2;

    rand reg_map_volatile_test_result test_result;

    rand reg_map_volatile_hallphase hallphase;

    rand reg_map_volatile_state state;

    rand reg_map_volatile_temperature temperature;

    rand reg_map_volatile_pdiff pdiff;

    rand reg_map_volatile_diff diff;

    rand reg_map_volatile_tdiff tdiff;

    rand reg_map_volatile_out out;

    rand reg_map_volatile_ppeak ppeak;

    rand reg_map_volatile_plast plast;

    rand reg_map_volatile_npeak npeak;

    rand reg_map_volatile_stored_tpo stored_tpo;

    rand reg_map_volatile_ee_cfg ee_cfg;

    rand reg_map_volatile_cp_cfg cp_cfg;

    rand reg_map_volatile_ee_status ee_status;

    rand reg_map_volatile_ee_data ee_data;

    rand reg_map_volatile_pat_test pat_test;

    rand reg_map_volatile_marg_test marg_test;

    rand reg_map_volatile_test_cfg test_cfg;

    // Function : new
    function new(string name = "reg_map_volatile");
        super.new(name);
    endfunction

    // Function : build
    virtual function void build();
        //create
        status0   =   reg_map_volatile_status0::type_id::create("status0");
        cfg0   =   reg_map_volatile_cfg0::type_id::create("cfg0");
        cfg1   =   reg_map_volatile_cfg1::type_id::create("cfg1");
        cfg2   =   reg_map_volatile_cfg2::type_id::create("cfg2");
        test_result   =   reg_map_volatile_test_result::type_id::create("test_result");
        hallphase   =   reg_map_volatile_hallphase::type_id::create("hallphase");
        state   =   reg_map_volatile_state::type_id::create("state");
        temperature   =   reg_map_volatile_temperature::type_id::create("temperature");
        pdiff   =   reg_map_volatile_pdiff::type_id::create("pdiff");
        diff   =   reg_map_volatile_diff::type_id::create("diff");
        tdiff   =   reg_map_volatile_tdiff::type_id::create("tdiff");
        out   =   reg_map_volatile_out::type_id::create("out");
        ppeak   =   reg_map_volatile_ppeak::type_id::create("ppeak");
        plast   =   reg_map_volatile_plast::type_id::create("plast");
        npeak   =   reg_map_volatile_npeak::type_id::create("npeak");
        stored_tpo   =   reg_map_volatile_stored_tpo::type_id::create("stored_tpo");
        ee_cfg   =   reg_map_volatile_ee_cfg::type_id::create("ee_cfg");
        cp_cfg   =   reg_map_volatile_cp_cfg::type_id::create("cp_cfg");
        ee_status   =   reg_map_volatile_ee_status::type_id::create("ee_status");
        ee_data   =   reg_map_volatile_ee_data::type_id::create("ee_data");
        pat_test   =   reg_map_volatile_pat_test::type_id::create("pat_test");
        marg_test   =   reg_map_volatile_marg_test::type_id::create("marg_test");
        test_cfg   =   reg_map_volatile_test_cfg::type_id::create("test_cfg");

        //config
        status0.configure(get_block(), this, "status0");
        cfg0.configure(get_block(), this, "cfg0");
        cfg1.configure(get_block(), this, "cfg1");
        cfg2.configure(get_block(), this, "cfg2");
        test_result.configure(get_block(), this, "test_result");
        hallphase.configure(get_block(), this, "hallphase");
        state.configure(get_block(), this, "state");
        temperature.configure(get_block(), this, "temperature");
        pdiff.configure(get_block(), this, "pdiff");
        diff.configure(get_block(), this, "diff");
        tdiff.configure(get_block(), this, "tdiff");
        out.configure(get_block(), this, "out");
        ppeak.configure(get_block(), this, "ppeak");
        plast.configure(get_block(), this, "plast");
        npeak.configure(get_block(), this, "npeak");
        stored_tpo.configure(get_block(), this, "stored_tpo");
        ee_cfg.configure(get_block(), this, "ee_cfg");
        cp_cfg.configure(get_block(), this, "cp_cfg");
        ee_status.configure(get_block(), this, "ee_status");
        ee_data.configure(get_block(), this, "ee_data");
        pat_test.configure(get_block(), this, "pat_test");
        marg_test.configure(get_block(), this, "marg_test");
        test_cfg.configure(get_block(), this, "test_cfg");

        //build
        status0.build();
        cfg0.build();
        cfg1.build();
        cfg2.build();
        test_result.build();
        hallphase.build();
        state.build();
        temperature.build();
        pdiff.build();
        diff.build();
        tdiff.build();
        out.build();
        ppeak.build();
        plast.build();
        npeak.build();
        stored_tpo.build();
        ee_cfg.build();
        cp_cfg.build();
        ee_status.build();
        ee_data.build();
        pat_test.build();
        marg_test.build();
        test_cfg.build();
    endfunction

    virtual function void map(uvm_reg_map mp, uvm_reg_addr_t offset);
        //add reg and regfiles
        mp.add_reg(status0, offset +  'h0, "RW");
        mp.add_reg(cfg0, offset +  'h1, "RW");
        mp.add_reg(cfg1, offset +  'h2, "RW");
        mp.add_reg(cfg2, offset +  'h3, "RW");
        mp.add_reg(test_result, offset +  'h4, "RW");
        mp.add_reg(hallphase, offset +  'h5, "RW");
        mp.add_reg(state, offset +  'h6, "RW");
        mp.add_reg(temperature, offset +  'h7, "RW");
        mp.add_reg(pdiff, offset +  'h8, "RW");
        mp.add_reg(diff, offset +  'h9, "RW");
        mp.add_reg(tdiff, offset +  'hA, "RW");
        mp.add_reg(out, offset +  'hB, "RW");
        mp.add_reg(ppeak, offset +  'hC, "RW");
        mp.add_reg(plast, offset +  'hD, "RW");
        mp.add_reg(npeak, offset +  'hE, "RW");
        mp.add_reg(stored_tpo, offset +  'hF, "RW");
        mp.add_reg(ee_cfg, offset +  'h30, "RW");
        mp.add_reg(cp_cfg, offset +  'h31, "RW");
        mp.add_reg(ee_status, offset +  'h32, "RW");
        mp.add_reg(ee_data, offset +  'h33, "RW");
        mp.add_reg(pat_test, offset +  'h34, "RW");
        mp.add_reg(marg_test, offset +  'h35, "RW");
        mp.add_reg(test_cfg, offset +  'h36, "RW");
    endfunction

    virtual function void set_offset(uvm_reg_map mp, uvm_reg_addr_t offset);
        status0.set_offset(mp, offset +  'h0);
        cfg0.set_offset(mp, offset +  'h1);
        cfg1.set_offset(mp, offset +  'h2);
        cfg2.set_offset(mp, offset +  'h3);
        test_result.set_offset(mp, offset +  'h4);
        hallphase.set_offset(mp, offset +  'h5);
        state.set_offset(mp, offset +  'h6);
        temperature.set_offset(mp, offset +  'h7);
        pdiff.set_offset(mp, offset +  'h8);
        diff.set_offset(mp, offset +  'h9);
        tdiff.set_offset(mp, offset +  'hA);
        out.set_offset(mp, offset +  'hB);
        ppeak.set_offset(mp, offset +  'hC);
        plast.set_offset(mp, offset +  'hD);
        npeak.set_offset(mp, offset +  'hE);
        stored_tpo.set_offset(mp, offset +  'hF);
        ee_cfg.set_offset(mp, offset +  'h30);
        cp_cfg.set_offset(mp, offset +  'h31);
        ee_status.set_offset(mp, offset +  'h32);
        ee_data.set_offset(mp, offset +  'h33);
        pat_test.set_offset(mp, offset +  'h34);
        marg_test.set_offset(mp, offset +  'h35);
        test_cfg.set_offset(mp, offset +  'h36);
    endfunction
endclass
`endif

/*----------------------------------------------------------------------
Class      : reg_map_block
-----------------------------------------------------------------------*/
`ifndef CLASS_reg_map_block
`define CLASS_reg_map_block
class reg_map_block extends uvm_reg_block;
    `uvm_object_utils(reg_map_block)

    rand reg_map_volatile volatile;
    rand reg_map_shadow shadow;
    rand reg_map_eeprom eeprom;

    local uvm_reg_addr_t m_offset;
    covergroup cg_addr;

        volatile : coverpoint m_offset
        {
            bins hit =  { ['h0 : 'hDB] };
        }
        shadow : coverpoint m_offset
        {
            bins hit =  { ['h44 : 'h5F] };
        }
        eeprom : coverpoint m_offset
        {
            bins hit =  { ['h60 : 'h9F] };
        }

    endgroup

    // Function : new
    function new(string name = "reg_map_block");
        super.new(name, build_coverage(UVM_CVR_ADDR_MAP));

        if (has_coverage(UVM_CVR_ADDR_MAP)) begin
            cg_addr = new();

        end
    endfunction

    // Function : build
    virtual function void build();
        //VOLATILE
        volatile   =   reg_map_volatile::type_id::create("volatile");
        volatile.configure(this, null, "volatile");
        volatile.build();

        //SHADOW
        shadow   =   reg_map_shadow::type_id::create("shadow");
        shadow.configure(this, null, "shadow");
        shadow.build();

        //EEPROM
        eeprom   =   reg_map_eeprom::type_id::create("eeprom");
        eeprom.configure(this, null, "eeprom");
        eeprom.build();

        //define default map and add reg/regfiles
        default_map= create_map("default_map", 'h0, 4, UVM_BIG_ENDIAN, 0);
        volatile.map(default_map, 'h0);
        shadow.map(default_map, 'h44);
        eeprom.map(default_map, 'h60);

        volatile.clear_hdl_path();
        volatile.add_hdl_path("");
        volatile.status0.clear_hdl_path();
        volatile.status0.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.dsc_major", 0, 4);
        volatile.status0.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.dsc_minor", 4, 4);
        volatile.test_result.clear_hdl_path();
        volatile.test_result.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_test_adc_sar.seq_conv_result", 0, 8);
        volatile.test_result.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_test_adc_sar.sar_result", 8, 8);
        volatile.hallphase.clear_hdl_path();
        volatile.hallphase.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_scheduler.hallphase",0,32);
        volatile.state.clear_hdl_path();
        volatile.state.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.state",0,32);
        volatile.temperature.clear_hdl_path();
        volatile.temperature.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_temp_filter.temperature",0,32);
        volatile.pdiff.clear_hdl_path();
        volatile.pdiff.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_adc.pdiff",0,32);
        volatile.diff.clear_hdl_path();
        volatile.diff.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_filter.diff",0,32);
        volatile.tdiff.clear_hdl_path();
        volatile.tdiff.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_a2d.u_temp_compensate.tdiff",0,32);
        volatile.out.clear_hdl_path();
        volatile.out.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.out",0,32);
        volatile.ppeak.clear_hdl_path();
        volatile.ppeak.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.ppeak",0,32);
        volatile.plast.clear_hdl_path();
        volatile.plast.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.plast",0,32);
        volatile.npeak.clear_hdl_path();
        volatile.npeak.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_controller.u_csm.npeak",0,32);
        volatile.stored_tpo.clear_hdl_path();
        volatile.stored_tpo.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_tpo_read_write.stored_tpo",0,32);
        shadow.clear_hdl_path();
        shadow.add_hdl_path("");
        shadow.shadow_9.clear_hdl_path();
        shadow.shadow_9.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_halltrim.register", 0, 7);
        shadow.shadow_9.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_osc_trim.register", 7, 5);
        shadow.shadow_9.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_ref_bg_trim.register", 12, 5);
        shadow.shadow_9.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_out_fastfall.register", 17, 1);
        eeprom.clear_hdl_path();
        eeprom.add_hdl_path("");
        eeprom.eeprom_0.clear_hdl_path();
        eeprom.eeprom_0.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[0]",0,32);
        eeprom.eeprom_1.clear_hdl_path();
        eeprom.eeprom_1.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[1]",0,32);
        eeprom.eeprom_2.clear_hdl_path();
        eeprom.eeprom_2.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[2]",0,32);
        eeprom.eeprom_3.clear_hdl_path();
        eeprom.eeprom_3.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[3]",0,32);
        eeprom.eeprom_4.clear_hdl_path();
        eeprom.eeprom_4.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[4]",0,32);
        eeprom.eeprom_5.clear_hdl_path();
        eeprom.eeprom_5.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[5]",0,32);
        eeprom.eeprom_6.clear_hdl_path();
        eeprom.eeprom_6.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[6]",0,32);
        eeprom.eeprom_7.clear_hdl_path();
        eeprom.eeprom_7.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[7]",0,32);
        eeprom.eeprom_8.clear_hdl_path();
        eeprom.eeprom_8.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[8]",0,32);
        eeprom.eeprom_9.clear_hdl_path();
        eeprom.eeprom_9.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[9]",0,32);
        eeprom.eeprom_a.clear_hdl_path();
        eeprom.eeprom_a.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[10]",0,32);
        eeprom.eeprom_b.clear_hdl_path();
        eeprom.eeprom_b.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[11]",0,32);
        eeprom.eeprom_c.clear_hdl_path();
        eeprom.eeprom_c.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[12]",0,32);
        eeprom.eeprom_d.clear_hdl_path();
        eeprom.eeprom_d.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[13]",0,32);
        eeprom.eeprom_e.clear_hdl_path();
        eeprom.eeprom_e.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[14]",0,32);
        eeprom.eeprom_f.clear_hdl_path();
        eeprom.eeprom_f.add_hdl_path_slice("wrapper.u_dig_top.u_scan_top.u_controller_bist_top.u_controller_top.u_eeprom_top.eeprom_array.mem[15]",0,32);

        lock_model();
    endfunction

    protected virtual function void sample(uvm_reg_addr_t offset, bit is_read, uvm_reg_map map);
        if (get_coverage(UVM_CVR_ADDR_MAP))  begin

            m_offset  = offset;
            cg_addr.sample();
            if (this.get_parent() != null) begin
                this.get_parent().sample(m_offset+'h0,is_read,map);
            end
        end

    endfunction
endclass : reg_map_block
`endif
