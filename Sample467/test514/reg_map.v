//Allegro Microsystems LLC ***** Copyright 2017 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Saurabh
// generated from    : F:\testGit\git_test\Sample467\test514\163001_AutoHdlPath.idsng
// IDesignSpec rev   : idsbatch v 6.16.4.7

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 32
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : true
// LittleEndian               : true
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : REG_MAP MODULE
//

module reg_map(
    
    // REGISTER : STATUS0 PORT SIGNAL
    volatile_status0_dsc_major_in,
    volatile_status0_dsc_major_r,
    
    volatile_status0_dsc_minor_in,
    volatile_status0_dsc_minor_r,
    
    
    // REGISTER : CFG0 PORT SIGNAL
    volatile_cfg0_enb,
    volatile_cfg0_outmode_in,
    volatile_cfg0_outmode_in_enb,
    volatile_cfg0_outmode_r,
    
    volatile_cfg0_pdiff_we_in,
    volatile_cfg0_pdiff_we_in_enb,
    volatile_cfg0_pdiff_we_r,
    
    volatile_cfg0_diff_we_in,
    volatile_cfg0_diff_we_in_enb,
    volatile_cfg0_diff_we_r,
    
    volatile_cfg0_tdiff_we_in,
    volatile_cfg0_tdiff_we_in_enb,
    volatile_cfg0_tdiff_we_r,
    
    volatile_cfg0_hallphase_we_in,
    volatile_cfg0_hallphase_we_in_enb,
    volatile_cfg0_hallphase_we_r,
    
    volatile_cfg0_state_we_in,
    volatile_cfg0_state_we_in_enb,
    volatile_cfg0_state_we_r,
    
    volatile_cfg0_temperature_we_in,
    volatile_cfg0_temperature_we_in_enb,
    volatile_cfg0_temperature_we_r,
    
    volatile_cfg0_out_we_in,
    volatile_cfg0_out_we_in_enb,
    volatile_cfg0_out_we_r,
    
    volatile_cfg0_samp_dis_in,
    volatile_cfg0_samp_dis_in_enb,
    volatile_cfg0_samp_dis_r,
    
    volatile_cfg0_conv_dis_in,
    volatile_cfg0_conv_dis_in_enb,
    volatile_cfg0_conv_dis_r,
    
    volatile_cfg0_eforce_mode_in,
    volatile_cfg0_eforce_mode_in_enb,
    volatile_cfg0_eforce_mode_r,
    
    volatile_cfg0_force_hallshort_in,
    volatile_cfg0_force_hallshort_in_enb,
    volatile_cfg0_force_hallshort_r,
    
    volatile_cfg0_out_risetime_in,
    volatile_cfg0_out_risetime_in_enb,
    volatile_cfg0_out_risetime_r,
    
    volatile_cfg0_force_timeout_in,
    volatile_cfg0_force_timeout_in_enb,
    volatile_cfg0_force_timeout_r,
    
    volatile_cfg0_tpo_auto_update_in,
    volatile_cfg0_tpo_auto_update_in_enb,
    volatile_cfg0_tpo_auto_update_r,
    
    volatile_cfg0_force_tpo_in,
    volatile_cfg0_force_tpo_in_enb,
    volatile_cfg0_force_tpo_r,
    
    volatile_cfg0_cpump_load_in,
    volatile_cfg0_cpump_load_in_enb,
    volatile_cfg0_cpump_load_r,
    
    volatile_cfg0_out_prog_en_in,
    volatile_cfg0_out_prog_en_in_enb,
    volatile_cfg0_out_prog_en_r,
    
    
    // REGISTER : CFG1 PORT SIGNAL
    volatile_cfg1_enb,
    volatile_cfg1_eol_diag_en_in,
    volatile_cfg1_eol_diag_en_in_enb,
    volatile_cfg1_eol_diag_en_r,
    
    
    // REGISTER : CFG2 PORT SIGNAL
    volatile_cfg2_enb,
    volatile_cfg2_adc_test_start_in,
    volatile_cfg2_adc_test_start_in_enb,
    volatile_cfg2_adc_test_start_r,
    
    volatile_cfg2_auto_hall_start_in,
    volatile_cfg2_auto_hall_start_in_enb,
    volatile_cfg2_auto_hall_start_r,
    
    volatile_cfg2_auto_hall_target_in,
    volatile_cfg2_auto_hall_target_in_enb,
    volatile_cfg2_auto_hall_target_r,
    
    
    // REGISTER(EXTERNAL) : TEST_RESULT PORT SIGNAL
    volatile_test_result_rd_ack_in,
    volatile_test_result_rd_data_in,
    volatile_test_result_rd_valid_out,
    
    
    // REGISTER(EXTERNAL) : HALLPHASE PORT SIGNAL
    volatile_hallphase_rd_ack_in,
    volatile_hallphase_rd_data_in,
    volatile_hallphase_rd_valid_out,
    volatile_hallphase_wr_req_in,
    volatile_hallphase_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : STATE PORT SIGNAL
    volatile_state_rd_ack_in,
    volatile_state_rd_data_in,
    volatile_state_rd_valid_out,
    volatile_state_wr_req_in,
    volatile_state_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : TEMPERATURE PORT SIGNAL
    volatile_temperature_rd_ack_in,
    volatile_temperature_rd_data_in,
    volatile_temperature_rd_valid_out,
    volatile_temperature_wr_req_in,
    volatile_temperature_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : PDIFF PORT SIGNAL
    volatile_pdiff_rd_ack_in,
    volatile_pdiff_rd_data_in,
    volatile_pdiff_rd_valid_out,
    volatile_pdiff_wr_req_in,
    volatile_pdiff_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : DIFF PORT SIGNAL
    volatile_diff_rd_ack_in,
    volatile_diff_rd_data_in,
    volatile_diff_rd_valid_out,
    volatile_diff_wr_req_in,
    volatile_diff_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : TDIFF PORT SIGNAL
    volatile_tdiff_rd_ack_in,
    volatile_tdiff_rd_data_in,
    volatile_tdiff_rd_valid_out,
    volatile_tdiff_wr_req_in,
    volatile_tdiff_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : OUT PORT SIGNAL
    volatile_out_rd_ack_in,
    volatile_out_rd_data_in,
    volatile_out_rd_valid_out,
    volatile_out_wr_req_in,
    volatile_out_wr_valid_out,
    
    
    // REGISTER(EXTERNAL) : PPEAK PORT SIGNAL
    volatile_ppeak_rd_ack_in,
    volatile_ppeak_rd_data_in,
    volatile_ppeak_rd_valid_out,
    
    
    // REGISTER(EXTERNAL) : PLAST PORT SIGNAL
    volatile_plast_rd_ack_in,
    volatile_plast_rd_data_in,
    volatile_plast_rd_valid_out,
    
    
    // REGISTER(EXTERNAL) : NPEAK PORT SIGNAL
    volatile_npeak_rd_ack_in,
    volatile_npeak_rd_data_in,
    volatile_npeak_rd_valid_out,
    
    
    // REGISTER(EXTERNAL) : STORED_TPO PORT SIGNAL
    volatile_stored_tpo_rd_ack_in,
    volatile_stored_tpo_rd_data_in,
    volatile_stored_tpo_rd_valid_out,
    
    
    // REGISTER : EE_CFG PORT SIGNAL
    volatile_ee_cfg_enb,
    volatile_ee_cfg_ee_erase_in,
    volatile_ee_cfg_ee_erase_in_enb,
    volatile_ee_cfg_ee_erase_r,
    
    volatile_ee_cfg_ee_prog_in,
    volatile_ee_cfg_ee_prog_in_enb,
    volatile_ee_cfg_ee_prog_r,
    
    volatile_ee_cfg_ee_block_mode_in,
    volatile_ee_cfg_ee_block_mode_in_enb,
    volatile_ee_cfg_ee_block_mode_r,
    
    volatile_ee_cfg_ee_vread_r,
    
    volatile_ee_cfg_ee_force_sbe_in,
    volatile_ee_cfg_ee_force_sbe_in_enb,
    volatile_ee_cfg_ee_force_sbe_r,
    
    volatile_ee_cfg_ee_force_dbe_in,
    volatile_ee_cfg_ee_force_dbe_in_enb,
    volatile_ee_cfg_ee_force_dbe_r,
    
    volatile_ee_cfg_ee_dis_ecc_in,
    volatile_ee_cfg_ee_dis_ecc_in_enb,
    volatile_ee_cfg_ee_dis_ecc_r,
    
    volatile_ee_cfg_ee_no_ecc_r,
    
    volatile_ee_cfg_ee_raw_ecc_in,
    volatile_ee_cfg_ee_raw_ecc_in_enb,
    volatile_ee_cfg_ee_raw_ecc_r,
    
    volatile_ee_cfg_ee_en_override_in,
    volatile_ee_cfg_ee_en_override_in_enb,
    volatile_ee_cfg_ee_en_override_r,
    
    volatile_ee_cfg_ee_override_in,
    volatile_ee_cfg_ee_override_in_enb,
    volatile_ee_cfg_ee_override_r,
    
    volatile_ee_cfg_ee_force_reload_in,
    volatile_ee_cfg_ee_force_reload_in_enb,
    volatile_ee_cfg_ee_force_reload_r,
    
    volatile_ee_cfg_ee_noload_in,
    volatile_ee_cfg_ee_noload_in_enb,
    volatile_ee_cfg_ee_noload_r,
    
    volatile_ee_cfg_ee_abort_in,
    volatile_ee_cfg_ee_abort_in_enb,
    volatile_ee_cfg_ee_abort_r,
    
    
    // REGISTER : CP_CFG PORT SIGNAL
    volatile_cp_cfg_enb,
    volatile_cp_cfg_cp_force_en_r,
    
    volatile_cp_cfg_cp_use_dac_r,
    
    volatile_cp_cfg_cp_dac_in,
    volatile_cp_cfg_cp_dac_in_enb,
    volatile_cp_cfg_cp_dac_r,
    
    volatile_cp_cfg_cp_dis_abort_r,
    
    volatile_cp_cfg_cp_err_in,
    volatile_cp_cfg_cp_err_in_enb,
    
    volatile_cp_cfg_cp_cntrl_r,
    
    volatile_cp_cfg_cp_rup_sel_r,
    
    volatile_cp_cfg_cp_hv_sel_r,
    
    volatile_cp_cfg_cp_rdn_sel_r,
    
    
    // REGISTER : EE_STATUS PORT SIGNAL
    volatile_ee_status_enb,
    volatile_ee_status_ee_dbe_flag_in,
    volatile_ee_status_ee_dbe_flag_in_enb,
    volatile_ee_status_ee_dbe_flag_r,
    
    volatile_ee_status_ee_sbe_flag_in,
    volatile_ee_status_ee_sbe_flag_in_enb,
    volatile_ee_status_ee_sbe_flag_r,
    
    volatile_ee_status_ee_err_in,
    volatile_ee_status_ee_err_in_enb,
    
    volatile_ee_status_ee_err_status_in,
    volatile_ee_status_ee_err_status_in_enb,
    
    volatile_ee_status_ee_addr_in,
    volatile_ee_status_ee_addr_in_enb,
    volatile_ee_status_ee_addr_r,
    
    volatile_ee_status_ee_ecc_in,
    volatile_ee_status_ee_ecc_in_enb,
    volatile_ee_status_ee_ecc_r,
    
    
    // REGISTER : EE_DATA PORT SIGNAL
    volatile_ee_data_enb,
    volatile_ee_data_ee_data_in,
    volatile_ee_data_ee_data_in_enb,
    volatile_ee_data_ee_data_r,
    
    
    // REGISTER : PAT_TEST PORT SIGNAL
    volatile_pat_test_enb,
    volatile_pat_test_pat_test_start_in,
    volatile_pat_test_pat_test_start_in_enb,
    volatile_pat_test_pat_test_start_r,
    
    volatile_pat_test_pat_test_status_in,
    volatile_pat_test_pat_test_status_in_enb,
    
    volatile_pat_test_pat_test_pattern_in,
    volatile_pat_test_pat_test_pattern_in_enb,
    volatile_pat_test_pat_test_pattern_r,
    
    
    // REGISTER : MARG_TEST PORT SIGNAL
    volatile_marg_test_enb,
    volatile_marg_test_margin_start_in,
    volatile_marg_test_margin_start_in_enb,
    volatile_marg_test_margin_start_r,
    
    volatile_marg_test_margin_no_max_in,
    volatile_marg_test_margin_no_max_in_enb,
    volatile_marg_test_margin_no_max_r,
    
    volatile_marg_test_margin_no_min_in,
    volatile_marg_test_margin_no_min_in_enb,
    volatile_marg_test_margin_no_min_r,
    
    volatile_marg_test_margin_status_in,
    volatile_marg_test_margin_status_in_enb,
    
    volatile_marg_test_margin_min_max_fail_in,
    volatile_marg_test_margin_min_max_fail_in_enb,
    
    
    // REGISTER : TEST_CFG PORT SIGNAL
    volatile_test_cfg_enb,
    volatile_test_cfg_ee_loop_in,
    volatile_test_cfg_ee_loop_in_enb,
    volatile_test_cfg_ee_loop_r,
    
    volatile_test_cfg_ee_use_test_addr_in,
    volatile_test_cfg_ee_use_test_addr_in_enb,
    volatile_test_cfg_ee_use_test_addr_r,
    
    volatile_test_cfg_ee_test_addr_in,
    volatile_test_cfg_ee_test_addr_in_enb,
    volatile_test_cfg_ee_test_addr_r,
    
    
    // REGISTER : SHADOW_4 PORT SIGNAL
    shadow_shadow_4_enb,
    shadow_shadow_4_rmt_in,
    shadow_shadow_4_rmt_in_enb,
    shadow_shadow_4_rmt_r,
    
    shadow_shadow_4_pol_in,
    shadow_shadow_4_pol_in_enb,
    shadow_shadow_4_pol_r,
    
    shadow_shadow_4_aggr_in,
    shadow_shadow_4_aggr_in_enb,
    shadow_shadow_4_aggr_r,
    
    shadow_shadow_4_teeth_in,
    shadow_shadow_4_teeth_in_enb,
    shadow_shadow_4_teeth_r,
    
    shadow_shadow_4_fact_tpo_in,
    shadow_shadow_4_fact_tpo_in_enb,
    shadow_shadow_4_fact_tpo_r,
    
    shadow_shadow_4_wdog_en_in,
    shadow_shadow_4_wdog_en_in_enb,
    shadow_shadow_4_wdog_en_r,
    
    
    // REGISTER : SHADOW_5 PORT SIGNAL
    shadow_shadow_5_enb,
    shadow_shadow_5_thrr_in,
    shadow_shadow_5_thrr_in_enb,
    shadow_shadow_5_thrr_r,
    
    shadow_shadow_5_thrf_in,
    shadow_shadow_5_thrf_in_enb,
    shadow_shadow_5_thrf_r,
    
    shadow_shadow_5_ffall_in,
    shadow_shadow_5_ffall_in_enb,
    shadow_shadow_5_ffall_r,
    
    shadow_shadow_5_fb_test_in,
    shadow_shadow_5_fb_test_in_enb,
    shadow_shadow_5_fb_test_r,
    
    shadow_shadow_5_dem_test_in,
    shadow_shadow_5_dem_test_in_enb,
    shadow_shadow_5_dem_test_r,
    
    shadow_shadow_5_fe_cal_dis_in,
    shadow_shadow_5_fe_cal_dis_in_enb,
    shadow_shadow_5_fe_cal_dis_r,
    
    shadow_shadow_5_variable_chop_in,
    shadow_shadow_5_variable_chop_in_enb,
    shadow_shadow_5_variable_chop_r,
    
    shadow_shadow_5_adc_filter_sel_in,
    shadow_shadow_5_adc_filter_sel_in_enb,
    shadow_shadow_5_adc_filter_sel_r,
    
    shadow_shadow_5_tpoself_dis_in,
    shadow_shadow_5_tpoself_dis_in_enb,
    shadow_shadow_5_tpoself_dis_r,
    
    shadow_shadow_5_tpoself_lvl_in,
    shadow_shadow_5_tpoself_lvl_in_enb,
    shadow_shadow_5_tpoself_lvl_r,
    
    shadow_shadow_5_temp_comp_in,
    shadow_shadow_5_temp_comp_in_enb,
    shadow_shadow_5_temp_comp_r,
    
    
    // REGISTER : SHADOW_6 PORT SIGNAL
    shadow_shadow_6_enb,
    shadow_shadow_6_diff_baseline_40_in,
    shadow_shadow_6_diff_baseline_40_in_enb,
    shadow_shadow_6_diff_baseline_40_r,
    
    shadow_shadow_6_diff_tpo_40_in,
    shadow_shadow_6_diff_tpo_40_in_enb,
    shadow_shadow_6_diff_tpo_40_r,
    
    
    // REGISTER : SHADOW_7 PORT SIGNAL
    shadow_shadow_7_enb,
    shadow_shadow_7_diff_baseline_25_in,
    shadow_shadow_7_diff_baseline_25_in_enb,
    shadow_shadow_7_diff_baseline_25_r,
    
    shadow_shadow_7_diff_tpo_25_in,
    shadow_shadow_7_diff_tpo_25_in_enb,
    shadow_shadow_7_diff_tpo_25_r,
    
    
    // REGISTER : SHADOW_8 PORT SIGNAL
    shadow_shadow_8_enb,
    shadow_shadow_8_diff_baseline_165_in,
    shadow_shadow_8_diff_baseline_165_in_enb,
    shadow_shadow_8_diff_baseline_165_r,
    
    shadow_shadow_8_diff_tpo_165_in,
    shadow_shadow_8_diff_tpo_165_in_enb,
    shadow_shadow_8_diff_tpo_165_r,
    
    
    // REGISTER : SHADOW_9 PORT SIGNAL
    shadow_shadow_9_enb,
    shadow_shadow_9_halltrim_in,
    shadow_shadow_9_halltrim_in_enb,
    shadow_shadow_9_halltrim_r,
    
    shadow_shadow_9_osc_trim_in,
    shadow_shadow_9_osc_trim_in_enb,
    shadow_shadow_9_osc_trim_r,
    
    shadow_shadow_9_ref_bg_trim_in,
    shadow_shadow_9_ref_bg_trim_in_enb,
    shadow_shadow_9_ref_bg_trim_r,
    
    shadow_shadow_9_out_fastfall_in,
    shadow_shadow_9_out_fastfall_in_enb,
    shadow_shadow_9_out_fastfall_r,
    
    
    // REGISTER : SHADOW_A PORT SIGNAL
    shadow_shadow_a_enb,
    shadow_shadow_a_lock_t_in,
    shadow_shadow_a_lock_t_in_enb,
    shadow_shadow_a_lock_t_r,
    
    shadow_shadow_a_lock_a_in,
    shadow_shadow_a_lock_a_in_enb,
    shadow_shadow_a_lock_a_r,
    
    shadow_shadow_a_lock_c_in,
    shadow_shadow_a_lock_c_in_enb,
    shadow_shadow_a_lock_c_r,
    
    shadow_shadow_a_lock_o_in,
    shadow_shadow_a_lock_o_in_enb,
    shadow_shadow_a_lock_o_r,
    
    shadow_shadow_a_lock_s_in,
    shadow_shadow_a_lock_s_in_enb,
    shadow_shadow_a_lock_s_r,
    
    shadow_shadow_a_lock_bd_in,
    shadow_shadow_a_lock_bd_in_enb,
    shadow_shadow_a_lock_bd_r,
    
    
    // SECTION(EXTERNAL) : EEPROM PORT SIGNAL
    eeprom_rd_ack_in,
    eeprom_rd_data_in,
    eeprom_rd_valid_out,
    eeprom_wr_req_in,
    eeprom_wr_valid_out,
    
    
    address_out,
    wr_data_out,
    
    
    
    //CUSTOM signals
    clk,   // Bus clock
    reset_l,   // Reset
    rd_stb,   // Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    rd_wait,   // Read wait
    wr_stb,   // Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    address,   // Address for write/read
    wr_data,   // Write data
    bitenable,   // Specify which bytes are being written or during read which bytes the master is reading
    request,   // Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    rd_data_vld,   // Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    rd_data   // Read data
    );
    //  PARAMETERS
    parameter bus_width   = 32;
    parameter addr_width = 9;
    
    parameter block_offset  = {(addr_width){1'b0}};
    
    // SECTION : VOLATILE
    parameter volatile_address_width = addr_width;
    
    // SECTION : SHADOW
    parameter shadow_address_width = addr_width;
    
    // SECTION : EEPROM
    parameter eeprom_address_width = addr_width - 6;
    
    
    parameter reg_map_address_width = addr_width;
    //-----------------------------------------------------
    // REGISTER : STATUS0 SIGNALS
    
    
    wire    volatile_status0_decode;         // DECODE
    wire    [bus_width-1 : 0] volatile_status0_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_status0_offset;  // OFFSET
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    
    // BUFFER SIGNAL FOR EACH FIELD
    wire  [3 : 0] volatile_status0_dsc_major_q ;      // FIELD : DSC_MAJOR
    wire  [3 : 0] volatile_status0_dsc_minor_q ;      // FIELD : DSC_MINOR
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [3 : 0] volatile_status0_dsc_major_r ;      // FIELD : DSC_MAJOR
    output   [3 : 0] volatile_status0_dsc_minor_r ;      // FIELD : DSC_MINOR
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [3 : 0] volatile_status0_dsc_major_in ;      // FIELD : DSC_MAJOR
    
    input    [3 : 0] volatile_status0_dsc_minor_in ;      // FIELD : DSC_MINOR
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : CFG0 SIGNALS
    
    
    wire    volatile_cfg0_decode;         // DECODE
    wire    volatile_cfg0_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_cfg0_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_cfg0_offset;  // OFFSET
    output  volatile_cfg0_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_cfg0_outmode_in_enb         ;      // FIELD : OUTMODE
    input   volatile_cfg0_pdiff_we_in_enb        ;      // FIELD : PDIFF_WE
    input   volatile_cfg0_diff_we_in_enb         ;      // FIELD : DIFF_WE
    input   volatile_cfg0_tdiff_we_in_enb        ;      // FIELD : TDIFF_WE
    input   volatile_cfg0_hallphase_we_in_enb    ;      // FIELD : HALLPHASE_WE
    input   volatile_cfg0_state_we_in_enb        ;      // FIELD : STATE_WE
    input   volatile_cfg0_temperature_we_in_enb  ;      // FIELD : TEMPERATURE_WE
    input   volatile_cfg0_out_we_in_enb          ;      // FIELD : OUT_WE
    input   volatile_cfg0_samp_dis_in_enb        ;      // FIELD : SAMP_DIS
    input   volatile_cfg0_conv_dis_in_enb        ;      // FIELD : CONV_DIS
    input   volatile_cfg0_eforce_mode_in_enb     ;      // FIELD : EFORCE_MODE
    input   volatile_cfg0_force_hallshort_in_enb ;      // FIELD : FORCE_HALLSHORT
    input   volatile_cfg0_out_risetime_in_enb    ;      // FIELD : OUT_RISETIME
    input   volatile_cfg0_force_timeout_in_enb   ;      // FIELD : FORCE_TIMEOUT
    input   volatile_cfg0_tpo_auto_update_in_enb ;      // FIELD : TPO_AUTO_UPDATE
    input   volatile_cfg0_force_tpo_in_enb       ;      // FIELD : FORCE_TPO
    input   volatile_cfg0_cpump_load_in_enb      ;      // FIELD : CPUMP_LOAD
    input   volatile_cfg0_out_prog_en_in_enb     ;      // FIELD : OUT_PROG_EN
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_cfg0_outmode_q         ;      // FIELD : OUTMODE
    reg          volatile_cfg0_pdiff_we_q        ;      // FIELD : PDIFF_WE
    reg          volatile_cfg0_diff_we_q         ;      // FIELD : DIFF_WE
    reg          volatile_cfg0_tdiff_we_q        ;      // FIELD : TDIFF_WE
    reg          volatile_cfg0_hallphase_we_q    ;      // FIELD : HALLPHASE_WE
    reg          volatile_cfg0_state_we_q        ;      // FIELD : STATE_WE
    reg          volatile_cfg0_temperature_we_q  ;      // FIELD : TEMPERATURE_WE
    reg          volatile_cfg0_out_we_q          ;      // FIELD : OUT_WE
    reg          volatile_cfg0_samp_dis_q        ;      // FIELD : SAMP_DIS
    reg          volatile_cfg0_conv_dis_q        ;      // FIELD : CONV_DIS
    reg  [1 : 0] volatile_cfg0_eforce_mode_q     ;      // FIELD : EFORCE_MODE
    reg          volatile_cfg0_force_hallshort_q ;      // FIELD : FORCE_HALLSHORT
    reg          volatile_cfg0_out_risetime_q    ;      // FIELD : OUT_RISETIME
    reg          volatile_cfg0_force_timeout_q   ;      // FIELD : FORCE_TIMEOUT
    reg          volatile_cfg0_tpo_auto_update_q ;      // FIELD : TPO_AUTO_UPDATE
    reg          volatile_cfg0_force_tpo_q       ;      // FIELD : FORCE_TPO
    reg          volatile_cfg0_cpump_load_q      ;      // FIELD : CPUMP_LOAD
    reg          volatile_cfg0_out_prog_en_q     ;      // FIELD : OUT_PROG_EN
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_cfg0_outmode_r         ;      // FIELD : OUTMODE
    output           volatile_cfg0_pdiff_we_r        ;      // FIELD : PDIFF_WE
    output           volatile_cfg0_diff_we_r         ;      // FIELD : DIFF_WE
    output           volatile_cfg0_tdiff_we_r        ;      // FIELD : TDIFF_WE
    output           volatile_cfg0_hallphase_we_r    ;      // FIELD : HALLPHASE_WE
    output           volatile_cfg0_state_we_r        ;      // FIELD : STATE_WE
    output           volatile_cfg0_temperature_we_r  ;      // FIELD : TEMPERATURE_WE
    output           volatile_cfg0_out_we_r          ;      // FIELD : OUT_WE
    output           volatile_cfg0_samp_dis_r        ;      // FIELD : SAMP_DIS
    output           volatile_cfg0_conv_dis_r        ;      // FIELD : CONV_DIS
    output   [1 : 0] volatile_cfg0_eforce_mode_r     ;      // FIELD : EFORCE_MODE
    output           volatile_cfg0_force_hallshort_r ;      // FIELD : FORCE_HALLSHORT
    output           volatile_cfg0_out_risetime_r    ;      // FIELD : OUT_RISETIME
    output           volatile_cfg0_force_timeout_r   ;      // FIELD : FORCE_TIMEOUT
    output           volatile_cfg0_tpo_auto_update_r ;      // FIELD : TPO_AUTO_UPDATE
    output           volatile_cfg0_force_tpo_r       ;      // FIELD : FORCE_TPO
    output           volatile_cfg0_cpump_load_r      ;      // FIELD : CPUMP_LOAD
    output           volatile_cfg0_out_prog_en_r     ;      // FIELD : OUT_PROG_EN
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_cfg0_outmode_in         ;      // FIELD : OUTMODE
    
    input            volatile_cfg0_pdiff_we_in        ;      // FIELD : PDIFF_WE
    
    input            volatile_cfg0_diff_we_in         ;      // FIELD : DIFF_WE
    
    input            volatile_cfg0_tdiff_we_in        ;      // FIELD : TDIFF_WE
    
    input            volatile_cfg0_hallphase_we_in    ;      // FIELD : HALLPHASE_WE
    
    input            volatile_cfg0_state_we_in        ;      // FIELD : STATE_WE
    
    input            volatile_cfg0_temperature_we_in  ;      // FIELD : TEMPERATURE_WE
    
    input            volatile_cfg0_out_we_in          ;      // FIELD : OUT_WE
    
    input            volatile_cfg0_samp_dis_in        ;      // FIELD : SAMP_DIS
    
    input            volatile_cfg0_conv_dis_in        ;      // FIELD : CONV_DIS
    
    input    [1 : 0] volatile_cfg0_eforce_mode_in     ;      // FIELD : EFORCE_MODE
    
    input            volatile_cfg0_force_hallshort_in ;      // FIELD : FORCE_HALLSHORT
    
    input            volatile_cfg0_out_risetime_in    ;      // FIELD : OUT_RISETIME
    
    input            volatile_cfg0_force_timeout_in   ;      // FIELD : FORCE_TIMEOUT
    
    input            volatile_cfg0_tpo_auto_update_in ;      // FIELD : TPO_AUTO_UPDATE
    
    input            volatile_cfg0_force_tpo_in       ;      // FIELD : FORCE_TPO
    
    input            volatile_cfg0_cpump_load_in      ;      // FIELD : CPUMP_LOAD
    
    input            volatile_cfg0_out_prog_en_in     ;      // FIELD : OUT_PROG_EN
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : CFG1 SIGNALS
    
    
    wire    volatile_cfg1_decode;         // DECODE
    wire    volatile_cfg1_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_cfg1_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_cfg1_offset;  // OFFSET
    output  volatile_cfg1_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_cfg1_eol_diag_en_in_enb ;      // FIELD : EOL_DIAG_EN
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg volatile_cfg1_eol_diag_en_q ;      // FIELD : EOL_DIAG_EN
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  volatile_cfg1_eol_diag_en_r ;      // FIELD : EOL_DIAG_EN
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   volatile_cfg1_eol_diag_en_in ;      // FIELD : EOL_DIAG_EN
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : CFG2 SIGNALS
    
    
    wire    volatile_cfg2_decode;         // DECODE
    wire    volatile_cfg2_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_cfg2_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_cfg2_offset;  // OFFSET
    output  volatile_cfg2_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_cfg2_adc_test_start_in_enb   ;      // FIELD : ADC_TEST_START
    input   volatile_cfg2_auto_hall_start_in_enb  ;      // FIELD : AUTO_HALL_START
    input   volatile_cfg2_auto_hall_target_in_enb ;      // FIELD : AUTO_HALL_TARGET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_cfg2_adc_test_start_q   ;      // FIELD : ADC_TEST_START
    reg          volatile_cfg2_auto_hall_start_q  ;      // FIELD : AUTO_HALL_START
    reg  [6 : 0] volatile_cfg2_auto_hall_target_q ;      // FIELD : AUTO_HALL_TARGET
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_cfg2_adc_test_start_r   ;      // FIELD : ADC_TEST_START
    output           volatile_cfg2_auto_hall_start_r  ;      // FIELD : AUTO_HALL_START
    output   [6 : 0] volatile_cfg2_auto_hall_target_r ;      // FIELD : AUTO_HALL_TARGET
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_cfg2_adc_test_start_in   ;      // FIELD : ADC_TEST_START
    
    input            volatile_cfg2_auto_hall_start_in  ;      // FIELD : AUTO_HALL_START
    
    input    [6 : 0] volatile_cfg2_auto_hall_target_in ;      // FIELD : AUTO_HALL_TARGET
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : TEST_RESULT SIGNALS
    input   volatile_test_result_rd_ack_in;
    input  [bus_width-1 : 0] volatile_test_result_rd_data_in;
    output  volatile_test_result_rd_valid_out;
    wire    volatile_test_result_decode;
    wire    [64-1 : 0] volatile_test_result_offset;
    wire    volatile_test_result_rd_valid;
    wire     volatile_test_result_rd_ack_wire;
    wire     volatile_test_result_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_test_result_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : HALLPHASE SIGNALS
    input   volatile_hallphase_rd_ack_in;
    input  [bus_width-1 : 0] volatile_hallphase_rd_data_in;
    output  volatile_hallphase_rd_valid_out;
    input   volatile_hallphase_wr_req_in;
    output  volatile_hallphase_wr_valid_out;
    wire    volatile_hallphase_decode;
    wire    [64-1 : 0] volatile_hallphase_offset;
    wire    volatile_hallphase_rd_valid;
    wire    volatile_hallphase_wr_valid;
    wire     volatile_hallphase_wr_req_wire;
    wire     volatile_hallphase_rd_ack_wire;
    wire     volatile_hallphase_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_hallphase_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : STATE SIGNALS
    input   volatile_state_rd_ack_in;
    input  [bus_width-1 : 0] volatile_state_rd_data_in;
    output  volatile_state_rd_valid_out;
    input   volatile_state_wr_req_in;
    output  volatile_state_wr_valid_out;
    wire    volatile_state_decode;
    wire    [64-1 : 0] volatile_state_offset;
    wire    volatile_state_rd_valid;
    wire    volatile_state_wr_valid;
    wire     volatile_state_wr_req_wire;
    wire     volatile_state_rd_ack_wire;
    wire     volatile_state_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_state_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : TEMPERATURE SIGNALS
    input   volatile_temperature_rd_ack_in;
    input  [bus_width-1 : 0] volatile_temperature_rd_data_in;
    output  volatile_temperature_rd_valid_out;
    input   volatile_temperature_wr_req_in;
    output  volatile_temperature_wr_valid_out;
    wire    volatile_temperature_decode;
    wire    [64-1 : 0] volatile_temperature_offset;
    wire    volatile_temperature_rd_valid;
    wire    volatile_temperature_wr_valid;
    wire     volatile_temperature_wr_req_wire;
    wire     volatile_temperature_rd_ack_wire;
    wire     volatile_temperature_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_temperature_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : PDIFF SIGNALS
    input   volatile_pdiff_rd_ack_in;
    input  [bus_width-1 : 0] volatile_pdiff_rd_data_in;
    output  volatile_pdiff_rd_valid_out;
    input   volatile_pdiff_wr_req_in;
    output  volatile_pdiff_wr_valid_out;
    wire    volatile_pdiff_decode;
    wire    [64-1 : 0] volatile_pdiff_offset;
    wire    volatile_pdiff_rd_valid;
    wire    volatile_pdiff_wr_valid;
    wire     volatile_pdiff_wr_req_wire;
    wire     volatile_pdiff_rd_ack_wire;
    wire     volatile_pdiff_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_pdiff_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : DIFF SIGNALS
    input   volatile_diff_rd_ack_in;
    input  [bus_width-1 : 0] volatile_diff_rd_data_in;
    output  volatile_diff_rd_valid_out;
    input   volatile_diff_wr_req_in;
    output  volatile_diff_wr_valid_out;
    wire    volatile_diff_decode;
    wire    [64-1 : 0] volatile_diff_offset;
    wire    volatile_diff_rd_valid;
    wire    volatile_diff_wr_valid;
    wire     volatile_diff_wr_req_wire;
    wire     volatile_diff_rd_ack_wire;
    wire     volatile_diff_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_diff_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : TDIFF SIGNALS
    input   volatile_tdiff_rd_ack_in;
    input  [bus_width-1 : 0] volatile_tdiff_rd_data_in;
    output  volatile_tdiff_rd_valid_out;
    input   volatile_tdiff_wr_req_in;
    output  volatile_tdiff_wr_valid_out;
    wire    volatile_tdiff_decode;
    wire    [64-1 : 0] volatile_tdiff_offset;
    wire    volatile_tdiff_rd_valid;
    wire    volatile_tdiff_wr_valid;
    wire     volatile_tdiff_wr_req_wire;
    wire     volatile_tdiff_rd_ack_wire;
    wire     volatile_tdiff_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_tdiff_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : OUT SIGNALS
    input   volatile_out_rd_ack_in;
    input  [bus_width-1 : 0] volatile_out_rd_data_in;
    output  volatile_out_rd_valid_out;
    input   volatile_out_wr_req_in;
    output  volatile_out_wr_valid_out;
    wire    volatile_out_decode;
    wire    [64-1 : 0] volatile_out_offset;
    wire    volatile_out_rd_valid;
    wire    volatile_out_wr_valid;
    wire     volatile_out_wr_req_wire;
    wire     volatile_out_rd_ack_wire;
    wire     volatile_out_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_out_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : PPEAK SIGNALS
    input   volatile_ppeak_rd_ack_in;
    input  [bus_width-1 : 0] volatile_ppeak_rd_data_in;
    output  volatile_ppeak_rd_valid_out;
    wire    volatile_ppeak_decode;
    wire    [64-1 : 0] volatile_ppeak_offset;
    wire    volatile_ppeak_rd_valid;
    wire     volatile_ppeak_rd_ack_wire;
    wire     volatile_ppeak_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_ppeak_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : PLAST SIGNALS
    input   volatile_plast_rd_ack_in;
    input  [bus_width-1 : 0] volatile_plast_rd_data_in;
    output  volatile_plast_rd_valid_out;
    wire    volatile_plast_decode;
    wire    [64-1 : 0] volatile_plast_offset;
    wire    volatile_plast_rd_valid;
    wire     volatile_plast_rd_ack_wire;
    wire     volatile_plast_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_plast_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : NPEAK SIGNALS
    input   volatile_npeak_rd_ack_in;
    input  [bus_width-1 : 0] volatile_npeak_rd_data_in;
    output  volatile_npeak_rd_valid_out;
    wire    volatile_npeak_decode;
    wire    [64-1 : 0] volatile_npeak_offset;
    wire    volatile_npeak_rd_valid;
    wire     volatile_npeak_rd_ack_wire;
    wire     volatile_npeak_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_npeak_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : STORED_TPO SIGNALS
    input   volatile_stored_tpo_rd_ack_in;
    input  [bus_width-1 : 0] volatile_stored_tpo_rd_data_in;
    output  volatile_stored_tpo_rd_valid_out;
    wire    volatile_stored_tpo_decode;
    wire    [64-1 : 0] volatile_stored_tpo_offset;
    wire    volatile_stored_tpo_rd_valid;
    wire     volatile_stored_tpo_rd_ack_wire;
    wire     volatile_stored_tpo_decode_wire;
    
    wire    [bus_width-1 : 0] volatile_stored_tpo_rd_data;
    
    //-----------------------------------------------------
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : EE_CFG SIGNALS
    
    
    wire    volatile_ee_cfg_decode;         // DECODE
    wire    volatile_ee_cfg_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_ee_cfg_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_ee_cfg_offset;  // OFFSET
    output  volatile_ee_cfg_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_ee_cfg_ee_erase_in_enb        ;      // FIELD : EE_ERASE
    input   volatile_ee_cfg_ee_prog_in_enb         ;      // FIELD : EE_PROG
    input   volatile_ee_cfg_ee_block_mode_in_enb   ;      // FIELD : EE_BLOCK_MODE
    input   volatile_ee_cfg_ee_force_sbe_in_enb    ;      // FIELD : EE_FORCE_SBE
    input   volatile_ee_cfg_ee_force_dbe_in_enb    ;      // FIELD : EE_FORCE_DBE
    input   volatile_ee_cfg_ee_dis_ecc_in_enb      ;      // FIELD : EE_DIS_ECC
    input   volatile_ee_cfg_ee_raw_ecc_in_enb      ;      // FIELD : EE_RAW_ECC
    input   volatile_ee_cfg_ee_en_override_in_enb  ;      // FIELD : EE_EN_OVERRIDE
    input   volatile_ee_cfg_ee_override_in_enb     ;      // FIELD : EE_OVERRIDE
    input   volatile_ee_cfg_ee_force_reload_in_enb ;      // FIELD : EE_FORCE_RELOAD
    input   volatile_ee_cfg_ee_noload_in_enb       ;      // FIELD : EE_NOLOAD
    input   volatile_ee_cfg_ee_abort_in_enb        ;      // FIELD : EE_ABORT
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_ee_cfg_ee_erase_q        ;      // FIELD : EE_ERASE
    reg          volatile_ee_cfg_ee_prog_q         ;      // FIELD : EE_PROG
    reg  [1 : 0] volatile_ee_cfg_ee_block_mode_q   ;      // FIELD : EE_BLOCK_MODE
    reg  [2 : 0] volatile_ee_cfg_ee_vread_q        ;      // FIELD : EE_VREAD
    reg          volatile_ee_cfg_ee_force_sbe_q    ;      // FIELD : EE_FORCE_SBE
    reg          volatile_ee_cfg_ee_force_dbe_q    ;      // FIELD : EE_FORCE_DBE
    reg          volatile_ee_cfg_ee_dis_ecc_q      ;      // FIELD : EE_DIS_ECC
    reg          volatile_ee_cfg_ee_no_ecc_q       ;      // FIELD : EE_NO_ECC
    reg          volatile_ee_cfg_ee_raw_ecc_q      ;      // FIELD : EE_RAW_ECC
    reg          volatile_ee_cfg_ee_en_override_q  ;      // FIELD : EE_EN_OVERRIDE
    reg  [1 : 0] volatile_ee_cfg_ee_override_q     ;      // FIELD : EE_OVERRIDE
    reg          volatile_ee_cfg_ee_force_reload_q ;      // FIELD : EE_FORCE_RELOAD
    reg          volatile_ee_cfg_ee_noload_q       ;      // FIELD : EE_NOLOAD
    reg          volatile_ee_cfg_ee_abort_q        ;      // FIELD : EE_ABORT
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_ee_cfg_ee_erase_r        ;      // FIELD : EE_ERASE
    output           volatile_ee_cfg_ee_prog_r         ;      // FIELD : EE_PROG
    output   [1 : 0] volatile_ee_cfg_ee_block_mode_r   ;      // FIELD : EE_BLOCK_MODE
    output   [2 : 0] volatile_ee_cfg_ee_vread_r        ;      // FIELD : EE_VREAD
    output           volatile_ee_cfg_ee_force_sbe_r    ;      // FIELD : EE_FORCE_SBE
    output           volatile_ee_cfg_ee_force_dbe_r    ;      // FIELD : EE_FORCE_DBE
    output           volatile_ee_cfg_ee_dis_ecc_r      ;      // FIELD : EE_DIS_ECC
    output           volatile_ee_cfg_ee_no_ecc_r       ;      // FIELD : EE_NO_ECC
    output           volatile_ee_cfg_ee_raw_ecc_r      ;      // FIELD : EE_RAW_ECC
    output           volatile_ee_cfg_ee_en_override_r  ;      // FIELD : EE_EN_OVERRIDE
    output   [1 : 0] volatile_ee_cfg_ee_override_r     ;      // FIELD : EE_OVERRIDE
    output           volatile_ee_cfg_ee_force_reload_r ;      // FIELD : EE_FORCE_RELOAD
    output           volatile_ee_cfg_ee_noload_r       ;      // FIELD : EE_NOLOAD
    output           volatile_ee_cfg_ee_abort_r        ;      // FIELD : EE_ABORT
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_ee_cfg_ee_erase_in        ;      // FIELD : EE_ERASE
    
    input            volatile_ee_cfg_ee_prog_in         ;      // FIELD : EE_PROG
    
    input    [1 : 0] volatile_ee_cfg_ee_block_mode_in   ;      // FIELD : EE_BLOCK_MODE
    
    input            volatile_ee_cfg_ee_force_sbe_in    ;      // FIELD : EE_FORCE_SBE
    
    input            volatile_ee_cfg_ee_force_dbe_in    ;      // FIELD : EE_FORCE_DBE
    
    input            volatile_ee_cfg_ee_dis_ecc_in      ;      // FIELD : EE_DIS_ECC
    
    input            volatile_ee_cfg_ee_raw_ecc_in      ;      // FIELD : EE_RAW_ECC
    
    input            volatile_ee_cfg_ee_en_override_in  ;      // FIELD : EE_EN_OVERRIDE
    
    input    [1 : 0] volatile_ee_cfg_ee_override_in     ;      // FIELD : EE_OVERRIDE
    
    input            volatile_ee_cfg_ee_force_reload_in ;      // FIELD : EE_FORCE_RELOAD
    
    input            volatile_ee_cfg_ee_noload_in       ;      // FIELD : EE_NOLOAD
    
    input            volatile_ee_cfg_ee_abort_in        ;      // FIELD : EE_ABORT
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : CP_CFG SIGNALS
    
    
    wire    volatile_cp_cfg_decode;         // DECODE
    wire    volatile_cp_cfg_wr_valid;       // WRITE VALID
    wire    volatile_cp_cfg_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] volatile_cp_cfg_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_cp_cfg_offset;  // OFFSET
    output  volatile_cp_cfg_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_cp_cfg_cp_dac_in_enb ;      // FIELD : CP_DAC
    input   volatile_cp_cfg_cp_err_in_enb ;      // FIELD : CP_ERR
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_cp_cfg_cp_force_en_q  ;      // FIELD : CP_FORCE_EN
    reg          volatile_cp_cfg_cp_use_dac_q   ;      // FIELD : CP_USE_DAC
    reg  [5 : 0] volatile_cp_cfg_cp_dac_q       ;      // FIELD : CP_DAC
    reg          volatile_cp_cfg_cp_dis_abort_q ;      // FIELD : CP_DIS_ABORT
    reg          volatile_cp_cfg_cp_err_q       ;      // FIELD : CP_ERR
    reg  [1 : 0] volatile_cp_cfg_cp_cntrl_q     ;      // FIELD : CP_CNTRL
    reg  [1 : 0] volatile_cp_cfg_cp_rup_sel_q   ;      // FIELD : CP_RUP_SEL
    reg  [1 : 0] volatile_cp_cfg_cp_hv_sel_q    ;      // FIELD : CP_HV_SEL
    reg  [1 : 0] volatile_cp_cfg_cp_rdn_sel_q   ;      // FIELD : CP_RDN_SEL
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_cp_cfg_cp_force_en_r  ;      // FIELD : CP_FORCE_EN
    output           volatile_cp_cfg_cp_use_dac_r   ;      // FIELD : CP_USE_DAC
    output   [5 : 0] volatile_cp_cfg_cp_dac_r       ;      // FIELD : CP_DAC
    output           volatile_cp_cfg_cp_dis_abort_r ;      // FIELD : CP_DIS_ABORT
    output   [1 : 0] volatile_cp_cfg_cp_cntrl_r     ;      // FIELD : CP_CNTRL
    output   [1 : 0] volatile_cp_cfg_cp_rup_sel_r   ;      // FIELD : CP_RUP_SEL
    output   [1 : 0] volatile_cp_cfg_cp_hv_sel_r    ;      // FIELD : CP_HV_SEL
    output   [1 : 0] volatile_cp_cfg_cp_rdn_sel_r   ;      // FIELD : CP_RDN_SEL
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [5 : 0] volatile_cp_cfg_cp_dac_in ;      // FIELD : CP_DAC
    
    input            volatile_cp_cfg_cp_err_in ;      // FIELD : CP_ERR
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : EE_STATUS SIGNALS
    
    
    wire    volatile_ee_status_decode;         // DECODE
    wire    volatile_ee_status_wr_valid;       // WRITE VALID
    wire    volatile_ee_status_rd_valid;       // READ VALID
    wire    [bus_width-1 : 0] volatile_ee_status_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_ee_status_offset;  // OFFSET
    output  volatile_ee_status_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_ee_status_ee_dbe_flag_in_enb   ;      // FIELD : EE_DBE_FLAG
    input   volatile_ee_status_ee_sbe_flag_in_enb   ;      // FIELD : EE_SBE_FLAG
    input   volatile_ee_status_ee_err_in_enb        ;      // FIELD : EE_ERR
    input   volatile_ee_status_ee_err_status_in_enb ;      // FIELD : EE_ERR_STATUS
    input   volatile_ee_status_ee_addr_in_enb       ;      // FIELD : EE_ADDR
    input   volatile_ee_status_ee_ecc_in_enb        ;      // FIELD : EE_ECC
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_ee_status_ee_dbe_flag_q   ;      // FIELD : EE_DBE_FLAG
    reg          volatile_ee_status_ee_sbe_flag_q   ;      // FIELD : EE_SBE_FLAG
    reg          volatile_ee_status_ee_err_q        ;      // FIELD : EE_ERR
    reg  [4 : 0] volatile_ee_status_ee_err_status_q ;      // FIELD : EE_ERR_STATUS
    reg  [3 : 0] volatile_ee_status_ee_addr_q       ;      // FIELD : EE_ADDR
    reg  [5 : 0] volatile_ee_status_ee_ecc_q        ;      // FIELD : EE_ECC
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_ee_status_ee_dbe_flag_r ;      // FIELD : EE_DBE_FLAG
    output           volatile_ee_status_ee_sbe_flag_r ;      // FIELD : EE_SBE_FLAG
    output   [3 : 0] volatile_ee_status_ee_addr_r     ;      // FIELD : EE_ADDR
    output   [5 : 0] volatile_ee_status_ee_ecc_r      ;      // FIELD : EE_ECC
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_ee_status_ee_dbe_flag_in   ;      // FIELD : EE_DBE_FLAG
    
    input            volatile_ee_status_ee_sbe_flag_in   ;      // FIELD : EE_SBE_FLAG
    
    input            volatile_ee_status_ee_err_in        ;      // FIELD : EE_ERR
    
    input    [4 : 0] volatile_ee_status_ee_err_status_in ;      // FIELD : EE_ERR_STATUS
    
    input    [3 : 0] volatile_ee_status_ee_addr_in       ;      // FIELD : EE_ADDR
    
    input    [5 : 0] volatile_ee_status_ee_ecc_in        ;      // FIELD : EE_ECC
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : EE_DATA SIGNALS
    
    
    wire    volatile_ee_data_decode;         // DECODE
    wire    volatile_ee_data_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_ee_data_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_ee_data_offset;  // OFFSET
    output  volatile_ee_data_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_ee_data_ee_data_in_enb ;      // FIELD : EE_DATA
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [25 : 0] volatile_ee_data_ee_data_q ;      // FIELD : EE_DATA
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [25 : 0] volatile_ee_data_ee_data_r ;      // FIELD : EE_DATA
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [25 : 0] volatile_ee_data_ee_data_in ;      // FIELD : EE_DATA
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : PAT_TEST SIGNALS
    
    
    wire    volatile_pat_test_decode;         // DECODE
    wire    volatile_pat_test_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_pat_test_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_pat_test_offset;  // OFFSET
    output  volatile_pat_test_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_pat_test_pat_test_start_in_enb   ;      // FIELD : PAT_TEST_START
    input   volatile_pat_test_pat_test_status_in_enb  ;      // FIELD : PAT_TEST_STATUS
    input   volatile_pat_test_pat_test_pattern_in_enb ;      // FIELD : PAT_TEST_PATTERN
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_pat_test_pat_test_start_q   ;      // FIELD : PAT_TEST_START
    reg  [1 : 0] volatile_pat_test_pat_test_status_q  ;      // FIELD : PAT_TEST_STATUS
    reg  [1 : 0] volatile_pat_test_pat_test_pattern_q ;      // FIELD : PAT_TEST_PATTERN
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_pat_test_pat_test_start_r   ;      // FIELD : PAT_TEST_START
    output   [1 : 0] volatile_pat_test_pat_test_pattern_r ;      // FIELD : PAT_TEST_PATTERN
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_pat_test_pat_test_start_in   ;      // FIELD : PAT_TEST_START
    
    input    [1 : 0] volatile_pat_test_pat_test_status_in  ;      // FIELD : PAT_TEST_STATUS
    
    input    [1 : 0] volatile_pat_test_pat_test_pattern_in ;      // FIELD : PAT_TEST_PATTERN
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : MARG_TEST SIGNALS
    
    
    wire    volatile_marg_test_decode;         // DECODE
    wire    volatile_marg_test_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_marg_test_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_marg_test_offset;  // OFFSET
    output  volatile_marg_test_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_marg_test_margin_start_in_enb        ;      // FIELD : MARGIN_START
    input   volatile_marg_test_margin_no_max_in_enb       ;      // FIELD : MARGIN_NO_MAX
    input   volatile_marg_test_margin_no_min_in_enb       ;      // FIELD : MARGIN_NO_MIN
    input   volatile_marg_test_margin_status_in_enb       ;      // FIELD : MARGIN_STATUS
    input   volatile_marg_test_margin_min_max_fail_in_enb ;      // FIELD : MARGIN_MIN_MAX_FAIL
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_marg_test_margin_start_q        ;      // FIELD : MARGIN_START
    reg          volatile_marg_test_margin_no_max_q       ;      // FIELD : MARGIN_NO_MAX
    reg          volatile_marg_test_margin_no_min_q       ;      // FIELD : MARGIN_NO_MIN
    reg  [1 : 0] volatile_marg_test_margin_status_q       ;      // FIELD : MARGIN_STATUS
    reg          volatile_marg_test_margin_min_max_fail_q ;      // FIELD : MARGIN_MIN_MAX_FAIL
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_marg_test_margin_start_r  ;      // FIELD : MARGIN_START
    output           volatile_marg_test_margin_no_max_r ;      // FIELD : MARGIN_NO_MAX
    output           volatile_marg_test_margin_no_min_r ;      // FIELD : MARGIN_NO_MIN
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_marg_test_margin_start_in        ;      // FIELD : MARGIN_START
    
    input            volatile_marg_test_margin_no_max_in       ;      // FIELD : MARGIN_NO_MAX
    
    input            volatile_marg_test_margin_no_min_in       ;      // FIELD : MARGIN_NO_MIN
    
    input    [1 : 0] volatile_marg_test_margin_status_in       ;      // FIELD : MARGIN_STATUS
    
    input            volatile_marg_test_margin_min_max_fail_in ;      // FIELD : MARGIN_MIN_MAX_FAIL
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : TEST_CFG SIGNALS
    
    
    wire    volatile_test_cfg_decode;         // DECODE
    wire    volatile_test_cfg_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] volatile_test_cfg_rd_data;          // READ DATA
    wire    [64-1 : 0] volatile_test_cfg_offset;  // OFFSET
    output  volatile_test_cfg_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   volatile_test_cfg_ee_loop_in_enb          ;      // FIELD : EE_LOOP
    input   volatile_test_cfg_ee_use_test_addr_in_enb ;      // FIELD : EE_USE_TEST_ADDR
    input   volatile_test_cfg_ee_test_addr_in_enb     ;      // FIELD : EE_TEST_ADDR
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg          volatile_test_cfg_ee_loop_q          ;      // FIELD : EE_LOOP
    reg          volatile_test_cfg_ee_use_test_addr_q ;      // FIELD : EE_USE_TEST_ADDR
    reg  [3 : 0] volatile_test_cfg_ee_test_addr_q     ;      // FIELD : EE_TEST_ADDR
    
    // READ DATA SIGNAL FOR EACH FIELD
    output           volatile_test_cfg_ee_loop_r          ;      // FIELD : EE_LOOP
    output           volatile_test_cfg_ee_use_test_addr_r ;      // FIELD : EE_USE_TEST_ADDR
    output   [3 : 0] volatile_test_cfg_ee_test_addr_r     ;      // FIELD : EE_TEST_ADDR
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input            volatile_test_cfg_ee_loop_in          ;      // FIELD : EE_LOOP
    
    input            volatile_test_cfg_ee_use_test_addr_in ;      // FIELD : EE_USE_TEST_ADDR
    
    input    [3 : 0] volatile_test_cfg_ee_test_addr_in     ;      // FIELD : EE_TEST_ADDR
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_4 SIGNALS
    
    
    wire    shadow_shadow_4_decode;         // DECODE
    wire    shadow_shadow_4_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_4_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_4_offset;  // OFFSET
    output  shadow_shadow_4_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_4_rmt_in_enb      ;      // FIELD : RMT
    input   shadow_shadow_4_pol_in_enb      ;      // FIELD : POL
    input   shadow_shadow_4_aggr_in_enb     ;      // FIELD : AGGR
    input   shadow_shadow_4_teeth_in_enb    ;      // FIELD : TEETH
    input   shadow_shadow_4_fact_tpo_in_enb ;      // FIELD : FACT_TPO
    input   shadow_shadow_4_wdog_en_in_enb  ;      // FIELD : WDOG_EN
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [2 : 0] shadow_shadow_4_rmt_q      ;      // FIELD : RMT
    reg          shadow_shadow_4_pol_q      ;      // FIELD : POL
    reg          shadow_shadow_4_aggr_q     ;      // FIELD : AGGR
    reg  [3 : 0] shadow_shadow_4_teeth_q    ;      // FIELD : TEETH
    reg [12 : 0] shadow_shadow_4_fact_tpo_q ;      // FIELD : FACT_TPO
    reg          shadow_shadow_4_wdog_en_q  ;      // FIELD : WDOG_EN
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [2 : 0] shadow_shadow_4_rmt_r      ;      // FIELD : RMT
    output           shadow_shadow_4_pol_r      ;      // FIELD : POL
    output           shadow_shadow_4_aggr_r     ;      // FIELD : AGGR
    output   [3 : 0] shadow_shadow_4_teeth_r    ;      // FIELD : TEETH
    output  [12 : 0] shadow_shadow_4_fact_tpo_r ;      // FIELD : FACT_TPO
    output           shadow_shadow_4_wdog_en_r  ;      // FIELD : WDOG_EN
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [2 : 0] shadow_shadow_4_rmt_in      ;      // FIELD : RMT
    
    input            shadow_shadow_4_pol_in      ;      // FIELD : POL
    
    input            shadow_shadow_4_aggr_in     ;      // FIELD : AGGR
    
    input    [3 : 0] shadow_shadow_4_teeth_in    ;      // FIELD : TEETH
    
    input   [12 : 0] shadow_shadow_4_fact_tpo_in ;      // FIELD : FACT_TPO
    
    input            shadow_shadow_4_wdog_en_in  ;      // FIELD : WDOG_EN
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_5 SIGNALS
    
    
    wire    shadow_shadow_5_decode;         // DECODE
    wire    shadow_shadow_5_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_5_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_5_offset;  // OFFSET
    output  shadow_shadow_5_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_5_thrr_in_enb           ;      // FIELD : THRR
    input   shadow_shadow_5_thrf_in_enb           ;      // FIELD : THRF
    input   shadow_shadow_5_ffall_in_enb          ;      // FIELD : FFALL
    input   shadow_shadow_5_fb_test_in_enb        ;      // FIELD : FB_TEST
    input   shadow_shadow_5_dem_test_in_enb       ;      // FIELD : DEM_TEST
    input   shadow_shadow_5_fe_cal_dis_in_enb     ;      // FIELD : FE_CAL_DIS
    input   shadow_shadow_5_variable_chop_in_enb  ;      // FIELD : VARIABLE_CHOP
    input   shadow_shadow_5_adc_filter_sel_in_enb ;      // FIELD : ADC_FILTER_SEL
    input   shadow_shadow_5_tpoself_dis_in_enb    ;      // FIELD : TPOSELF_DIS
    input   shadow_shadow_5_tpoself_lvl_in_enb    ;      // FIELD : TPOSELF_LVL
    input   shadow_shadow_5_temp_comp_in_enb      ;      // FIELD : TEMP_COMP
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg  [3 : 0] shadow_shadow_5_thrr_q           ;      // FIELD : THRR
    reg  [3 : 0] shadow_shadow_5_thrf_q           ;      // FIELD : THRF
    reg          shadow_shadow_5_ffall_q          ;      // FIELD : FFALL
    reg          shadow_shadow_5_fb_test_q        ;      // FIELD : FB_TEST
    reg          shadow_shadow_5_dem_test_q       ;      // FIELD : DEM_TEST
    reg          shadow_shadow_5_fe_cal_dis_q     ;      // FIELD : FE_CAL_DIS
    reg          shadow_shadow_5_variable_chop_q  ;      // FIELD : VARIABLE_CHOP
    reg          shadow_shadow_5_adc_filter_sel_q ;      // FIELD : ADC_FILTER_SEL
    reg          shadow_shadow_5_tpoself_dis_q    ;      // FIELD : TPOSELF_DIS
    reg          shadow_shadow_5_tpoself_lvl_q    ;      // FIELD : TPOSELF_LVL
    reg  [3 : 0] shadow_shadow_5_temp_comp_q      ;      // FIELD : TEMP_COMP
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [3 : 0] shadow_shadow_5_thrr_r           ;      // FIELD : THRR
    output   [3 : 0] shadow_shadow_5_thrf_r           ;      // FIELD : THRF
    output           shadow_shadow_5_ffall_r          ;      // FIELD : FFALL
    output           shadow_shadow_5_fb_test_r        ;      // FIELD : FB_TEST
    output           shadow_shadow_5_dem_test_r       ;      // FIELD : DEM_TEST
    output           shadow_shadow_5_fe_cal_dis_r     ;      // FIELD : FE_CAL_DIS
    output           shadow_shadow_5_variable_chop_r  ;      // FIELD : VARIABLE_CHOP
    output           shadow_shadow_5_adc_filter_sel_r ;      // FIELD : ADC_FILTER_SEL
    output           shadow_shadow_5_tpoself_dis_r    ;      // FIELD : TPOSELF_DIS
    output           shadow_shadow_5_tpoself_lvl_r    ;      // FIELD : TPOSELF_LVL
    output   [3 : 0] shadow_shadow_5_temp_comp_r      ;      // FIELD : TEMP_COMP
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [3 : 0] shadow_shadow_5_thrr_in           ;      // FIELD : THRR
    
    input    [3 : 0] shadow_shadow_5_thrf_in           ;      // FIELD : THRF
    
    input            shadow_shadow_5_ffall_in          ;      // FIELD : FFALL
    
    input            shadow_shadow_5_fb_test_in        ;      // FIELD : FB_TEST
    
    input            shadow_shadow_5_dem_test_in       ;      // FIELD : DEM_TEST
    
    input            shadow_shadow_5_fe_cal_dis_in     ;      // FIELD : FE_CAL_DIS
    
    input            shadow_shadow_5_variable_chop_in  ;      // FIELD : VARIABLE_CHOP
    
    input            shadow_shadow_5_adc_filter_sel_in ;      // FIELD : ADC_FILTER_SEL
    
    input            shadow_shadow_5_tpoself_dis_in    ;      // FIELD : TPOSELF_DIS
    
    input            shadow_shadow_5_tpoself_lvl_in    ;      // FIELD : TPOSELF_LVL
    
    input    [3 : 0] shadow_shadow_5_temp_comp_in      ;      // FIELD : TEMP_COMP
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_6 SIGNALS
    
    
    wire    shadow_shadow_6_decode;         // DECODE
    wire    shadow_shadow_6_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_6_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_6_offset;  // OFFSET
    output  shadow_shadow_6_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_6_diff_baseline_40_in_enb ;      // FIELD : DIFF_BASELINE_40
    input   shadow_shadow_6_diff_tpo_40_in_enb      ;      // FIELD : DIFF_TPO_40
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [12 : 0] shadow_shadow_6_diff_baseline_40_q ;      // FIELD : DIFF_BASELINE_40
    reg [12 : 0] shadow_shadow_6_diff_tpo_40_q      ;      // FIELD : DIFF_TPO_40
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [12 : 0] shadow_shadow_6_diff_baseline_40_r ;      // FIELD : DIFF_BASELINE_40
    output  [12 : 0] shadow_shadow_6_diff_tpo_40_r      ;      // FIELD : DIFF_TPO_40
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [12 : 0] shadow_shadow_6_diff_baseline_40_in ;      // FIELD : DIFF_BASELINE_40
    
    input   [12 : 0] shadow_shadow_6_diff_tpo_40_in      ;      // FIELD : DIFF_TPO_40
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_7 SIGNALS
    
    
    wire    shadow_shadow_7_decode;         // DECODE
    wire    shadow_shadow_7_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_7_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_7_offset;  // OFFSET
    output  shadow_shadow_7_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_7_diff_baseline_25_in_enb ;      // FIELD : DIFF_BASELINE_25
    input   shadow_shadow_7_diff_tpo_25_in_enb      ;      // FIELD : DIFF_TPO_25
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [12 : 0] shadow_shadow_7_diff_baseline_25_q ;      // FIELD : DIFF_BASELINE_25
    reg [12 : 0] shadow_shadow_7_diff_tpo_25_q      ;      // FIELD : DIFF_TPO_25
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [12 : 0] shadow_shadow_7_diff_baseline_25_r ;      // FIELD : DIFF_BASELINE_25
    output  [12 : 0] shadow_shadow_7_diff_tpo_25_r      ;      // FIELD : DIFF_TPO_25
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [12 : 0] shadow_shadow_7_diff_baseline_25_in ;      // FIELD : DIFF_BASELINE_25
    
    input   [12 : 0] shadow_shadow_7_diff_tpo_25_in      ;      // FIELD : DIFF_TPO_25
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_8 SIGNALS
    
    
    wire    shadow_shadow_8_decode;         // DECODE
    wire    shadow_shadow_8_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_8_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_8_offset;  // OFFSET
    output  shadow_shadow_8_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_8_diff_baseline_165_in_enb ;      // FIELD : DIFF_BASELINE_165
    input   shadow_shadow_8_diff_tpo_165_in_enb      ;      // FIELD : DIFF_TPO_165
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [12 : 0] shadow_shadow_8_diff_baseline_165_q ;      // FIELD : DIFF_BASELINE_165
    reg [12 : 0] shadow_shadow_8_diff_tpo_165_q      ;      // FIELD : DIFF_TPO_165
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  [12 : 0] shadow_shadow_8_diff_baseline_165_r ;      // FIELD : DIFF_BASELINE_165
    output  [12 : 0] shadow_shadow_8_diff_tpo_165_r      ;      // FIELD : DIFF_TPO_165
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   [12 : 0] shadow_shadow_8_diff_baseline_165_in ;      // FIELD : DIFF_BASELINE_165
    
    input   [12 : 0] shadow_shadow_8_diff_tpo_165_in      ;      // FIELD : DIFF_TPO_165
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_9 SIGNALS
    
    
    wire    shadow_shadow_9_decode;         // DECODE
    wire    shadow_shadow_9_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_9_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_9_offset;  // OFFSET
    output  shadow_shadow_9_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_9_halltrim_in_enb     ;      // FIELD : HALLTRIM
    input   shadow_shadow_9_osc_trim_in_enb     ;      // FIELD : OSC_TRIM
    input   shadow_shadow_9_ref_bg_trim_in_enb  ;      // FIELD : REF_BG_TRIM
    input   shadow_shadow_9_out_fastfall_in_enb ;      // FIELD : OUT_FASTFALL
    
    // BUFFER SIGNAL FOR EACH FIELD
    wire  [6 : 0] shadow_shadow_9_halltrim_q     ;      // FIELD : HALLTRIM
    wire  [4 : 0] shadow_shadow_9_osc_trim_q     ;      // FIELD : OSC_TRIM
    wire  [4 : 0] shadow_shadow_9_ref_bg_trim_q  ;      // FIELD : REF_BG_TRIM
    wire          shadow_shadow_9_out_fastfall_q ;      // FIELD : OUT_FASTFALL
    
    // READ DATA SIGNAL FOR EACH FIELD
    output   [6 : 0] shadow_shadow_9_halltrim_r     ;      // FIELD : HALLTRIM
    output   [4 : 0] shadow_shadow_9_osc_trim_r     ;      // FIELD : OSC_TRIM
    output   [4 : 0] shadow_shadow_9_ref_bg_trim_r  ;      // FIELD : REF_BG_TRIM
    output           shadow_shadow_9_out_fastfall_r ;      // FIELD : OUT_FASTFALL
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input    [6 : 0] shadow_shadow_9_halltrim_in     ;      // FIELD : HALLTRIM
    
    input    [4 : 0] shadow_shadow_9_osc_trim_in     ;      // FIELD : OSC_TRIM
    
    input    [4 : 0] shadow_shadow_9_ref_bg_trim_in  ;      // FIELD : REF_BG_TRIM
    
    input            shadow_shadow_9_out_fastfall_in ;      // FIELD : OUT_FASTFALL
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : SHADOW_A SIGNALS
    
    
    wire    shadow_shadow_a_decode;         // DECODE
    wire    shadow_shadow_a_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] shadow_shadow_a_rd_data;          // READ DATA
    wire    [64-1 : 0] shadow_shadow_a_offset;  // OFFSET
    output  shadow_shadow_a_enb;    // REGISTER ENABLE
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   shadow_shadow_a_lock_t_in_enb  ;      // FIELD : LOCK_T
    input   shadow_shadow_a_lock_a_in_enb  ;      // FIELD : LOCK_A
    input   shadow_shadow_a_lock_c_in_enb  ;      // FIELD : LOCK_C
    input   shadow_shadow_a_lock_o_in_enb  ;      // FIELD : LOCK_O
    input   shadow_shadow_a_lock_s_in_enb  ;      // FIELD : LOCK_S
    input   shadow_shadow_a_lock_bd_in_enb ;      // FIELD : LOCK_BD
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg shadow_shadow_a_lock_t_q  ;      // FIELD : LOCK_T
    reg shadow_shadow_a_lock_a_q  ;      // FIELD : LOCK_A
    reg shadow_shadow_a_lock_c_q  ;      // FIELD : LOCK_C
    reg shadow_shadow_a_lock_o_q  ;      // FIELD : LOCK_O
    reg shadow_shadow_a_lock_s_q  ;      // FIELD : LOCK_S
    reg shadow_shadow_a_lock_bd_q ;      // FIELD : LOCK_BD
    
    // READ DATA SIGNAL FOR EACH FIELD
    output  shadow_shadow_a_lock_t_r  ;      // FIELD : LOCK_T
    output  shadow_shadow_a_lock_a_r  ;      // FIELD : LOCK_A
    output  shadow_shadow_a_lock_c_r  ;      // FIELD : LOCK_C
    output  shadow_shadow_a_lock_o_r  ;      // FIELD : LOCK_O
    output  shadow_shadow_a_lock_s_r  ;      // FIELD : LOCK_S
    output  shadow_shadow_a_lock_bd_r ;      // FIELD : LOCK_BD
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input   shadow_shadow_a_lock_t_in  ;      // FIELD : LOCK_T
    
    input   shadow_shadow_a_lock_a_in  ;      // FIELD : LOCK_A
    
    input   shadow_shadow_a_lock_c_in  ;      // FIELD : LOCK_C
    
    input   shadow_shadow_a_lock_o_in  ;      // FIELD : LOCK_O
    
    input   shadow_shadow_a_lock_s_in  ;      // FIELD : LOCK_S
    
    input   shadow_shadow_a_lock_bd_in ;      // FIELD : LOCK_BD
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER(EXTERNAL) : EEPROM SIGNALS
    input   eeprom_rd_ack_in;
    input  [bus_width-1 : 0] eeprom_rd_data_in;
    output  eeprom_rd_valid_out;
    input   eeprom_wr_req_in;
    output  eeprom_wr_valid_out;
    wire    eeprom_decode;
    wire    [64-1 : 0] eeprom_offset;
    wire    eeprom_rd_valid;
    wire    eeprom_wr_valid;
    wire     eeprom_wr_req_wire;
    wire     eeprom_rd_ack_wire;
    wire     eeprom_decode_wire;
    
    wire    [bus_width-1 : 0] eeprom_rd_data;
    
    //-----------------------------------------------------
    
    
    
    output [addr_width-1:0] address_out;
    output [bus_width-1:0] wr_data_out;
    
    wire  [bus_width-1:0] int_rd_data;
    wire  [bus_width-1:0] ext_rd_data;
    wire external_rd_valid;
    reg  rd_wait_state;
    wire external_rd_ack;
    wire external_wr_req;
    wire external_access;
    
    //CUSTOM signals
    input clk;
    input reset_l;
    input rd_stb;
    output rd_wait;
    input wr_stb;
    input [addr_width-1 : 0] address;
    input [bus_width-1 : 0] wr_data;
    input [bus_width-1 : 0] bitenable;
    output request;
    output rd_data_vld;
    output [bus_width-1 : 0] rd_data;
    
    wire  [bus_width-1:0] rd_data;
    wire [bus_width-1 : 0] reg_enb;
    assign address_out = address;
    assign wr_data_out = wr_data;
    
    assign reg_enb = bitenable;
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  STATUS0
    // ADDRESS       :  block_offset+'h0 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //      3:0 : dsc_major  ( SW : Read-only HW : Read-Write )
    //      7:4 : dsc_minor  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    assign volatile_status0_offset = block_offset+'h0 + 'h0;
    assign volatile_status0_decode  = (address[volatile_address_width-1 : 0]    == volatile_status0_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_status0_dsc_major_r =  volatile_status0_dsc_major_q;    // Field : DSC_MAJOR
    assign volatile_status0_dsc_major_q = volatile_status0_dsc_major_in;    // Field : DSC_MAJOR
    assign volatile_status0_dsc_minor_r =  volatile_status0_dsc_minor_q;    // Field : DSC_MINOR
    assign volatile_status0_dsc_minor_q = volatile_status0_dsc_minor_in;    // Field : DSC_MINOR
    
    
    assign volatile_status0_rd_data = volatile_status0_decode ? {24'b0 ,volatile_status0_dsc_minor_q , volatile_status0_dsc_major_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  CFG0
    // ADDRESS       :  block_offset+'h0 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : outmode          ( SW : Read-Write HW : Read-Write )
    //        1 : pdiff_we         ( SW : Read-Write HW : Read-Write )
    //        2 : diff_we          ( SW : Read-Write HW : Read-Write )
    //        3 : tdiff_we         ( SW : Read-Write HW : Read-Write )
    //        4 : hallphase_we     ( SW : Read-Write HW : Read-Write )
    //        5 : state_we         ( SW : Read-Write HW : Read-Write )
    //        6 : temperature_we   ( SW : Read-Write HW : Read-Write )
    //        7 : out_we           ( SW : Read-Write HW : Read-Write )
    //        8 : samp_dis         ( SW : Read-Write HW : Read-Write )
    //        9 : conv_dis         ( SW : Read-Write HW : Read-Write )
    //    11:10 : eforce_mode      ( SW : Read-Write HW : Read-Write )
    //       12 : force_hallshort  ( SW : Read-Write HW : Read-Write )
    //       13 : out_risetime     ( SW : Read-Write HW : Read-Write )
    //       14 : force_timeout    ( SW : Read-Write HW : Read-Write )
    //       15 : tpo_auto_update  ( SW : Read-Write HW : Read-Write )
    //       16 : force_tpo        ( SW : Read-Write HW : Read-Write )
    //       17 : cpump_load       ( SW : Read-Write HW : Read-Write )
    //       18 : out_prog_en      ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_cfg0_wr_valid = volatile_cfg0_decode && wr_stb;
    assign volatile_cfg0_enb      = volatile_cfg0_wr_valid;
    assign volatile_cfg0_offset = block_offset+'h0 + 'h4;
    assign volatile_cfg0_decode  = (address[volatile_address_width-1 : 0]    == volatile_cfg0_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OUTMODE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Allows MUX on the output when set. Must be set prior to DMA or RMA read accesses.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_outmode_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_outmode_in_enb)   // OUTMODE : HW Write
                begin
                    volatile_cfg0_outmode_q <= volatile_cfg0_outmode_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // OUTMODE : SW Write
                    begin
                        volatile_cfg0_outmode_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_cfg0_outmode_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PDIFF_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes pdiff signal and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_pdiff_we_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_pdiff_we_in_enb)   // PDIFF_WE : HW Write
                begin
                    volatile_cfg0_pdiff_we_q <= volatile_cfg0_pdiff_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // PDIFF_WE : SW Write
                    begin
                        volatile_cfg0_pdiff_we_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_cfg0_pdiff_we_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes diff signal and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_diff_we_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_diff_we_in_enb)   // DIFF_WE : HW Write
                begin
                    volatile_cfg0_diff_we_q <= volatile_cfg0_diff_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // DIFF_WE : SW Write
                    begin
                        volatile_cfg0_diff_we_q <=  ( wr_data[2] & reg_enb[2] ) | (volatile_cfg0_diff_we_q & (~reg_enb[2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TDIFF_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes tdiff signal and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_tdiff_we_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_tdiff_we_in_enb)   // TDIFF_WE : HW Write
                begin
                    volatile_cfg0_tdiff_we_q <= volatile_cfg0_tdiff_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // TDIFF_WE : SW Write
                    begin
                        volatile_cfg0_tdiff_we_q <=  ( wr_data[3] & reg_enb[3] ) | (volatile_cfg0_tdiff_we_q & (~reg_enb[3]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : HALLPHASE_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes hallphase signal and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_hallphase_we_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_hallphase_we_in_enb)   // HALLPHASE_WE : HW Write
                begin
                    volatile_cfg0_hallphase_we_q <= volatile_cfg0_hallphase_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // HALLPHASE_WE : SW Write
                    begin
                        volatile_cfg0_hallphase_we_q <=  ( wr_data[4] & reg_enb[4] ) | (volatile_cfg0_hallphase_we_q & (~reg_enb[4]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : STATE_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes state register and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_state_we_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_state_we_in_enb)   // STATE_WE : HW Write
                begin
                    volatile_cfg0_state_we_q <= volatile_cfg0_state_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // STATE_WE : SW Write
                    begin
                        volatile_cfg0_state_we_q <=  ( wr_data[5] & reg_enb[5] ) | (volatile_cfg0_state_we_q & (~reg_enb[5]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TEMPERATURE_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes temperature signal and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_temperature_we_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_temperature_we_in_enb)   // TEMPERATURE_WE : HW Write
                begin
                    volatile_cfg0_temperature_we_q <= volatile_cfg0_temperature_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // TEMPERATURE_WE : SW Write
                    begin
                        volatile_cfg0_temperature_we_q <=  ( wr_data[6] & reg_enb[6] ) | (volatile_cfg0_temperature_we_q & (~reg_enb[6]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OUT_WE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Freezes out signal and makes it writeable.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_out_we_q  <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_out_we_in_enb)   // OUT_WE : HW Write
                begin
                    volatile_cfg0_out_we_q <= volatile_cfg0_out_we_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // OUT_WE : SW Write
                    begin
                        volatile_cfg0_out_we_q <=  ( wr_data[7] & reg_enb[7] ) | (volatile_cfg0_out_we_q & (~reg_enb[7]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : SAMP_DIS
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Disables samp outputs.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_samp_dis_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_samp_dis_in_enb)   // SAMP_DIS : HW Write
                begin
                    volatile_cfg0_samp_dis_q <= volatile_cfg0_samp_dis_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // SAMP_DIS : SW Write
                    begin
                        volatile_cfg0_samp_dis_q <=  ( wr_data[8] & reg_enb[8] ) | (volatile_cfg0_samp_dis_q & (~reg_enb[8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CONV_DIS
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  9
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Disables conv outputs.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_conv_dis_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_conv_dis_in_enb)   // CONV_DIS : HW Write
                begin
                    volatile_cfg0_conv_dis_q <= volatile_cfg0_conv_dis_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // CONV_DIS : SW Write
                    begin
                        volatile_cfg0_conv_dis_q <=  ( wr_data[9] & reg_enb[9] ) | (volatile_cfg0_conv_dis_q & (~reg_enb[9]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EFORCE_MODE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  10
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  EFORCE phase mode.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_eforce_mode_q <= 2'b00;
            end
        else
            begin
            if (volatile_cfg0_eforce_mode_in_enb)   // EFORCE_MODE : HW Write
                begin
                    volatile_cfg0_eforce_mode_q <= volatile_cfg0_eforce_mode_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // EFORCE_MODE : SW Write
                    begin
                        volatile_cfg0_eforce_mode_q <=  ( wr_data[11 : 10] & reg_enb[11 : 10] ) | (volatile_cfg0_eforce_mode_q & (~reg_enb[11 : 10]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FORCE_HALLSHORT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Short Hallplate.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_force_hallshort_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_force_hallshort_in_enb)   // FORCE_HALLSHORT : HW Write
                begin
                    volatile_cfg0_force_hallshort_q <= volatile_cfg0_force_hallshort_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // FORCE_HALLSHORT : SW Write
                    begin
                        volatile_cfg0_force_hallshort_q <=  ( wr_data[12] & reg_enb[12] ) | (volatile_cfg0_force_hallshort_q & (~reg_enb[12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OUT_RISETIME
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  13
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Write '1' to revert to traditional non-limited output rise time.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_out_risetime_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_out_risetime_in_enb)   // OUT_RISETIME : HW Write
                begin
                    volatile_cfg0_out_risetime_q <= volatile_cfg0_out_risetime_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // OUT_RISETIME : SW Write
                    begin
                        volatile_cfg0_out_risetime_q <=  ( wr_data[13] & reg_enb[13] ) | (volatile_cfg0_out_risetime_q & (~reg_enb[13]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FORCE_TIMEOUT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  14
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Forces a watchdog timeout event.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_force_timeout_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_force_timeout_in_enb)   // FORCE_TIMEOUT : HW Write
                begin
                    volatile_cfg0_force_timeout_q <= volatile_cfg0_force_timeout_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // FORCE_TIMEOUT : SW Write
                    begin
                        volatile_cfg0_force_timeout_q <=  ( wr_data[14] & reg_enb[14] ) | (volatile_cfg0_force_timeout_q & (~reg_enb[14]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TPO_AUTO_UPDATE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  15
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Write '1' to copy the value of CDIFF into the FACT_TPO field in the EEPROM. This bit is a self-clearing one-shot.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_tpo_auto_update_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_tpo_auto_update_in_enb)   // TPO_AUTO_UPDATE : HW Write
                begin
                    volatile_cfg0_tpo_auto_update_q <= volatile_cfg0_tpo_auto_update_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // TPO_AUTO_UPDATE : SW Write
                    begin
                        volatile_cfg0_tpo_auto_update_q <=  ( wr_data[15] & reg_enb[15] ) | (volatile_cfg0_tpo_auto_update_q & (~reg_enb[15]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FORCE_TPO
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Force TPO state regardless of the current state of the controller.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_force_tpo_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_force_tpo_in_enb)   // FORCE_TPO : HW Write
                begin
                    volatile_cfg0_force_tpo_q <= volatile_cfg0_force_tpo_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // FORCE_TPO : SW Write
                    begin
                        volatile_cfg0_force_tpo_q <=  ( wr_data[16] & reg_enb[16] ) | (volatile_cfg0_force_tpo_q & (~reg_enb[16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CPUMP_LOAD
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  17
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Adds excess load to the regulator charge pump to test its load margin.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_cpump_load_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_cpump_load_in_enb)   // CPUMP_LOAD : HW Write
                begin
                    volatile_cfg0_cpump_load_q <= volatile_cfg0_cpump_load_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // CPUMP_LOAD : SW Write
                    begin
                        volatile_cfg0_cpump_load_q <=  ( wr_data[17] & reg_enb[17] ) | (volatile_cfg0_cpump_load_q & (~reg_enb[17]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : OUT_PROG_EN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  18
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Controls whether programming is performed via the VCC or output pins:
    //                  0 = VCC programming.
    //                  1 = Output programming.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg0_out_prog_en_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg0_out_prog_en_in_enb)   // OUT_PROG_EN : HW Write
                begin
                    volatile_cfg0_out_prog_en_q <= volatile_cfg0_out_prog_en_in;
                end
            else
                begin
                    
                if (volatile_cfg0_wr_valid)   // OUT_PROG_EN : SW Write
                    begin
                        volatile_cfg0_out_prog_en_q <=  ( wr_data[18] & reg_enb[18] ) | (volatile_cfg0_out_prog_en_q & (~reg_enb[18]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_cfg0_outmode_r =  volatile_cfg0_outmode_q;    // Field : OUTMODE
    assign volatile_cfg0_pdiff_we_r =  volatile_cfg0_pdiff_we_q;    // Field : PDIFF_WE
    assign volatile_cfg0_diff_we_r =  volatile_cfg0_diff_we_q;    // Field : DIFF_WE
    assign volatile_cfg0_tdiff_we_r =  volatile_cfg0_tdiff_we_q;    // Field : TDIFF_WE
    assign volatile_cfg0_hallphase_we_r =  volatile_cfg0_hallphase_we_q;    // Field : HALLPHASE_WE
    assign volatile_cfg0_state_we_r =  volatile_cfg0_state_we_q;    // Field : STATE_WE
    assign volatile_cfg0_temperature_we_r =  volatile_cfg0_temperature_we_q;    // Field : TEMPERATURE_WE
    assign volatile_cfg0_out_we_r  =  volatile_cfg0_out_we_q ;    // Field : OUT_WE
    assign volatile_cfg0_samp_dis_r =  volatile_cfg0_samp_dis_q;    // Field : SAMP_DIS
    assign volatile_cfg0_conv_dis_r =  volatile_cfg0_conv_dis_q;    // Field : CONV_DIS
    assign volatile_cfg0_eforce_mode_r =  volatile_cfg0_eforce_mode_q;    // Field : EFORCE_MODE
    assign volatile_cfg0_force_hallshort_r =  volatile_cfg0_force_hallshort_q;    // Field : FORCE_HALLSHORT
    assign volatile_cfg0_out_risetime_r =  volatile_cfg0_out_risetime_q;    // Field : OUT_RISETIME
    assign volatile_cfg0_force_timeout_r =  volatile_cfg0_force_timeout_q;    // Field : FORCE_TIMEOUT
    assign volatile_cfg0_tpo_auto_update_r =  volatile_cfg0_tpo_auto_update_q;    // Field : TPO_AUTO_UPDATE
    assign volatile_cfg0_force_tpo_r =  volatile_cfg0_force_tpo_q;    // Field : FORCE_TPO
    assign volatile_cfg0_cpump_load_r =  volatile_cfg0_cpump_load_q;    // Field : CPUMP_LOAD
    assign volatile_cfg0_out_prog_en_r =  volatile_cfg0_out_prog_en_q;    // Field : OUT_PROG_EN
    
    
    assign volatile_cfg0_rd_data = volatile_cfg0_decode ? {13'b0 ,volatile_cfg0_out_prog_en_q , volatile_cfg0_cpump_load_q , volatile_cfg0_force_tpo_q , volatile_cfg0_tpo_auto_update_q , volatile_cfg0_force_timeout_q , volatile_cfg0_out_risetime_q , volatile_cfg0_force_hallshort_q , volatile_cfg0_eforce_mode_q , volatile_cfg0_conv_dis_q , volatile_cfg0_samp_dis_q , volatile_cfg0_out_we_q , volatile_cfg0_temperature_we_q , volatile_cfg0_state_we_q , volatile_cfg0_hallphase_we_q , volatile_cfg0_tdiff_we_q , volatile_cfg0_diff_we_q , volatile_cfg0_pdiff_we_q , volatile_cfg0_outmode_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  CFG1
    // ADDRESS       :  block_offset+'h0 + 'h8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : eol_diag_en  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    //
    
    
    assign volatile_cfg1_wr_valid = volatile_cfg1_decode && wr_stb;
    assign volatile_cfg1_enb      = volatile_cfg1_wr_valid;
    assign volatile_cfg1_offset = block_offset+'h0 + 'h8;
    assign volatile_cfg1_decode  = (address[volatile_address_width-1 : 0]    == volatile_cfg1_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EOL_DIAG_EN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Write '1' to enable EOL diagnostic function
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg1_eol_diag_en_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg1_eol_diag_en_in_enb)   // EOL_DIAG_EN : HW Write
                begin
                    volatile_cfg1_eol_diag_en_q <= volatile_cfg1_eol_diag_en_in;
                end
            else
                begin
                    
                if (volatile_cfg1_wr_valid)   // EOL_DIAG_EN : SW Write
                    begin
                        volatile_cfg1_eol_diag_en_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_cfg1_eol_diag_en_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_cfg1_eol_diag_en_r =  volatile_cfg1_eol_diag_en_q;    // Field : EOL_DIAG_EN
    
    
    assign volatile_cfg1_rd_data = volatile_cfg1_decode ? {31'b0 ,volatile_cfg1_eol_diag_en_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  CFG2
    // ADDRESS       :  block_offset+'h0 + 'hC                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : adc_test_start    ( SW : Read-Write HW : Read-Write )
    //        1 : auto_hall_start   ( SW : Read-Write HW : Read-Write )
    //     14:8 : auto_hall_target  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_cfg2_wr_valid = volatile_cfg2_decode && wr_stb;
    assign volatile_cfg2_enb      = volatile_cfg2_wr_valid;
    assign volatile_cfg2_offset = block_offset+'h0 + 'hC;
    assign volatile_cfg2_decode  = (address[volatile_address_width-1 : 0]    == volatile_cfg2_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ADC_TEST_START
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Start ADC self test (clears when finished).
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg2_adc_test_start_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg2_adc_test_start_in_enb)   // ADC_TEST_START : HW Write
                begin
                    volatile_cfg2_adc_test_start_q <= volatile_cfg2_adc_test_start_in;
                end
            else
                begin
                    
                if (volatile_cfg2_wr_valid)   // ADC_TEST_START : SW Write
                    begin
                        volatile_cfg2_adc_test_start_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_cfg2_adc_test_start_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : AUTO_HALL_START
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Start Hall Automatic Trim (clears when finished).
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg2_auto_hall_start_q <= 1'b0;
            end
        else
            begin
            if (volatile_cfg2_auto_hall_start_in_enb)   // AUTO_HALL_START : HW Write
                begin
                    volatile_cfg2_auto_hall_start_q <= volatile_cfg2_auto_hall_start_in;
                end
            else
                begin
                    
                if (volatile_cfg2_wr_valid)   // AUTO_HALL_START : SW Write
                    begin
                        volatile_cfg2_auto_hall_start_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_cfg2_auto_hall_start_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : AUTO_HALL_TARGET
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  7
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  User settable Hall Automatic Trim target
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cfg2_auto_hall_target_q <= 7'b0000000;
            end
        else
            begin
            if (volatile_cfg2_auto_hall_target_in_enb)   // AUTO_HALL_TARGET : HW Write
                begin
                    volatile_cfg2_auto_hall_target_q <= volatile_cfg2_auto_hall_target_in;
                end
            else
                begin
                    
                if (volatile_cfg2_wr_valid)   // AUTO_HALL_TARGET : SW Write
                    begin
                        volatile_cfg2_auto_hall_target_q <=  ( wr_data[14 : 8] & reg_enb[14 : 8] ) | (volatile_cfg2_auto_hall_target_q & (~reg_enb[14 : 8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_cfg2_adc_test_start_r =  volatile_cfg2_adc_test_start_q;    // Field : ADC_TEST_START
    assign volatile_cfg2_auto_hall_start_r =  volatile_cfg2_auto_hall_start_q;    // Field : AUTO_HALL_START
    assign volatile_cfg2_auto_hall_target_r =  volatile_cfg2_auto_hall_target_q;    // Field : AUTO_HALL_TARGET
    
    
    assign volatile_cfg2_rd_data = volatile_cfg2_decode ? {17'b0 ,volatile_cfg2_auto_hall_target_q , 6'b0 ,volatile_cfg2_auto_hall_start_q , volatile_cfg2_adc_test_start_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  TEST_RESULT
    // ADDRESS       :  block_offset+'h0 + 'h10                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //      7:0 : seq_conv_result  ( SW : Read-only HW : Read-Write )
    //     15:8 : sar_result       ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_test_result_offset       = block_offset +'h0 + 'h10;
    assign volatile_test_result_decode      = (address[reg_map_address_width - 1:0]  == volatile_test_result_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_test_result_rd_valid     = volatile_test_result_decode && rd_stb && rd_wait_state;
    assign volatile_test_result_rd_valid_out = volatile_test_result_rd_valid;
    
    assign volatile_test_result_rd_data      = volatile_test_result_rd_ack_in ? volatile_test_result_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  HALLPHASE
    // ADDRESS       :  block_offset+'h0 + 'h14                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      3:0 : hallphase  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_hallphase_offset       = block_offset +'h0 + 'h14;
    assign volatile_hallphase_decode      = (address[reg_map_address_width - 1:0]  == volatile_hallphase_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_hallphase_wr_valid     = volatile_hallphase_decode &&  wr_stb;
    assign volatile_hallphase_rd_valid     = volatile_hallphase_decode && rd_stb && rd_wait_state;
    assign volatile_hallphase_wr_valid_out = volatile_hallphase_wr_valid;
    assign volatile_hallphase_rd_valid_out = volatile_hallphase_rd_valid;
    
    assign volatile_hallphase_rd_data      = volatile_hallphase_rd_ack_in ? volatile_hallphase_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  STATE
    // ADDRESS       :  block_offset+'h0 + 'h18                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      2:0 : state  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_state_offset       = block_offset +'h0 + 'h18;
    assign volatile_state_decode      = (address[reg_map_address_width - 1:0]  == volatile_state_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_state_wr_valid     = volatile_state_decode &&  wr_stb;
    assign volatile_state_rd_valid     = volatile_state_decode && rd_stb && rd_wait_state;
    assign volatile_state_wr_valid_out = volatile_state_wr_valid;
    assign volatile_state_rd_valid_out = volatile_state_rd_valid;
    
    assign volatile_state_rd_data      = volatile_state_rd_ack_in ? volatile_state_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  TEMPERATURE
    // ADDRESS       :  block_offset+'h0 + 'h1C                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     15:0 : temperature  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_temperature_offset       = block_offset +'h0 + 'h1C;
    assign volatile_temperature_decode      = (address[reg_map_address_width - 1:0]  == volatile_temperature_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_temperature_wr_valid     = volatile_temperature_decode &&  wr_stb;
    assign volatile_temperature_rd_valid     = volatile_temperature_decode && rd_stb && rd_wait_state;
    assign volatile_temperature_wr_valid_out = volatile_temperature_wr_valid;
    assign volatile_temperature_rd_valid_out = volatile_temperature_rd_valid;
    
    assign volatile_temperature_rd_data      = volatile_temperature_rd_ack_in ? volatile_temperature_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  PDIFF
    // ADDRESS       :  block_offset+'h0 + 'h20                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     13:0 : pdiff  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_pdiff_offset       = block_offset +'h0 + 'h20;
    assign volatile_pdiff_decode      = (address[reg_map_address_width - 1:0]  == volatile_pdiff_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_pdiff_wr_valid     = volatile_pdiff_decode &&  wr_stb;
    assign volatile_pdiff_rd_valid     = volatile_pdiff_decode && rd_stb && rd_wait_state;
    assign volatile_pdiff_wr_valid_out = volatile_pdiff_wr_valid;
    assign volatile_pdiff_rd_valid_out = volatile_pdiff_rd_valid;
    
    assign volatile_pdiff_rd_data      = volatile_pdiff_rd_ack_in ? volatile_pdiff_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  DIFF
    // ADDRESS       :  block_offset+'h0 + 'h24                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     12:0 : diff  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_diff_offset       = block_offset +'h0 + 'h24;
    assign volatile_diff_decode      = (address[reg_map_address_width - 1:0]  == volatile_diff_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_diff_wr_valid     = volatile_diff_decode &&  wr_stb;
    assign volatile_diff_rd_valid     = volatile_diff_decode && rd_stb && rd_wait_state;
    assign volatile_diff_wr_valid_out = volatile_diff_wr_valid;
    assign volatile_diff_rd_valid_out = volatile_diff_rd_valid;
    
    assign volatile_diff_rd_data      = volatile_diff_rd_ack_in ? volatile_diff_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  TDIFF
    // ADDRESS       :  block_offset+'h0 + 'h28                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     12:0 : tdiff  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_tdiff_offset       = block_offset +'h0 + 'h28;
    assign volatile_tdiff_decode      = (address[reg_map_address_width - 1:0]  == volatile_tdiff_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_tdiff_wr_valid     = volatile_tdiff_decode &&  wr_stb;
    assign volatile_tdiff_rd_valid     = volatile_tdiff_decode && rd_stb && rd_wait_state;
    assign volatile_tdiff_wr_valid_out = volatile_tdiff_wr_valid;
    assign volatile_tdiff_rd_valid_out = volatile_tdiff_rd_valid;
    
    assign volatile_tdiff_rd_data      = volatile_tdiff_rd_ack_in ? volatile_tdiff_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  OUT
    // ADDRESS       :  block_offset+'h0 + 'h2C                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : out  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_out_offset       = block_offset +'h0 + 'h2C;
    assign volatile_out_decode      = (address[reg_map_address_width - 1:0]  == volatile_out_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_out_wr_valid     = volatile_out_decode &&  wr_stb;
    assign volatile_out_rd_valid     = volatile_out_decode && rd_stb && rd_wait_state;
    assign volatile_out_wr_valid_out = volatile_out_wr_valid;
    assign volatile_out_rd_valid_out = volatile_out_rd_valid;
    
    assign volatile_out_rd_data      = volatile_out_rd_ack_in ? volatile_out_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  PPEAK
    // ADDRESS       :  block_offset+'h0 + 'h30                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     12:0 : ppeak  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_ppeak_offset       = block_offset +'h0 + 'h30;
    assign volatile_ppeak_decode      = (address[reg_map_address_width - 1:0]  == volatile_ppeak_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_ppeak_rd_valid     = volatile_ppeak_decode && rd_stb && rd_wait_state;
    assign volatile_ppeak_rd_valid_out = volatile_ppeak_rd_valid;
    
    assign volatile_ppeak_rd_data      = volatile_ppeak_rd_ack_in ? volatile_ppeak_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  PLAST
    // ADDRESS       :  block_offset+'h0 + 'h34                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     12:0 : plast  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_plast_offset       = block_offset +'h0 + 'h34;
    assign volatile_plast_decode      = (address[reg_map_address_width - 1:0]  == volatile_plast_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_plast_rd_valid     = volatile_plast_decode && rd_stb && rd_wait_state;
    assign volatile_plast_rd_valid_out = volatile_plast_rd_valid;
    
    assign volatile_plast_rd_data      = volatile_plast_rd_ack_in ? volatile_plast_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  NPEAK
    // ADDRESS       :  block_offset+'h0 + 'h38                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     12:0 : npeak  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_npeak_offset       = block_offset +'h0 + 'h38;
    assign volatile_npeak_decode      = (address[reg_map_address_width - 1:0]  == volatile_npeak_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_npeak_rd_valid     = volatile_npeak_decode && rd_stb && rd_wait_state;
    assign volatile_npeak_rd_valid_out = volatile_npeak_rd_valid;
    
    assign volatile_npeak_rd_data      = volatile_npeak_rd_ack_in ? volatile_npeak_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  STORED_TPO
    // ADDRESS       :  block_offset+'h0 + 'h3C                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-ONLY
    //
    // FIELDS   :
    //     12:0 : stored_tpo  ( SW : Read-only HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    
    assign volatile_stored_tpo_offset       = block_offset +'h0 + 'h3C;
    assign volatile_stored_tpo_decode      = (address[reg_map_address_width - 1:0]  == volatile_stored_tpo_offset[(reg_map_address_width) - 1 :0]) ? 1'b1 : 1'b0;
    assign volatile_stored_tpo_rd_valid     = volatile_stored_tpo_decode && rd_stb && rd_wait_state;
    assign volatile_stored_tpo_rd_valid_out = volatile_stored_tpo_rd_valid;
    
    assign volatile_stored_tpo_rd_data      = volatile_stored_tpo_rd_ack_in ? volatile_stored_tpo_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  EE_CFG
    // ADDRESS       :  block_offset+'h0 + 'hC0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : ee_erase         ( SW : Read-Write HW : Read-Write )
    //        1 : ee_prog          ( SW : Read-Write HW : Read-Write )
    //      3:2 : ee_block_mode    ( SW : Read-Write HW : Read-Write )
    //      6:4 : ee_vread         ( SW : Read-Write HW : Read-only )
    //        7 : ee_force_sbe     ( SW : Read-Write HW : Read-Write )
    //        8 : ee_force_dbe     ( SW : Read-Write HW : Read-Write )
    //        9 : ee_dis_ecc       ( SW : Read-Write HW : Read-Write )
    //       10 : ee_no_ecc        ( SW : Read-Write HW : Read-only )
    //       11 : ee_raw_ecc       ( SW : Read-Write HW : Read-Write )
    //       12 : ee_en_override   ( SW : Read-Write HW : Read-Write )
    //    14:13 : ee_override      ( SW : Read-Write HW : Read-Write )
    //       15 : ee_force_reload  ( SW : Read-Write HW : Read-Write )
    //       16 : ee_noload        ( SW : Read-Write HW : Read-Write )
    //       17 : ee_abort         ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_ee_cfg_wr_valid = volatile_ee_cfg_decode && wr_stb;
    assign volatile_ee_cfg_enb      = volatile_ee_cfg_wr_valid;
    assign volatile_ee_cfg_offset = block_offset+'h0 + 'hC0;
    assign volatile_ee_cfg_decode  = (address[volatile_address_width-1 : 0]    == volatile_ee_cfg_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_ERASE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Setting this bit will perform an ERASE operation only on the EEPROM the next time an EEPROM address is written. It is self-clearing when the ERASE operation is complete.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_erase_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_erase_in_enb)   // EE_ERASE : HW Write
                begin
                    volatile_ee_cfg_ee_erase_q <= volatile_ee_cfg_ee_erase_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_ERASE : SW Write
                    begin
                        volatile_ee_cfg_ee_erase_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_ee_cfg_ee_erase_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_PROG
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Setting this bit will perform a PROGRAM operation only on the EEPROM the next time and EEPROM address is written. If ERASE is set, this bit is ignored. It is self-clearing when the PROGRAM operation is complete.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_prog_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_prog_in_enb)   // EE_PROG : HW Write
                begin
                    volatile_ee_cfg_ee_prog_q <= volatile_ee_cfg_ee_prog_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_PROG : SW Write
                    begin
                        volatile_ee_cfg_ee_prog_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_ee_cfg_ee_prog_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_BLOCK_MODE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  00: Single Word Write Access
    //                  01: Odd Word Write Access (address ignored)
    //                  10: Even Word Write Access (address ignored)
    //                  11: All Word Write Access (address ignored)
    //                  This field only affects write operations.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_block_mode_q <= 2'b00;
            end
        else
            begin
            if (volatile_ee_cfg_ee_block_mode_in_enb)   // EE_BLOCK_MODE : HW Write
                begin
                    volatile_ee_cfg_ee_block_mode_q <= volatile_ee_cfg_ee_block_mode_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_BLOCK_MODE : SW Write
                    begin
                        volatile_ee_cfg_ee_block_mode_q <=  ( wr_data[3 : 2] & reg_enb[3 : 2] ) | (volatile_ee_cfg_ee_block_mode_q & (~reg_enb[3 : 2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_VREAD
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  VREAD EEPROM setting per EEPROM V3.0 spec
    //                  Available post lock
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_vread_q <= 3'b000;
            end
        else
            begin
                
            if (volatile_ee_cfg_wr_valid)   // EE_VREAD : SW Write
                begin
                    volatile_ee_cfg_ee_vread_q <=  ( wr_data[6 : 4] & reg_enb[6 : 4] ) | (volatile_ee_cfg_ee_vread_q & (~reg_enb[6 : 4]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_FORCE_SBE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Forces a single bit error
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_force_sbe_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_force_sbe_in_enb)   // EE_FORCE_SBE : HW Write
                begin
                    volatile_ee_cfg_ee_force_sbe_q <= volatile_ee_cfg_ee_force_sbe_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_FORCE_SBE : SW Write
                    begin
                        volatile_ee_cfg_ee_force_sbe_q <=  ( wr_data[7] & reg_enb[7] ) | (volatile_ee_cfg_ee_force_sbe_q & (~reg_enb[7]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_FORCE_DBE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Forces a multi bit error
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_force_dbe_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_force_dbe_in_enb)   // EE_FORCE_DBE : HW Write
                begin
                    volatile_ee_cfg_ee_force_dbe_q <= volatile_ee_cfg_ee_force_dbe_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_FORCE_DBE : SW Write
                    begin
                        volatile_ee_cfg_ee_force_dbe_q <=  ( wr_data[8] & reg_enb[8] ) | (volatile_ee_cfg_ee_force_dbe_q & (~reg_enb[8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_DIS_ECC
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  9
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Correct Single bit errors when they occur
    //                  1: Do not correct single bit errors when they occur
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_dis_ecc_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_dis_ecc_in_enb)   // EE_DIS_ECC : HW Write
                begin
                    volatile_ee_cfg_ee_dis_ecc_q <= volatile_ee_cfg_ee_dis_ecc_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_DIS_ECC : SW Write
                    begin
                        volatile_ee_cfg_ee_dis_ecc_q <=  ( wr_data[9] & reg_enb[9] ) | (volatile_ee_cfg_ee_dis_ecc_q & (~reg_enb[9]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_NO_ECC
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  10
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Upper bits of EEPROM is written with ECC bits.
    //                  1: EEPROM is written with all bits of raw data. During a read, all bits of raw data is returned.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_no_ecc_q <= 1'b0;
            end
        else
            begin
                
            if (volatile_ee_cfg_wr_valid)   // EE_NO_ECC : SW Write
                begin
                    volatile_ee_cfg_ee_no_ecc_q <=  ( wr_data[10] & reg_enb[10] ) | (volatile_ee_cfg_ee_no_ecc_q & (~reg_enb[10]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_RAW_ECC
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  11
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0 0: Bits [31:26] of an EEPROM READ return the following read status information.
    //                  Bit 31 = 0
    //                  Bit 30 = 0
    //                  Bit 29 = 1 if double bit error, 0 if not
    //                  Bit 28 = 1 if single bit error, 0 if not
    //                  Bit 27 = 0
    //                  Bit 26 = 0
    //
    //                  1: Bits [31:26] of an EEPROM READ return the 6 bit ECC code
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_raw_ecc_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_raw_ecc_in_enb)   // EE_RAW_ECC : HW Write
                begin
                    volatile_ee_cfg_ee_raw_ecc_q <= volatile_ee_cfg_ee_raw_ecc_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_RAW_ECC : SW Write
                    begin
                        volatile_ee_cfg_ee_raw_ecc_q <=  ( wr_data[11] & reg_enb[11] ) | (volatile_ee_cfg_ee_raw_ecc_q & (~reg_enb[11]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_EN_OVERRIDE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Normal operation
    //                  1: Force ee_en output high
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_en_override_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_en_override_in_enb)   // EE_EN_OVERRIDE : HW Write
                begin
                    volatile_ee_cfg_ee_en_override_q <= volatile_ee_cfg_ee_en_override_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_EN_OVERRIDE : SW Write
                    begin
                        volatile_ee_cfg_ee_en_override_q <=  ( wr_data[12] & reg_enb[12] ) | (volatile_ee_cfg_ee_en_override_q & (~reg_enb[12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_OVERRIDE
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  13
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  00: Normal operation
    //                  01: Force ee_rd output high
    //                  10: Force ee_er output high
    //                  11: Force ee_pr output high
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_override_q <= 2'b00;
            end
        else
            begin
            if (volatile_ee_cfg_ee_override_in_enb)   // EE_OVERRIDE : HW Write
                begin
                    volatile_ee_cfg_ee_override_q <= volatile_ee_cfg_ee_override_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_OVERRIDE : SW Write
                    begin
                        volatile_ee_cfg_ee_override_q <=  ( wr_data[14 : 13] & reg_enb[14 : 13] ) | (volatile_ee_cfg_ee_override_q & (~reg_enb[14 : 13]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_FORCE_RELOAD
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  15
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Write to a 1 to reload all shadow registers with EEPROM values. If the noload test pad or ee_noload is set the reload will not occur.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_force_reload_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_force_reload_in_enb)   // EE_FORCE_RELOAD : HW Write
                begin
                    volatile_ee_cfg_ee_force_reload_q <= volatile_ee_cfg_ee_force_reload_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_FORCE_RELOAD : SW Write
                    begin
                        volatile_ee_cfg_ee_force_reload_q <=  ( wr_data[15] & reg_enb[15] ) | (volatile_ee_cfg_ee_force_reload_q & (~reg_enb[15]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_NOLOAD
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  When set shadow will not update when eeprom is written
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_noload_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_noload_in_enb)   // EE_NOLOAD : HW Write
                begin
                    volatile_ee_cfg_ee_noload_q <= volatile_ee_cfg_ee_noload_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_NOLOAD : SW Write
                    begin
                        volatile_ee_cfg_ee_noload_q <=  ( wr_data[16] & reg_enb[16] ) | (volatile_ee_cfg_ee_noload_q & (~reg_enb[16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_ABORT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  17
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  When set the eeprom controller will abort the current action return to idle
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_cfg_ee_abort_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_cfg_ee_abort_in_enb)   // EE_ABORT : HW Write
                begin
                    volatile_ee_cfg_ee_abort_q <= volatile_ee_cfg_ee_abort_in;
                end
            else
                begin
                    
                if (volatile_ee_cfg_wr_valid)   // EE_ABORT : SW Write
                    begin
                        volatile_ee_cfg_ee_abort_q <=  ( wr_data[17] & reg_enb[17] ) | (volatile_ee_cfg_ee_abort_q & (~reg_enb[17]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_ee_cfg_ee_erase_r =  volatile_ee_cfg_ee_erase_q;    // Field : EE_ERASE
    assign volatile_ee_cfg_ee_prog_r =  volatile_ee_cfg_ee_prog_q;    // Field : EE_PROG
    assign volatile_ee_cfg_ee_block_mode_r =  volatile_ee_cfg_ee_block_mode_q;    // Field : EE_BLOCK_MODE
    assign volatile_ee_cfg_ee_vread_r =  volatile_ee_cfg_ee_vread_q;    // Field : EE_VREAD
    assign volatile_ee_cfg_ee_force_sbe_r =  volatile_ee_cfg_ee_force_sbe_q;    // Field : EE_FORCE_SBE
    assign volatile_ee_cfg_ee_force_dbe_r =  volatile_ee_cfg_ee_force_dbe_q;    // Field : EE_FORCE_DBE
    assign volatile_ee_cfg_ee_dis_ecc_r =  volatile_ee_cfg_ee_dis_ecc_q;    // Field : EE_DIS_ECC
    assign volatile_ee_cfg_ee_no_ecc_r =  volatile_ee_cfg_ee_no_ecc_q;    // Field : EE_NO_ECC
    assign volatile_ee_cfg_ee_raw_ecc_r =  volatile_ee_cfg_ee_raw_ecc_q;    // Field : EE_RAW_ECC
    assign volatile_ee_cfg_ee_en_override_r =  volatile_ee_cfg_ee_en_override_q;    // Field : EE_EN_OVERRIDE
    assign volatile_ee_cfg_ee_override_r =  volatile_ee_cfg_ee_override_q;    // Field : EE_OVERRIDE
    assign volatile_ee_cfg_ee_force_reload_r =  volatile_ee_cfg_ee_force_reload_q;    // Field : EE_FORCE_RELOAD
    assign volatile_ee_cfg_ee_noload_r =  volatile_ee_cfg_ee_noload_q;    // Field : EE_NOLOAD
    assign volatile_ee_cfg_ee_abort_r =  volatile_ee_cfg_ee_abort_q;    // Field : EE_ABORT
    
    
    assign volatile_ee_cfg_rd_data = volatile_ee_cfg_decode ? {14'b0 ,volatile_ee_cfg_ee_abort_q , volatile_ee_cfg_ee_noload_q , volatile_ee_cfg_ee_force_reload_q , volatile_ee_cfg_ee_override_q , volatile_ee_cfg_ee_en_override_q , volatile_ee_cfg_ee_raw_ecc_q , volatile_ee_cfg_ee_no_ecc_q , volatile_ee_cfg_ee_dis_ecc_q , volatile_ee_cfg_ee_force_dbe_q , volatile_ee_cfg_ee_force_sbe_q , volatile_ee_cfg_ee_vread_q , volatile_ee_cfg_ee_block_mode_q , volatile_ee_cfg_ee_prog_q , volatile_ee_cfg_ee_erase_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  CP_CFG
    // ADDRESS       :  block_offset+'h0 + 'hC4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : cp_force_en   ( SW : Read-Write         HW : Read-only )
    //        1 : cp_use_dac    ( SW : Read-Write         HW : Read-only )
    //      7:2 : cp_dac        ( SW : Read-Write         HW : Read-Write )
    //        8 : cp_dis_abort  ( SW : Read-Write         HW : Read-only )
    //        9 : cp_err        ( SW : Read to Clear-only HW : Write-only )
    //    11:10 : cp_cntrl      ( SW : Read-Write         HW : Read-only )
    //    13:12 : cp_rup_sel    ( SW : Read-Write         HW : Read-only )
    //    15:14 : cp_hv_sel     ( SW : Read-Write         HW : Read-only )
    //    17:16 : cp_rdn_sel    ( SW : Read-Write         HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_cp_cfg_wr_valid = volatile_cp_cfg_decode && wr_stb;
    assign volatile_cp_cfg_rd_valid = volatile_cp_cfg_decode && rd_stb;
    assign volatile_cp_cfg_enb      = volatile_cp_cfg_wr_valid;
    assign volatile_cp_cfg_offset = block_offset+'h0 + 'hC4;
    assign volatile_cp_cfg_decode  = (address[volatile_address_width-1 : 0]    == volatile_cp_cfg_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_FORCE_EN
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Normal operation
    //                  1: Force cp_en output high
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_force_en_q <= 1'b0;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_FORCE_EN : SW Write
                begin
                    volatile_cp_cfg_cp_force_en_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_cp_cfg_cp_force_en_q & (~reg_enb[0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_USE_DAC
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Normal operation
    //                  1: The value in CP_DAC drives the cp_dac [5:0] output
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_use_dac_q <= 1'b0;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_USE_DAC : SW Write
                begin
                    volatile_cp_cfg_cp_use_dac_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_cp_cfg_cp_use_dac_q & (~reg_enb[1]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_DAC
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  6
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  This value is driven on cp_dac [5:0] ouput when cp_use_dac is set
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_dac_q <= 6'b000000;
            end
        else
            begin
            if (volatile_cp_cfg_cp_dac_in_enb)   // CP_DAC : HW Write
                begin
                    volatile_cp_cfg_cp_dac_q <= volatile_cp_cfg_cp_dac_in;
                end
            else
                begin
                    
                if (volatile_cp_cfg_wr_valid)   // CP_DAC : SW Write
                    begin
                        volatile_cp_cfg_cp_dac_q <=  ( wr_data[7 : 2] & reg_enb[7 : 2] ) | (volatile_cp_cfg_cp_dac_q & (~reg_enb[7 : 2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_DIS_ABORT
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Normal operation
    //                  1: EEPROM write (or erase, program) will not abort if ee_prog_pulse is not at correct value
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_dis_abort_q <= 1'b0;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_DIS_ABORT : SW Write
                begin
                    volatile_cp_cfg_cp_dis_abort_q <=  ( wr_data[8] & reg_enb[8] ) | (volatile_cp_cfg_cp_dis_abort_q & (~reg_enb[8]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_ERR
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  1
    // SW ACCESS  :  READ TO CLEAR-ONLY                  OFFSET :  9
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  High to indicate an error occurred during charge pump ramp. ee_err_status stores information about the error.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_err_q <= 1'b0;
            end
        else
            begin
            if (volatile_cp_cfg_cp_err_in_enb)   // CP_ERR : HW Write
                begin
                    volatile_cp_cfg_cp_err_q <= volatile_cp_cfg_cp_err_in;
                end
            else
                begin
                    
                if (volatile_cp_cfg_rd_valid)   // CP_ERR : SW Read to Clear
                    begin
                        volatile_cp_cfg_cp_err_q <= 1'b0;
                    end
                end  // sw_rc/rs_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_CNTRL
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  10
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Directly drives cp_cntrl [7:0] ouputs to control charge pump.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_cntrl_q <= 2'b00;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_CNTRL : SW Write
                begin
                    volatile_cp_cfg_cp_cntrl_q <=  ( wr_data[11 : 10] & reg_enb[11 : 10] ) | (volatile_cp_cfg_cp_cntrl_q & (~reg_enb[11 : 10]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_RUP_SEL
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Selects the ramp up time for the charge pump. Values are TBD.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_rup_sel_q <= 2'b00;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_RUP_SEL : SW Write
                begin
                    volatile_cp_cfg_cp_rup_sel_q <=  ( wr_data[13 : 12] & reg_enb[13 : 12] ) | (volatile_cp_cfg_cp_rup_sel_q & (~reg_enb[13 : 12]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_HV_SEL
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  14
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Selects the time the cp_dac remains at its max value (0x3F). Values are TBD.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_hv_sel_q <= 2'b00;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_HV_SEL : SW Write
                begin
                    volatile_cp_cfg_cp_hv_sel_q <=  ( wr_data[15 : 14] & reg_enb[15 : 14] ) | (volatile_cp_cfg_cp_hv_sel_q & (~reg_enb[15 : 14]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CP_RDN_SEL
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Selects the ramp down time for the charge pump. Values are TBD.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_cp_cfg_cp_rdn_sel_q <= 2'b00;
            end
        else
            begin
                
            if (volatile_cp_cfg_wr_valid)   // CP_RDN_SEL : SW Write
                begin
                    volatile_cp_cfg_cp_rdn_sel_q <=  ( wr_data[17 : 16] & reg_enb[17 : 16] ) | (volatile_cp_cfg_cp_rdn_sel_q & (~reg_enb[17 : 16]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_cp_cfg_cp_force_en_r =  volatile_cp_cfg_cp_force_en_q;    // Field : CP_FORCE_EN
    assign volatile_cp_cfg_cp_use_dac_r =  volatile_cp_cfg_cp_use_dac_q;    // Field : CP_USE_DAC
    assign volatile_cp_cfg_cp_dac_r =  volatile_cp_cfg_cp_dac_q;    // Field : CP_DAC
    assign volatile_cp_cfg_cp_dis_abort_r =  volatile_cp_cfg_cp_dis_abort_q;    // Field : CP_DIS_ABORT
    assign volatile_cp_cfg_cp_cntrl_r =  volatile_cp_cfg_cp_cntrl_q;    // Field : CP_CNTRL
    assign volatile_cp_cfg_cp_rup_sel_r =  volatile_cp_cfg_cp_rup_sel_q;    // Field : CP_RUP_SEL
    assign volatile_cp_cfg_cp_hv_sel_r =  volatile_cp_cfg_cp_hv_sel_q;    // Field : CP_HV_SEL
    assign volatile_cp_cfg_cp_rdn_sel_r =  volatile_cp_cfg_cp_rdn_sel_q;    // Field : CP_RDN_SEL
    
    
    assign volatile_cp_cfg_rd_data = volatile_cp_cfg_decode ? {14'b0 ,volatile_cp_cfg_cp_rdn_sel_q , volatile_cp_cfg_cp_hv_sel_q , volatile_cp_cfg_cp_rup_sel_q , volatile_cp_cfg_cp_cntrl_q , volatile_cp_cfg_cp_err_q , volatile_cp_cfg_cp_dis_abort_q , volatile_cp_cfg_cp_dac_q , volatile_cp_cfg_cp_use_dac_q , volatile_cp_cfg_cp_force_en_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  EE_STATUS
    // ADDRESS       :  block_offset+'h0 + 'hC8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : ee_dbe_flag    ( SW : Read-Write         HW : Read-Write )
    //        1 : ee_sbe_flag    ( SW : Read-Write         HW : Read-Write )
    //        2 : ee_err         ( SW : Read to Clear-only HW : Write-only )
    //      7:3 : ee_err_status  ( SW : Read-only          HW : Write-only )
    //     11:8 : ee_addr        ( SW : Read-Write         HW : Read-Write )
    //    17:12 : ee_ecc         ( SW : Read-Write         HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_ee_status_wr_valid = volatile_ee_status_decode && wr_stb;
    assign volatile_ee_status_rd_valid = volatile_ee_status_decode && rd_stb;
    assign volatile_ee_status_enb      = volatile_ee_status_wr_valid;
    assign volatile_ee_status_offset = block_offset+'h0 + 'hC8;
    assign volatile_ee_status_decode  = (address[volatile_address_width-1 : 0]    == volatile_ee_status_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_DBE_FLAG
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Set if a dual bit error has occurred. This bit is clear on read.
    //                  Cannot be unlocked with unlock pad.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_status_ee_dbe_flag_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_status_ee_dbe_flag_in_enb)   // EE_DBE_FLAG : HW Write
                begin
                    volatile_ee_status_ee_dbe_flag_q <= volatile_ee_status_ee_dbe_flag_in;
                end
            else
                begin
                    
                if (volatile_ee_status_wr_valid)   // EE_DBE_FLAG : SW Write
                    begin
                        volatile_ee_status_ee_dbe_flag_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_ee_status_ee_dbe_flag_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_SBE_FLAG
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Set if a single bit error has occurred. This bit is clear on read.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_status_ee_sbe_flag_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_status_ee_sbe_flag_in_enb)   // EE_SBE_FLAG : HW Write
                begin
                    volatile_ee_status_ee_sbe_flag_q <= volatile_ee_status_ee_sbe_flag_in;
                end
            else
                begin
                    
                if (volatile_ee_status_wr_valid)   // EE_SBE_FLAG : SW Write
                    begin
                        volatile_ee_status_ee_sbe_flag_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_ee_status_ee_sbe_flag_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_ERR
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  1
    // SW ACCESS  :  READ TO CLEAR-ONLY                  OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Error flag, goes high when an error occurs during an eeprom write
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_status_ee_err_q <= 1'b0;
            end
        else
            begin
            if (volatile_ee_status_ee_err_in_enb)   // EE_ERR : HW Write
                begin
                    volatile_ee_status_ee_err_q <= volatile_ee_status_ee_err_in;
                end
            else
                begin
                    
                if (volatile_ee_status_rd_valid)   // EE_ERR : SW Read to Clear
                    begin
                        volatile_ee_status_ee_err_q <= 1'b0;
                    end
                end  // sw_rc/rs_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_ERR_STATUS
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  5
    // SW ACCESS  :  READ-ONLY                           OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Status of when the last eeprom error.
    //                  Bit 4: 0 - error occurred during erase, 1 - error occurred during program.
    //                  Bit 3: 0 - error occurred during Ramp Up, 1 - error occurred during Ramp Down.
    //                  Bit 2: Program Pulse value.
    //                  Bit 1: hlat value.
    //                  Bit 0: llat value.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_status_ee_err_status_q <= 5'b00000;
            end
        else
            begin
            if (volatile_ee_status_ee_err_status_in_enb)   // EE_ERR_STATUS : HW Write
                begin
                    volatile_ee_status_ee_err_status_q <= volatile_ee_status_ee_err_status_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_ADDR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  4
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Contains the address for an EEPROM access. On a write or a read to EEPROM this register is updated with the access address. This address is the first read on powerup and the default should point to the row containing the oscillator trim.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_status_ee_addr_q <= 4'b1001;
            end
        else
            begin
            if (volatile_ee_status_ee_addr_in_enb)   // EE_ADDR : HW Write
                begin
                    volatile_ee_status_ee_addr_q <= volatile_ee_status_ee_addr_in;
                end
            else
                begin
                    
                if (volatile_ee_status_wr_valid)   // EE_ADDR : SW Write
                    begin
                        volatile_ee_status_ee_addr_q <=  ( wr_data[11 : 8] & reg_enb[11 : 8] ) | (volatile_ee_status_ee_addr_q & (~reg_enb[11 : 8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_ECC
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  6
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Contains the ecc for an eeprom access. On a write this register contains the written ecc, on a read this register contains the read ecc.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_status_ee_ecc_q <= 6'b000000;
            end
        else
            begin
            if (volatile_ee_status_ee_ecc_in_enb)   // EE_ECC : HW Write
                begin
                    volatile_ee_status_ee_ecc_q <= volatile_ee_status_ee_ecc_in;
                end
            else
                begin
                    
                if (volatile_ee_status_wr_valid)   // EE_ECC : SW Write
                    begin
                        volatile_ee_status_ee_ecc_q <=  ( wr_data[17 : 12] & reg_enb[17 : 12] ) | (volatile_ee_status_ee_ecc_q & (~reg_enb[17 : 12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_ee_status_ee_dbe_flag_r =  volatile_ee_status_ee_dbe_flag_q;    // Field : EE_DBE_FLAG
    assign volatile_ee_status_ee_sbe_flag_r =  volatile_ee_status_ee_sbe_flag_q;    // Field : EE_SBE_FLAG
    assign volatile_ee_status_ee_addr_r =  volatile_ee_status_ee_addr_q;    // Field : EE_ADDR
    assign volatile_ee_status_ee_ecc_r =  volatile_ee_status_ee_ecc_q;    // Field : EE_ECC
    
    
    assign volatile_ee_status_rd_data = volatile_ee_status_decode ? {14'b0 ,volatile_ee_status_ee_ecc_q , volatile_ee_status_ee_addr_q , volatile_ee_status_ee_err_status_q , volatile_ee_status_ee_err_q , volatile_ee_status_ee_sbe_flag_q , volatile_ee_status_ee_dbe_flag_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  EE_DATA
    // ADDRESS       :  block_offset+'h0 + 'hCC                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     25:0 : ee_data  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_ee_data_wr_valid = volatile_ee_data_decode && wr_stb;
    assign volatile_ee_data_enb      = volatile_ee_data_wr_valid;
    assign volatile_ee_data_offset = block_offset+'h0 + 'hCC;
    assign volatile_ee_data_decode  = (address[volatile_address_width-1 : 0]    == volatile_ee_data_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_DATA
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  26
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Contains the data for an eeprom access. On a write this register contains the written data, on a read this register contains the read data.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_ee_data_ee_data_q <= 26'b00000000000000000000000000;
            end
        else
            begin
            if (volatile_ee_data_ee_data_in_enb)   // EE_DATA : HW Write
                begin
                    volatile_ee_data_ee_data_q <= volatile_ee_data_ee_data_in;
                end
            else
                begin
                    
                if (volatile_ee_data_wr_valid)   // EE_DATA : SW Write
                    begin
                        volatile_ee_data_ee_data_q <=  ( wr_data[25 : 0] & reg_enb[25 : 0] ) | (volatile_ee_data_ee_data_q & (~reg_enb[25 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_ee_data_ee_data_r =  volatile_ee_data_ee_data_q;    // Field : EE_DATA
    
    
    assign volatile_ee_data_rd_data = volatile_ee_data_decode ? {6'b0 ,volatile_ee_data_ee_data_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  PAT_TEST
    // ADDRESS       :  block_offset+'h0 + 'hD0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : pat_test_start    ( SW : Read-Write HW : Read-Write )
    //      2:1 : pat_test_status   ( SW : Read-only  HW : Write-only )
    //      4:3 : pat_test_pattern  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_pat_test_wr_valid = volatile_pat_test_decode && wr_stb;
    assign volatile_pat_test_enb      = volatile_pat_test_wr_valid;
    assign volatile_pat_test_offset = block_offset+'h0 + 'hD0;
    assign volatile_pat_test_decode  = (address[volatile_address_width-1 : 0]    == volatile_pat_test_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PAT_TEST_START
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Write to 1 to start pattern check testing. If EE_LOOP is low, this bit will self clear when the last address is reached. If EE_LOOP is high, this bit must be written to 0 to stop test. This bit always clears on a fail.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_pat_test_pat_test_start_q <= 1'b0;
            end
        else
            begin
            if (volatile_pat_test_pat_test_start_in_enb)   // PAT_TEST_START : HW Write
                begin
                    volatile_pat_test_pat_test_start_q <= volatile_pat_test_pat_test_start_in;
                end
            else
                begin
                    
                if (volatile_pat_test_wr_valid)   // PAT_TEST_START : SW Write
                    begin
                        volatile_pat_test_pat_test_start_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_pat_test_pat_test_start_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PAT_TEST_STATUS
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  2
    // SW ACCESS  :  READ-ONLY                           OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Bits are cleared after a read or reset.
    //                   00: Reset condition (no result from pat testing)
    //                   01: Pass, no failure detected during pat testing
    //                   10: Fail, failure detected during pat testing
    //                   11: Running, pat test is still running
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_pat_test_pat_test_status_q <= 2'b00;
            end
        else
            begin
            if (volatile_pat_test_pat_test_status_in_enb)   // PAT_TEST_STATUS : HW Write
                begin
                    volatile_pat_test_pat_test_status_q <= volatile_pat_test_pat_test_status_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : PAT_TEST_PATTERN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  2
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Defines the pattern that will be checked when reading the EEPROM.
    //                  00: All 0s
    //                  01: All 1s
    //                  10: Checker board starting at 0x0 with '010101.'
    //                  11: Checker board starting at 0x0 with '101010.'
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_pat_test_pat_test_pattern_q <= 2'b00;
            end
        else
            begin
            if (volatile_pat_test_pat_test_pattern_in_enb)   // PAT_TEST_PATTERN : HW Write
                begin
                    volatile_pat_test_pat_test_pattern_q <= volatile_pat_test_pat_test_pattern_in;
                end
            else
                begin
                    
                if (volatile_pat_test_wr_valid)   // PAT_TEST_PATTERN : SW Write
                    begin
                        volatile_pat_test_pat_test_pattern_q <=  ( wr_data[4 : 3] & reg_enb[4 : 3] ) | (volatile_pat_test_pat_test_pattern_q & (~reg_enb[4 : 3]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_pat_test_pat_test_start_r =  volatile_pat_test_pat_test_start_q;    // Field : PAT_TEST_START
    assign volatile_pat_test_pat_test_pattern_r =  volatile_pat_test_pat_test_pattern_q;    // Field : PAT_TEST_PATTERN
    
    
    assign volatile_pat_test_rd_data = volatile_pat_test_decode ? {27'b0 ,volatile_pat_test_pat_test_pattern_q , volatile_pat_test_pat_test_status_q , volatile_pat_test_pat_test_start_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  MARG_TEST
    // ADDRESS       :  block_offset+'h0 + 'hD4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : margin_start         ( SW : Read-Write HW : Read-Write )
    //        1 : margin_no_max        ( SW : Read-Write HW : Read-Write )
    //        2 : margin_no_min        ( SW : Read-Write HW : Read-Write )
    //      4:3 : margin_status        ( SW : Read-only  HW : Write-only )
    //        5 : margin_min_max_fail  ( SW : Read-only  HW : Write-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_marg_test_wr_valid = volatile_marg_test_decode && wr_stb;
    assign volatile_marg_test_enb      = volatile_marg_test_wr_valid;
    assign volatile_marg_test_offset = block_offset+'h0 + 'hD4;
    assign volatile_marg_test_decode  = (address[volatile_address_width-1 : 0]    == volatile_marg_test_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : MARGIN_START
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Write to 1 to start margin testing. If EE_LOOP is low, this bit will self clear when address 0xB is reached. If EE_LOOP is high, this bit must be written to 0 to stop test. This bit always clears on a fail.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_marg_test_margin_start_q <= 1'b0;
            end
        else
            begin
            if (volatile_marg_test_margin_start_in_enb)   // MARGIN_START : HW Write
                begin
                    volatile_marg_test_margin_start_q <= volatile_marg_test_margin_start_in;
                end
            else
                begin
                    
                if (volatile_marg_test_wr_valid)   // MARGIN_START : SW Write
                    begin
                        volatile_marg_test_margin_start_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_marg_test_margin_start_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : MARGIN_NO_MAX
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Max reference voltage will be used during margin testing
    //                  1: Max voltage reference will be skiped during margin testing
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_marg_test_margin_no_max_q <= 1'b0;
            end
        else
            begin
            if (volatile_marg_test_margin_no_max_in_enb)   // MARGIN_NO_MAX : HW Write
                begin
                    volatile_marg_test_margin_no_max_q <= volatile_marg_test_margin_no_max_in;
                end
            else
                begin
                    
                if (volatile_marg_test_wr_valid)   // MARGIN_NO_MAX : SW Write
                    begin
                        volatile_marg_test_margin_no_max_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_marg_test_margin_no_max_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : MARGIN_NO_MIN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Min reference voltage will be used during margin testing
    //                  1: Min voltage reference will be skiped during margin testing
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_marg_test_margin_no_min_q <= 1'b0;
            end
        else
            begin
            if (volatile_marg_test_margin_no_min_in_enb)   // MARGIN_NO_MIN : HW Write
                begin
                    volatile_marg_test_margin_no_min_q <= volatile_marg_test_margin_no_min_in;
                end
            else
                begin
                    
                if (volatile_marg_test_wr_valid)   // MARGIN_NO_MIN : SW Write
                    begin
                        volatile_marg_test_margin_no_min_q <=  ( wr_data[2] & reg_enb[2] ) | (volatile_marg_test_margin_no_min_q & (~reg_enb[2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : MARGIN_STATUS
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  2
    // SW ACCESS  :  READ-ONLY                           OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Bits are cleared after a read or reset.
    //                   00: Reset condition (no result from margin testing)
    //                   01: Pass, no failure detected during margin testing
    //                   10: Fail, failure detected during margin testing
    //                   11: Running, margin test is still running
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_marg_test_margin_status_q <= 2'b00;
            end
        else
            begin
            if (volatile_marg_test_margin_status_in_enb)   // MARGIN_STATUS : HW Write
                begin
                    volatile_marg_test_margin_status_q <= volatile_marg_test_margin_status_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : MARGIN_MIN_MAX_FAIL
    // HW ACCESS  :  WRITE-ONLY                          WIDTH  :  1
    // SW ACCESS  :  READ-ONLY                           OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  If margining fails, this bit indicates if the min or max reference failed.
    //                  0: Min margining failed.
    //                  1: Max margining failed.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_marg_test_margin_min_max_fail_q <= 1'b0;
            end
        else
            begin
            if (volatile_marg_test_margin_min_max_fail_in_enb)   // MARGIN_MIN_MAX_FAIL : HW Write
                begin
                    volatile_marg_test_margin_min_max_fail_q <= volatile_marg_test_margin_min_max_fail_in;
                end
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_marg_test_margin_start_r =  volatile_marg_test_margin_start_q;    // Field : MARGIN_START
    assign volatile_marg_test_margin_no_max_r =  volatile_marg_test_margin_no_max_q;    // Field : MARGIN_NO_MAX
    assign volatile_marg_test_margin_no_min_r =  volatile_marg_test_margin_no_min_q;    // Field : MARGIN_NO_MIN
    
    
    assign volatile_marg_test_rd_data = volatile_marg_test_decode ? {26'b0 ,volatile_marg_test_margin_min_max_fail_q , volatile_marg_test_margin_status_q , volatile_marg_test_margin_no_min_q , volatile_marg_test_margin_no_max_q , volatile_marg_test_margin_start_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  TEST_CFG
    // ADDRESS       :  block_offset+'h0 + 'hD8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : ee_loop           ( SW : Read-Write HW : Read-Write )
    //        1 : ee_use_test_addr  ( SW : Read-Write HW : Read-Write )
    //      5:2 : ee_test_addr      ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign volatile_test_cfg_wr_valid = volatile_test_cfg_decode && wr_stb;
    assign volatile_test_cfg_enb      = volatile_test_cfg_wr_valid;
    assign volatile_test_cfg_offset = block_offset+'h0 + 'hD8;
    assign volatile_test_cfg_decode  = (address[volatile_address_width-1 : 0]    == volatile_test_cfg_offset[volatile_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_LOOP
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: Test completes at final address or fail
    //                  1: Test loops until MARGIN_START is written low or fail.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_test_cfg_ee_loop_q  <= 1'b0;
            end
        else
            begin
            if (volatile_test_cfg_ee_loop_in_enb)   // EE_LOOP : HW Write
                begin
                    volatile_test_cfg_ee_loop_q <= volatile_test_cfg_ee_loop_in;
                end
            else
                begin
                    
                if (volatile_test_cfg_wr_valid)   // EE_LOOP : SW Write
                    begin
                        volatile_test_cfg_ee_loop_q <=  ( wr_data[0] & reg_enb[0] ) | (volatile_test_cfg_ee_loop_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_USE_TEST_ADDR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  0: No effect
    //                  1: Uses EE_TST_ADDR as the start address for margining.
    //                  If EE_LOOP is set, this bit is ignored and the starting address is always 0x0
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_test_cfg_ee_use_test_addr_q <= 1'b0;
            end
        else
            begin
            if (volatile_test_cfg_ee_use_test_addr_in_enb)   // EE_USE_TEST_ADDR : HW Write
                begin
                    volatile_test_cfg_ee_use_test_addr_q <= volatile_test_cfg_ee_use_test_addr_in;
                end
            else
                begin
                    
                if (volatile_test_cfg_wr_valid)   // EE_USE_TEST_ADDR : SW Write
                    begin
                        volatile_test_cfg_ee_use_test_addr_q <=  ( wr_data[1] & reg_enb[1] ) | (volatile_test_cfg_ee_use_test_addr_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : EE_TEST_ADDR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  4
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  If USE_TST_ADDR is set, then margining or check testing will start at this address. If the test fails, this will contain the failing address.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                volatile_test_cfg_ee_test_addr_q <= 4'b0000;
            end
        else
            begin
            if (volatile_test_cfg_ee_test_addr_in_enb)   // EE_TEST_ADDR : HW Write
                begin
                    volatile_test_cfg_ee_test_addr_q <= volatile_test_cfg_ee_test_addr_in;
                end
            else
                begin
                    
                if (volatile_test_cfg_wr_valid)   // EE_TEST_ADDR : SW Write
                    begin
                        volatile_test_cfg_ee_test_addr_q <=  ( wr_data[5 : 2] & reg_enb[5 : 2] ) | (volatile_test_cfg_ee_test_addr_q & (~reg_enb[5 : 2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign volatile_test_cfg_ee_loop_r  =  volatile_test_cfg_ee_loop_q ;    // Field : EE_LOOP
    assign volatile_test_cfg_ee_use_test_addr_r =  volatile_test_cfg_ee_use_test_addr_q;    // Field : EE_USE_TEST_ADDR
    assign volatile_test_cfg_ee_test_addr_r =  volatile_test_cfg_ee_test_addr_q;    // Field : EE_TEST_ADDR
    
    
    assign volatile_test_cfg_rd_data = volatile_test_cfg_decode ? {26'b0 ,volatile_test_cfg_ee_test_addr_q , volatile_test_cfg_ee_use_test_addr_q , volatile_test_cfg_ee_loop_q} : 32'b00000000000000000000000000000000;
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_4
    // ADDRESS       :  block_offset+'h110 + 'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      5:3 : rmt       ( SW : Read-Write HW : Read-Write )
    //        6 : pol       ( SW : Read-Write HW : Read-Write )
    //        7 : aggr      ( SW : Read-Write HW : Read-Write )
    //     11:8 : teeth     ( SW : Read-Write HW : Read-Write )
    //    24:12 : fact_tpo  ( SW : Read-Write HW : Read-Write )
    //       25 : wdog_en   ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_4_wr_valid = shadow_shadow_4_decode && wr_stb;
    assign shadow_shadow_4_enb      = shadow_shadow_4_wr_valid;
    assign shadow_shadow_4_offset = block_offset+'h110 + 'h0;
    assign shadow_shadow_4_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_4_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : RMT
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  3
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Running Mode Transition
    //                  Determines the conditions to transition from the output controlled by TPO (at power on) to output controlled by threshold POSCOMP
    //                  3'd0 = Fast Swap (as soon as P/N PEAKs separate)
    //                  3'd1 = Qualified Swap (after one tooth)
    //                  3'd2 = Always TPO
    //                  3'd3 = Fastish Swap (like Fast, but requires larger separation)
    //                  3'd4 = TBD (stays in TPO for teeth?)
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_4_rmt_q <= 3'b000;
            end
        else
            begin
            if (shadow_shadow_4_rmt_in_enb)   // RMT : HW Write
                begin
                    shadow_shadow_4_rmt_q <= shadow_shadow_4_rmt_in;
                end
            else
                begin
                    
                if (shadow_shadow_4_wr_valid)   // RMT : SW Write
                    begin
                        shadow_shadow_4_rmt_q <=  ( wr_data[5 : 3] & reg_enb[5 : 3] ) | (shadow_shadow_4_rmt_q & (~reg_enb[5 : 3]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : POL
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  6
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Polarity
    //                  Inverts the polarity of the analog output driver operation. No effect on internal signals.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_4_pol_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_4_pol_in_enb)   // POL : HW Write
                begin
                    shadow_shadow_4_pol_q <= shadow_shadow_4_pol_in;
                end
            else
                begin
                    
                if (shadow_shadow_4_wr_valid)   // POL : SW Write
                    begin
                        shadow_shadow_4_pol_q <=  ( wr_data[6] & reg_enb[6] ) | (shadow_shadow_4_pol_q & (~reg_enb[6]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : AGGR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  7
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Aggressive Update
    //                  Enables NPEAK aggressive update. (Default is conservative)
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_4_aggr_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_4_aggr_in_enb)   // AGGR : HW Write
                begin
                    shadow_shadow_4_aggr_q <= shadow_shadow_4_aggr_in;
                end
            else
                begin
                    
                if (shadow_shadow_4_wr_valid)   // AGGR : SW Write
                    begin
                        shadow_shadow_4_aggr_q <=  ( wr_data[7] & reg_enb[7] ) | (shadow_shadow_4_aggr_q & (~reg_enb[7]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TEETH
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  4
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Number of Teeth sequences
    //                  The sensor will remember peak levels for the indicated number of theeth. This should be set to match the number of target teeth.
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_4_teeth_q <= 4'b0000;
            end
        else
            begin
            if (shadow_shadow_4_teeth_in_enb)   // TEETH : HW Write
                begin
                    shadow_shadow_4_teeth_q <= shadow_shadow_4_teeth_in;
                end
            else
                begin
                    
                if (shadow_shadow_4_wr_valid)   // TEETH : SW Write
                    begin
                        shadow_shadow_4_teeth_q <=  ( wr_data[11 : 8] & reg_enb[11 : 8] ) | (shadow_shadow_4_teeth_q & (~reg_enb[11 : 8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FACT_TPO
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Factory TPO value
    //                  Default switching threshold for device from power on to RMT. May be superseded by thresh_a/b/c
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_4_fact_tpo_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_4_fact_tpo_in_enb)   // FACT_TPO : HW Write
                begin
                    shadow_shadow_4_fact_tpo_q <= shadow_shadow_4_fact_tpo_in;
                end
            else
                begin
                    
                if (shadow_shadow_4_wr_valid)   // FACT_TPO : SW Write
                    begin
                        shadow_shadow_4_fact_tpo_q <=  ( wr_data[24 : 12] & reg_enb[24 : 12] ) | (shadow_shadow_4_fact_tpo_q & (~reg_enb[24 : 12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : WDOG_EN
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  25
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Watchdog Enable
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_4_wdog_en_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_4_wdog_en_in_enb)   // WDOG_EN : HW Write
                begin
                    shadow_shadow_4_wdog_en_q <= shadow_shadow_4_wdog_en_in;
                end
            else
                begin
                    
                if (shadow_shadow_4_wr_valid)   // WDOG_EN : SW Write
                    begin
                        shadow_shadow_4_wdog_en_q <=  ( wr_data[25] & reg_enb[25] ) | (shadow_shadow_4_wdog_en_q & (~reg_enb[25]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_4_rmt_r =  shadow_shadow_4_rmt_q;    // Field : RMT
    assign shadow_shadow_4_pol_r =  shadow_shadow_4_pol_q;    // Field : POL
    assign shadow_shadow_4_aggr_r =  shadow_shadow_4_aggr_q;    // Field : AGGR
    assign shadow_shadow_4_teeth_r =  shadow_shadow_4_teeth_q;    // Field : TEETH
    assign shadow_shadow_4_fact_tpo_r =  shadow_shadow_4_fact_tpo_q;    // Field : FACT_TPO
    assign shadow_shadow_4_wdog_en_r =  shadow_shadow_4_wdog_en_q;    // Field : WDOG_EN
    
    
    assign shadow_shadow_4_rd_data = shadow_shadow_4_decode ? {6'b0 ,shadow_shadow_4_wdog_en_q , shadow_shadow_4_fact_tpo_q , shadow_shadow_4_teeth_q , shadow_shadow_4_aggr_q , shadow_shadow_4_pol_q , shadow_shadow_4_rmt_q , 3'b0} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_5
    // ADDRESS       :  block_offset+'h110 + 'h4                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      3:0 : thrr            ( SW : Read-Write HW : Read-Write )
    //      7:4 : thrf            ( SW : Read-Write HW : Read-Write )
    //        8 : ffall           ( SW : Read-Write HW : Read-Write )
    //        9 : fb_test         ( SW : Read-Write HW : Read-Write )
    //       10 : dem_test        ( SW : Read-Write HW : Read-Write )
    //       11 : fe_cal_dis      ( SW : Read-Write HW : Read-Write )
    //       12 : variable_chop   ( SW : Read-Write HW : Read-Write )
    //       13 : adc_filter_sel  ( SW : Read-Write HW : Read-Write )
    //       14 : tpoself_dis     ( SW : Read-Write HW : Read-Write )
    //       15 : tpoself_lvl     ( SW : Read-Write HW : Read-Write )
    //    19:16 : temp_comp       ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_5_wr_valid = shadow_shadow_5_decode && wr_stb;
    assign shadow_shadow_5_enb      = shadow_shadow_5_wr_valid;
    assign shadow_shadow_5_offset = block_offset+'h110 + 'h4;
    assign shadow_shadow_5_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_5_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : THRR
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  4
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Threshold for the rising edge
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_thrr_q     <= 4'b0000;
            end
        else
            begin
            if (shadow_shadow_5_thrr_in_enb)   // THRR : HW Write
                begin
                    shadow_shadow_5_thrr_q <= shadow_shadow_5_thrr_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // THRR : SW Write
                    begin
                        shadow_shadow_5_thrr_q <=  ( wr_data[3 : 0] & reg_enb[3 : 0] ) | (shadow_shadow_5_thrr_q & (~reg_enb[3 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : THRF
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  4
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Threshold for the falling edge
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_thrf_q     <= 4'b0000;
            end
        else
            begin
            if (shadow_shadow_5_thrf_in_enb)   // THRF : HW Write
                begin
                    shadow_shadow_5_thrf_q <= shadow_shadow_5_thrf_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // THRF : SW Write
                    begin
                        shadow_shadow_5_thrf_q <=  ( wr_data[7 : 4] & reg_enb[7 : 4] ) | (shadow_shadow_5_thrf_q & (~reg_enb[7 : 4]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FFALL
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  8
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Fast Fall mode on output enable
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_ffall_q    <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_ffall_in_enb)   // FFALL : HW Write
                begin
                    shadow_shadow_5_ffall_q <= shadow_shadow_5_ffall_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // FFALL : SW Write
                    begin
                        shadow_shadow_5_ffall_q <=  ( wr_data[8] & reg_enb[8] ) | (shadow_shadow_5_ffall_q & (~reg_enb[8]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FB_TEST
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  9
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  ADC Feedback test mode
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_fb_test_q  <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_fb_test_in_enb)   // FB_TEST : HW Write
                begin
                    shadow_shadow_5_fb_test_q <= shadow_shadow_5_fb_test_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // FB_TEST : SW Write
                    begin
                        shadow_shadow_5_fb_test_q <=  ( wr_data[9] & reg_enb[9] ) | (shadow_shadow_5_fb_test_q & (~reg_enb[9]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DEM_TEST
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  10
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  SAR DEM test mode
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_dem_test_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_dem_test_in_enb)   // DEM_TEST : HW Write
                begin
                    shadow_shadow_5_dem_test_q <= shadow_shadow_5_dem_test_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // DEM_TEST : SW Write
                    begin
                        shadow_shadow_5_dem_test_q <=  ( wr_data[10] & reg_enb[10] ) | (shadow_shadow_5_dem_test_q & (~reg_enb[10]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : FE_CAL_DIS
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  11
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  FE Calibration disable, holds segment and chop weights at 0
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_fe_cal_dis_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_fe_cal_dis_in_enb)   // FE_CAL_DIS : HW Write
                begin
                    shadow_shadow_5_fe_cal_dis_q <= shadow_shadow_5_fe_cal_dis_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // FE_CAL_DIS : SW Write
                    begin
                        shadow_shadow_5_fe_cal_dis_q <=  ( wr_data[11] & reg_enb[11] ) | (shadow_shadow_5_fe_cal_dis_q & (~reg_enb[11]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : VARIABLE_CHOP
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  12
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Enables variable chopping
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_variable_chop_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_variable_chop_in_enb)   // VARIABLE_CHOP : HW Write
                begin
                    shadow_shadow_5_variable_chop_q <= shadow_shadow_5_variable_chop_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // VARIABLE_CHOP : SW Write
                    begin
                        shadow_shadow_5_variable_chop_q <=  ( wr_data[12] & reg_enb[12] ) | (shadow_shadow_5_variable_chop_q & (~reg_enb[12]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : ADC_FILTER_SEL
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  13
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  selects filter settings
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_adc_filter_sel_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_adc_filter_sel_in_enb)   // ADC_FILTER_SEL : HW Write
                begin
                    shadow_shadow_5_adc_filter_sel_q <= shadow_shadow_5_adc_filter_sel_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // ADC_FILTER_SEL : SW Write
                    begin
                        shadow_shadow_5_adc_filter_sel_q <=  ( wr_data[13] & reg_enb[13] ) | (shadow_shadow_5_adc_filter_sel_q & (~reg_enb[13]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TPOSELF_DIS
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  14
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Disables TPO self write
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_tpoself_dis_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_tpoself_dis_in_enb)   // TPOSELF_DIS : HW Write
                begin
                    shadow_shadow_5_tpoself_dis_q <= shadow_shadow_5_tpoself_dis_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // TPOSELF_DIS : SW Write
                    begin
                        shadow_shadow_5_tpoself_dis_q <=  ( wr_data[14] & reg_enb[14] ) | (shadow_shadow_5_tpoself_dis_q & (~reg_enb[14]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TPOSELF_LVL
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  15
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Level for TPO self write
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_tpoself_lvl_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_5_tpoself_lvl_in_enb)   // TPOSELF_LVL : HW Write
                begin
                    shadow_shadow_5_tpoself_lvl_q <= shadow_shadow_5_tpoself_lvl_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // TPOSELF_LVL : SW Write
                    begin
                        shadow_shadow_5_tpoself_lvl_q <=  ( wr_data[15] & reg_enb[15] ) | (shadow_shadow_5_tpoself_lvl_q & (~reg_enb[15]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : TEMP_COMP
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  4
    // SW ACCESS  :  READ-WRITE                          OFFSET :  16
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  Temperature compensation value
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_5_temp_comp_q <= 4'b0000;
            end
        else
            begin
            if (shadow_shadow_5_temp_comp_in_enb)   // TEMP_COMP : HW Write
                begin
                    shadow_shadow_5_temp_comp_q <= shadow_shadow_5_temp_comp_in;
                end
            else
                begin
                    
                if (shadow_shadow_5_wr_valid)   // TEMP_COMP : SW Write
                    begin
                        shadow_shadow_5_temp_comp_q <=  ( wr_data[19 : 16] & reg_enb[19 : 16] ) | (shadow_shadow_5_temp_comp_q & (~reg_enb[19 : 16]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_5_thrr_r     =  shadow_shadow_5_thrr_q    ;    // Field : THRR
    assign shadow_shadow_5_thrf_r     =  shadow_shadow_5_thrf_q    ;    // Field : THRF
    assign shadow_shadow_5_ffall_r    =  shadow_shadow_5_ffall_q   ;    // Field : FFALL
    assign shadow_shadow_5_fb_test_r  =  shadow_shadow_5_fb_test_q ;    // Field : FB_TEST
    assign shadow_shadow_5_dem_test_r =  shadow_shadow_5_dem_test_q;    // Field : DEM_TEST
    assign shadow_shadow_5_fe_cal_dis_r =  shadow_shadow_5_fe_cal_dis_q;    // Field : FE_CAL_DIS
    assign shadow_shadow_5_variable_chop_r =  shadow_shadow_5_variable_chop_q;    // Field : VARIABLE_CHOP
    assign shadow_shadow_5_adc_filter_sel_r =  shadow_shadow_5_adc_filter_sel_q;    // Field : ADC_FILTER_SEL
    assign shadow_shadow_5_tpoself_dis_r =  shadow_shadow_5_tpoself_dis_q;    // Field : TPOSELF_DIS
    assign shadow_shadow_5_tpoself_lvl_r =  shadow_shadow_5_tpoself_lvl_q;    // Field : TPOSELF_LVL
    assign shadow_shadow_5_temp_comp_r =  shadow_shadow_5_temp_comp_q;    // Field : TEMP_COMP
    
    
    assign shadow_shadow_5_rd_data = shadow_shadow_5_decode ? {12'b0 ,shadow_shadow_5_temp_comp_q , shadow_shadow_5_tpoself_lvl_q , shadow_shadow_5_tpoself_dis_q , shadow_shadow_5_adc_filter_sel_q , shadow_shadow_5_variable_chop_q , shadow_shadow_5_fe_cal_dis_q , shadow_shadow_5_dem_test_q , shadow_shadow_5_fb_test_q , shadow_shadow_5_ffall_q , shadow_shadow_5_thrf_q , shadow_shadow_5_thrr_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_6
    // ADDRESS       :  block_offset+'h110 + 'h8                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     12:0 : diff_baseline_40  ( SW : Read-Write HW : Read-Write )
    //    25:13 : diff_tpo_40       ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_6_wr_valid = shadow_shadow_6_decode && wr_stb;
    assign shadow_shadow_6_enb      = shadow_shadow_6_wr_valid;
    assign shadow_shadow_6_offset = block_offset+'h110 + 'h8;
    assign shadow_shadow_6_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_6_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_BASELINE_40
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  The DIFF value to be offset to mid scale at -40 ?C.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_6_diff_baseline_40_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_6_diff_baseline_40_in_enb)   // DIFF_BASELINE_40 : HW Write
                begin
                    shadow_shadow_6_diff_baseline_40_q <= shadow_shadow_6_diff_baseline_40_in;
                end
            else
                begin
                    
                if (shadow_shadow_6_wr_valid)   // DIFF_BASELINE_40 : SW Write
                    begin
                        shadow_shadow_6_diff_baseline_40_q <=  ( wr_data[12 : 0] & reg_enb[12 : 0] ) | (shadow_shadow_6_diff_baseline_40_q & (~reg_enb[12 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_TPO_40
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  13
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  The TPO level at cold to be gain corrected to match 25 ?C.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_6_diff_tpo_40_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_6_diff_tpo_40_in_enb)   // DIFF_TPO_40 : HW Write
                begin
                    shadow_shadow_6_diff_tpo_40_q <= shadow_shadow_6_diff_tpo_40_in;
                end
            else
                begin
                    
                if (shadow_shadow_6_wr_valid)   // DIFF_TPO_40 : SW Write
                    begin
                        shadow_shadow_6_diff_tpo_40_q <=  ( wr_data[25 : 13] & reg_enb[25 : 13] ) | (shadow_shadow_6_diff_tpo_40_q & (~reg_enb[25 : 13]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_6_diff_baseline_40_r =  shadow_shadow_6_diff_baseline_40_q;    // Field : DIFF_BASELINE_40
    assign shadow_shadow_6_diff_tpo_40_r =  shadow_shadow_6_diff_tpo_40_q;    // Field : DIFF_TPO_40
    
    
    assign shadow_shadow_6_rd_data = shadow_shadow_6_decode ? {6'b0 ,shadow_shadow_6_diff_tpo_40_q , shadow_shadow_6_diff_baseline_40_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_7
    // ADDRESS       :  block_offset+'h110 + 'hC                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     12:0 : diff_baseline_25  ( SW : Read-Write HW : Read-Write )
    //    25:13 : diff_tpo_25       ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_7_wr_valid = shadow_shadow_7_decode && wr_stb;
    assign shadow_shadow_7_enb      = shadow_shadow_7_wr_valid;
    assign shadow_shadow_7_offset = block_offset+'h110 + 'hC;
    assign shadow_shadow_7_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_7_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_BASELINE_25
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  The DIFF value to be offset to mid scale at 25 ?C.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_7_diff_baseline_25_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_7_diff_baseline_25_in_enb)   // DIFF_BASELINE_25 : HW Write
                begin
                    shadow_shadow_7_diff_baseline_25_q <= shadow_shadow_7_diff_baseline_25_in;
                end
            else
                begin
                    
                if (shadow_shadow_7_wr_valid)   // DIFF_BASELINE_25 : SW Write
                    begin
                        shadow_shadow_7_diff_baseline_25_q <=  ( wr_data[12 : 0] & reg_enb[12 : 0] ) | (shadow_shadow_7_diff_baseline_25_q & (~reg_enb[12 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_TPO_25
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  13
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  The reference TPO level.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_7_diff_tpo_25_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_7_diff_tpo_25_in_enb)   // DIFF_TPO_25 : HW Write
                begin
                    shadow_shadow_7_diff_tpo_25_q <= shadow_shadow_7_diff_tpo_25_in;
                end
            else
                begin
                    
                if (shadow_shadow_7_wr_valid)   // DIFF_TPO_25 : SW Write
                    begin
                        shadow_shadow_7_diff_tpo_25_q <=  ( wr_data[25 : 13] & reg_enb[25 : 13] ) | (shadow_shadow_7_diff_tpo_25_q & (~reg_enb[25 : 13]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_7_diff_baseline_25_r =  shadow_shadow_7_diff_baseline_25_q;    // Field : DIFF_BASELINE_25
    assign shadow_shadow_7_diff_tpo_25_r =  shadow_shadow_7_diff_tpo_25_q;    // Field : DIFF_TPO_25
    
    
    assign shadow_shadow_7_rd_data = shadow_shadow_7_decode ? {6'b0 ,shadow_shadow_7_diff_tpo_25_q , shadow_shadow_7_diff_baseline_25_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_8
    // ADDRESS       :  block_offset+'h110 + 'h10                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     12:0 : diff_baseline_165  ( SW : Read-Write HW : Read-Write )
    //    25:13 : diff_tpo_165       ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_8_wr_valid = shadow_shadow_8_decode && wr_stb;
    assign shadow_shadow_8_enb      = shadow_shadow_8_wr_valid;
    assign shadow_shadow_8_offset = block_offset+'h110 + 'h10;
    assign shadow_shadow_8_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_8_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_BASELINE_165
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  The DIFF value to be offset to mid scale at 165 ?C.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_8_diff_baseline_165_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_8_diff_baseline_165_in_enb)   // DIFF_BASELINE_165 : HW Write
                begin
                    shadow_shadow_8_diff_baseline_165_q <= shadow_shadow_8_diff_baseline_165_in;
                end
            else
                begin
                    
                if (shadow_shadow_8_wr_valid)   // DIFF_BASELINE_165 : SW Write
                    begin
                        shadow_shadow_8_diff_baseline_165_q <=  ( wr_data[12 : 0] & reg_enb[12 : 0] ) | (shadow_shadow_8_diff_baseline_165_q & (~reg_enb[12 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : DIFF_TPO_165
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  13
    // SW ACCESS  :  READ-WRITE                          OFFSET :  13
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  The TPO level at hot to be gain corrected to match 25 ?C.
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_8_diff_tpo_165_q <= 13'b0000000000000;
            end
        else
            begin
            if (shadow_shadow_8_diff_tpo_165_in_enb)   // DIFF_TPO_165 : HW Write
                begin
                    shadow_shadow_8_diff_tpo_165_q <= shadow_shadow_8_diff_tpo_165_in;
                end
            else
                begin
                    
                if (shadow_shadow_8_wr_valid)   // DIFF_TPO_165 : SW Write
                    begin
                        shadow_shadow_8_diff_tpo_165_q <=  ( wr_data[25 : 13] & reg_enb[25 : 13] ) | (shadow_shadow_8_diff_tpo_165_q & (~reg_enb[25 : 13]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_8_diff_baseline_165_r =  shadow_shadow_8_diff_baseline_165_q;    // Field : DIFF_BASELINE_165
    assign shadow_shadow_8_diff_tpo_165_r =  shadow_shadow_8_diff_tpo_165_q;    // Field : DIFF_TPO_165
    
    
    assign shadow_shadow_8_rd_data = shadow_shadow_8_decode ? {6'b0 ,shadow_shadow_8_diff_tpo_165_q , shadow_shadow_8_diff_baseline_165_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_9
    // ADDRESS       :  block_offset+'h110 + 'h14                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //      6:0 : halltrim      ( SW : Read-Write HW : Read-Write )
    //     11:7 : osc_trim      ( SW : Read-Write HW : Read-Write )
    //    16:12 : ref_bg_trim   ( SW : Read-Write HW : Read-Write )
    //       17 : out_fastfall  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_9_wr_valid = shadow_shadow_9_decode && wr_stb;
    assign shadow_shadow_9_enb      = shadow_shadow_9_wr_valid;
    assign shadow_shadow_9_offset = block_offset+'h110 + 'h14;
    assign shadow_shadow_9_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_9_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_9_halltrim_r =  shadow_shadow_9_halltrim_q;    // Field : HALLTRIM
    assign shadow_shadow_9_halltrim_q = shadow_shadow_9_halltrim_in_enb ? shadow_shadow_9_halltrim_in : (shadow_shadow_9_wr_valid ? wr_data[6:0] : shadow_shadow_9_halltrim_in);    // Field : HALLTRIM
    assign shadow_shadow_9_osc_trim_r =  shadow_shadow_9_osc_trim_q;    // Field : OSC_TRIM
    assign shadow_shadow_9_osc_trim_q = shadow_shadow_9_osc_trim_in_enb ? shadow_shadow_9_osc_trim_in : (shadow_shadow_9_wr_valid ? wr_data[11:7] : shadow_shadow_9_osc_trim_in);    // Field : OSC_TRIM
    assign shadow_shadow_9_ref_bg_trim_r =  shadow_shadow_9_ref_bg_trim_q;    // Field : REF_BG_TRIM
    assign shadow_shadow_9_ref_bg_trim_q = shadow_shadow_9_ref_bg_trim_in_enb ? shadow_shadow_9_ref_bg_trim_in : (shadow_shadow_9_wr_valid ? wr_data[16:12] : shadow_shadow_9_ref_bg_trim_in);    // Field : REF_BG_TRIM
    assign shadow_shadow_9_out_fastfall_r =  shadow_shadow_9_out_fastfall_q;    // Field : OUT_FASTFALL
    assign shadow_shadow_9_out_fastfall_q = shadow_shadow_9_out_fastfall_in_enb ? shadow_shadow_9_out_fastfall_in : (shadow_shadow_9_wr_valid ? wr_data[17] : shadow_shadow_9_out_fastfall_in);    // Field : OUT_FASTFALL
    
    
    assign shadow_shadow_9_rd_data = shadow_shadow_9_decode ? {14'b0 ,shadow_shadow_9_out_fastfall_q , shadow_shadow_9_ref_bg_trim_q , shadow_shadow_9_osc_trim_q , shadow_shadow_9_halltrim_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  SHADOW_A
    // ADDRESS       :  block_offset+'h110 + 'h18                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //        0 : lock_t   ( SW : Read-Write HW : Read-Write )
    //        1 : lock_a   ( SW : Read-Write HW : Read-Write )
    //        2 : lock_c   ( SW : Read-Write HW : Read-Write )
    //        3 : lock_o   ( SW : Read-Write HW : Read-Write )
    //        4 : lock_s   ( SW : Read-Write HW : Read-Write )
    //        5 : lock_bd  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :
    //
    
    
    assign shadow_shadow_a_wr_valid = shadow_shadow_a_decode && wr_stb;
    assign shadow_shadow_a_enb      = shadow_shadow_a_wr_valid;
    assign shadow_shadow_a_offset = block_offset+'h110 + 'h18;
    assign shadow_shadow_a_decode  = (address[shadow_address_width-1 : 0]    == shadow_shadow_a_offset[shadow_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LOCK_T
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  See EEPROM Section
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_a_lock_t_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_a_lock_t_in_enb)   // LOCK_T : HW Write
                begin
                    shadow_shadow_a_lock_t_q <= shadow_shadow_a_lock_t_in;
                end
            else
                begin
                    
                if (shadow_shadow_a_wr_valid)   // LOCK_T : SW Write
                    begin
                        shadow_shadow_a_lock_t_q <=  ( wr_data[0] & reg_enb[0] ) | (shadow_shadow_a_lock_t_q & (~reg_enb[0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LOCK_A
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  1
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  See EEPROM Section
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_a_lock_a_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_a_lock_a_in_enb)   // LOCK_A : HW Write
                begin
                    shadow_shadow_a_lock_a_q <= shadow_shadow_a_lock_a_in;
                end
            else
                begin
                    
                if (shadow_shadow_a_wr_valid)   // LOCK_A : SW Write
                    begin
                        shadow_shadow_a_lock_a_q <=  ( wr_data[1] & reg_enb[1] ) | (shadow_shadow_a_lock_a_q & (~reg_enb[1]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LOCK_C
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  2
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  See EEPROM Section
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_a_lock_c_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_a_lock_c_in_enb)   // LOCK_C : HW Write
                begin
                    shadow_shadow_a_lock_c_q <= shadow_shadow_a_lock_c_in;
                end
            else
                begin
                    
                if (shadow_shadow_a_wr_valid)   // LOCK_C : SW Write
                    begin
                        shadow_shadow_a_lock_c_q <=  ( wr_data[2] & reg_enb[2] ) | (shadow_shadow_a_lock_c_q & (~reg_enb[2]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LOCK_O
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  3
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  See EEPROM Section
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_a_lock_o_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_a_lock_o_in_enb)   // LOCK_O : HW Write
                begin
                    shadow_shadow_a_lock_o_q <= shadow_shadow_a_lock_o_in;
                end
            else
                begin
                    
                if (shadow_shadow_a_wr_valid)   // LOCK_O : SW Write
                    begin
                        shadow_shadow_a_lock_o_q <=  ( wr_data[3] & reg_enb[3] ) | (shadow_shadow_a_lock_o_q & (~reg_enb[3]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LOCK_S
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  4
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  See EEPROM Section
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_a_lock_s_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_a_lock_s_in_enb)   // LOCK_S : HW Write
                begin
                    shadow_shadow_a_lock_s_q <= shadow_shadow_a_lock_s_in;
                end
            else
                begin
                    
                if (shadow_shadow_a_wr_valid)   // LOCK_S : SW Write
                    begin
                        shadow_shadow_a_lock_s_q <=  ( wr_data[4] & reg_enb[4] ) | (shadow_shadow_a_lock_s_q & (~reg_enb[4]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    
    //----------------------------------------------------------------------------
    // FIELD  : LOCK_BD
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  1
    // SW ACCESS  :  READ-WRITE                          OFFSET :  5
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //                  See EEPROM Section
    //
    //
    
    always @(posedge clk or negedge reset_l)
        begin
        if (!reset_l)
            begin
                
                shadow_shadow_a_lock_bd_q <= 1'b0;
            end
        else
            begin
            if (shadow_shadow_a_lock_bd_in_enb)   // LOCK_BD : HW Write
                begin
                    shadow_shadow_a_lock_bd_q <= shadow_shadow_a_lock_bd_in;
                end
            else
                begin
                    
                if (shadow_shadow_a_wr_valid)   // LOCK_BD : SW Write
                    begin
                        shadow_shadow_a_lock_bd_q <=  ( wr_data[5] & reg_enb[5] ) | (shadow_shadow_a_lock_bd_q & (~reg_enb[5]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign shadow_shadow_a_lock_t_r =  shadow_shadow_a_lock_t_q;    // Field : LOCK_T
    assign shadow_shadow_a_lock_a_r =  shadow_shadow_a_lock_a_q;    // Field : LOCK_A
    assign shadow_shadow_a_lock_c_r =  shadow_shadow_a_lock_c_q;    // Field : LOCK_C
    assign shadow_shadow_a_lock_o_r =  shadow_shadow_a_lock_o_q;    // Field : LOCK_O
    assign shadow_shadow_a_lock_s_r =  shadow_shadow_a_lock_s_q;    // Field : LOCK_S
    assign shadow_shadow_a_lock_bd_r =  shadow_shadow_a_lock_bd_q;    // Field : LOCK_BD
    
    
    assign shadow_shadow_a_rd_data = shadow_shadow_a_decode ? {26'b0 ,shadow_shadow_a_lock_bd_q , shadow_shadow_a_lock_s_q , shadow_shadow_a_lock_o_q , shadow_shadow_a_lock_c_q , shadow_shadow_a_lock_a_q , shadow_shadow_a_lock_t_q} : 32'b00000000000000000000000000000000;
    
    
    
    assign eeprom_offset       = (block_offset/'h40) +'h6;
    assign eeprom_decode      = (address[(addr_width - 1):6]  == eeprom_offset[(addr_width -6) - 1 : 0]) ? 1'b1 : 1'b0;
    assign eeprom_wr_valid     = eeprom_decode &&  wr_stb;
    assign eeprom_rd_valid     = eeprom_decode && rd_stb && rd_wait_state;
    assign eeprom_wr_valid_out = eeprom_wr_valid;
    assign eeprom_rd_valid_out = eeprom_rd_valid;
    
    assign eeprom_rd_data      = eeprom_rd_ack_in ? eeprom_rd_data_in : 32'b00000000000000000000000000000000;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    assign volatile_test_result_rd_ack_wire = volatile_test_result_rd_ack_in;
    assign volatile_test_result_decode_wire = volatile_test_result_decode;
    assign volatile_hallphase_wr_req_wire = volatile_hallphase_wr_req_in;
    assign volatile_hallphase_rd_ack_wire = volatile_hallphase_rd_ack_in;
    assign volatile_hallphase_decode_wire = volatile_hallphase_decode;
    assign volatile_state_wr_req_wire = volatile_state_wr_req_in;
    assign volatile_state_rd_ack_wire = volatile_state_rd_ack_in;
    assign volatile_state_decode_wire = volatile_state_decode;
    assign volatile_temperature_wr_req_wire = volatile_temperature_wr_req_in;
    assign volatile_temperature_rd_ack_wire = volatile_temperature_rd_ack_in;
    assign volatile_temperature_decode_wire = volatile_temperature_decode;
    assign volatile_pdiff_wr_req_wire = volatile_pdiff_wr_req_in;
    assign volatile_pdiff_rd_ack_wire = volatile_pdiff_rd_ack_in;
    assign volatile_pdiff_decode_wire = volatile_pdiff_decode;
    assign volatile_diff_wr_req_wire = volatile_diff_wr_req_in;
    assign volatile_diff_rd_ack_wire = volatile_diff_rd_ack_in;
    assign volatile_diff_decode_wire = volatile_diff_decode;
    assign volatile_tdiff_wr_req_wire = volatile_tdiff_wr_req_in;
    assign volatile_tdiff_rd_ack_wire = volatile_tdiff_rd_ack_in;
    assign volatile_tdiff_decode_wire = volatile_tdiff_decode;
    assign volatile_out_wr_req_wire = volatile_out_wr_req_in;
    assign volatile_out_rd_ack_wire = volatile_out_rd_ack_in;
    assign volatile_out_decode_wire = volatile_out_decode;
    assign volatile_ppeak_rd_ack_wire = volatile_ppeak_rd_ack_in;
    assign volatile_ppeak_decode_wire = volatile_ppeak_decode;
    assign volatile_plast_rd_ack_wire = volatile_plast_rd_ack_in;
    assign volatile_plast_decode_wire = volatile_plast_decode;
    assign volatile_npeak_rd_ack_wire = volatile_npeak_rd_ack_in;
    assign volatile_npeak_decode_wire = volatile_npeak_decode;
    assign volatile_stored_tpo_rd_ack_wire = volatile_stored_tpo_rd_ack_in;
    assign volatile_stored_tpo_decode_wire = volatile_stored_tpo_decode;
    
    assign eeprom_wr_req_wire = eeprom_wr_req_in;
    assign eeprom_rd_ack_wire = eeprom_rd_ack_in;
    assign eeprom_decode_wire = eeprom_decode;
    
    assign rd_data = int_rd_data | ext_rd_data ;
    
    assign int_rd_data = (rd_wait_state & ~external_access)? ( volatile_status0_rd_data |
    volatile_cfg0_rd_data |
    volatile_cfg1_rd_data |
    volatile_cfg2_rd_data |
    volatile_ee_cfg_rd_data |
    volatile_cp_cfg_rd_data |
    volatile_ee_status_rd_data |
    volatile_ee_data_rd_data |
    volatile_pat_test_rd_data |
    volatile_marg_test_rd_data |
    volatile_test_cfg_rd_data |
    shadow_shadow_4_rd_data |
    shadow_shadow_5_rd_data |
    shadow_shadow_6_rd_data |
    shadow_shadow_7_rd_data |
    shadow_shadow_8_rd_data |
    shadow_shadow_9_rd_data |
    shadow_shadow_a_rd_data) : {bus_width{1'b0}};
    
    assign ext_rd_data = (external_rd_ack == 1'b1)? ( volatile_test_result_rd_data |
    volatile_hallphase_rd_data |
    volatile_state_rd_data |
    volatile_temperature_rd_data |
    volatile_pdiff_rd_data |
    volatile_diff_rd_data |
    volatile_tdiff_rd_data |
    volatile_out_rd_data |
    volatile_ppeak_rd_data |
    volatile_plast_rd_data |
    volatile_npeak_rd_data |
    volatile_stored_tpo_rd_data |
    eeprom_rd_data ): {bus_width{1'b0}} ;
    
    
    
    
    assign external_rd_valid = volatile_test_result_rd_valid |
    volatile_hallphase_rd_valid |
    volatile_state_rd_valid |
    volatile_temperature_rd_valid |
    volatile_pdiff_rd_valid |
    volatile_diff_rd_valid |
    volatile_tdiff_rd_valid |
    volatile_out_rd_valid |
    volatile_ppeak_rd_valid |
    volatile_plast_rd_valid |
    volatile_npeak_rd_valid |
    volatile_stored_tpo_rd_valid |
    eeprom_rd_valid;
    // END external_rd_valid
    
    assign external_rd_ack = volatile_test_result_rd_ack_wire |
    volatile_hallphase_rd_ack_wire |
    volatile_state_rd_ack_wire |
    volatile_temperature_rd_ack_wire |
    volatile_pdiff_rd_ack_wire |
    volatile_diff_rd_ack_wire |
    volatile_tdiff_rd_ack_wire |
    volatile_out_rd_ack_wire |
    volatile_ppeak_rd_ack_wire |
    volatile_plast_rd_ack_wire |
    volatile_npeak_rd_ack_wire |
    volatile_stored_tpo_rd_ack_wire |
    eeprom_rd_ack_wire;
    // END external_rd_ack
    
    assign external_wr_req = volatile_hallphase_wr_req_wire &
    volatile_state_wr_req_wire &
    volatile_temperature_wr_req_wire &
    volatile_pdiff_wr_req_wire &
    volatile_diff_wr_req_wire &
    volatile_tdiff_wr_req_wire &
    volatile_out_wr_req_wire &
    eeprom_wr_req_wire;
    // END external_wr_req
    
    assign external_access = (volatile_test_result_decode_wire |
    volatile_hallphase_decode_wire |
    volatile_state_decode_wire |
    volatile_temperature_decode_wire |
    volatile_pdiff_decode_wire |
    volatile_diff_decode_wire |
    volatile_tdiff_decode_wire |
    volatile_out_decode_wire |
    volatile_ppeak_decode_wire |
    volatile_plast_decode_wire |
    volatile_npeak_decode_wire |
    volatile_stored_tpo_decode_wire |
    eeprom_decode_wire) & (rd_stb | wr_stb);
    // END external_access
    
    always @(posedge clk or negedge reset_l)
        begin
        if ( !reset_l )
            begin
                rd_wait_state <= 1'b1;
            end
        else
            begin
                case(rd_wait_state)
                    1'b1:
                    begin
                    if (external_rd_valid == 1'b1 && external_rd_ack == 1'b0 )
                        begin
                            rd_wait_state <= 1'b0;
                        end
                    end
                    1'b0:
                    begin
                    if (external_rd_ack == 1'b1)
                        begin
                            rd_wait_state <= 1'b1;
                        end
                    end
                endcase
            end
    end // always END
    
    
    assign request     = external_wr_req;
    assign rd_data_vld = external_rd_ack |(~external_access & rd_stb & rd_wait_state);
    assign rd_wait     = rd_wait_state;
    
    
endmodule
