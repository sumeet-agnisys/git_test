//Agnisys, Inc. ***** Copyright 2018 All Rights Reserved. *****
//
//*** This file is auto generated by IDesignSpec (http://www.agnisys.com) . Please do not edit this file. ***
// created by        :
// generated by      : Saurabh
// generated from    : F:\testGit\git_test\Sample467\test514\test515.idsng
// IDesignSpec rev   : idsbatch v 6.16.4.7

//*** This code is generated with following settings ***
// Reg Width                  : 32
// Address Unit               : 8
// C++ Types int              : hwint
// Bus Type                   : PROPRIETARY
// BigEndian                  : false
// LittleEndian               : false
// Dist. Decode and Readback  : false
//---------------------------------------------------------------------------------------------------------------

//------------------------------------------------
//  BLOCK : TEST515 MODULE
//

module test515_ids #(
    
    //  PARAMETERS
    parameter bus_width   = 32,
    parameter addr_width = 5,
    
    parameter block_offset  = {(addr_width){1'b0}},
    
    
    parameter test515_address_width = addr_width
    )
    
    (
    
    //-----------------------------------------------------
    // REGISTER : CXX SIGNALS
    
    output   cxx_enb,
    
    // HW WRITE DATA SIGNAL FOR EACH FIELD
    input  [31 : 0] cxx_xfcds_in,    // FIELD : XFCDS
    
    
    // HW WRITE-ABLE SIGNAL FOR EACH FIELD
    input   cxx_xfcds_in_enb,    // FIELD : XFCDS
    
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] cxx_xfcds_r,    // FIELD : XFCDS
    
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME1 SIGNALS
    
    output   reg_name1_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] reg_name1_xcz_r,    // FIELD : XCZ
    
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME2 SIGNALS
    
    output   reg_name2_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] reg_name2_xc_r,    // FIELD : XC
    
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME3 SIGNALS
    
    output   reg_name3_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] reg_name3_xc_r,    // FIELD : XC
    
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME4 SIGNALS
    
    output   reg_name4_enb,
    
    // READ DATA SIGNAL FOR EACH FIELD
    output [31 : 0] reg_name4_cxc_r,    // FIELD : CXC
    
    
    
    
    //CUSTOM signals
    input clk,     //Bus clock
    input reset_l,     //Reset
    input rd_stb,     //Read strobe        : This signal should be HIGH during read operation and LOW during write operation
    output rd_wait,     //Read wait
    input wr_stb,     //Write strobe       : This signal should be HIGH during write operation and LOW during read operation
    input [addr_width-1 : 0] address,     //Address for write/read
    input [bus_width-1 : 0] wr_data,     //Write data
    input [bus_width/8-1 : 0] byteenable,     //Specify which bytes are being written or during read which bytes the master is reading
    output request,     //Bus request signal : HIGH indicates bus is free and LOW indicates bus is busy
    output rd_data_vld,     //Read data valid : Asserted by the slave to indicate that the read data signal contains valid data
    output [bus_width-1 : 0] rd_data     //Read data
    
    );
    //-----------------------------------------------------
    // REGISTER : CXX SIGNALS
    
    
    wire    cxx_decode;         // DECODE
    wire    cxx_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] cxx_rd_data;          // READ DATA
    wire    [64-1 : 0] cxx_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] cxx_xfcds_q ;      // FIELD : XFCDS
    
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME1 SIGNALS
    
    
    wire    reg_name1_decode;         // DECODE
    wire    reg_name1_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] reg_name1_rd_data;          // READ DATA
    wire    [64-1 : 0] reg_name1_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] reg_name1_xcz_q ;      // FIELD : XCZ
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME2 SIGNALS
    
    
    wire    reg_name2_decode;         // DECODE
    wire    reg_name2_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] reg_name2_rd_data;          // READ DATA
    wire    [64-1 : 0] reg_name2_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] reg_name2_xc_q ;      // FIELD : XC
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME3 SIGNALS
    
    
    wire    reg_name3_decode;         // DECODE
    wire    reg_name3_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] reg_name3_rd_data;          // READ DATA
    wire    [64-1 : 0] reg_name3_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] reg_name3_xc_q ;      // FIELD : XC
    
    //-----------------------------------------------------
    
    
    //-----------------------------------------------------
    // REGISTER : REG_NAME4 SIGNALS
    
    
    wire    reg_name4_decode;         // DECODE
    wire    reg_name4_wr_valid;       // WRITE VALID
    wire    [bus_width-1 : 0] reg_name4_rd_data;          // READ DATA
    wire    [64-1 : 0] reg_name4_offset;  // OFFSET
    
    // BUFFER SIGNAL FOR EACH FIELD
    reg [31 : 0] reg_name4_cxc_q ;      // FIELD : CXC
    
    //-----------------------------------------------------
    
    
    
    
    //CUSTOM signals
    
    wire [bus_width-1 : 0] reg_enb;
    wire [bus_width/8 -1 : 0] byte_enb;
    
    assign byte_enb = byteenable;
    assign reg_enb =  {
    {8{byte_enb[3]}} ,
    {8{byte_enb[2]}} ,
    {8{byte_enb[1]}} ,
    {8{byte_enb[0]}}};
    
    
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  CXX
    // ADDRESS       :  block_offset+'h0                WIDTH : 32
    // HW ACCESS     :  READ-WRITE
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : xfcds  ( SW : Read-Write HW : Read-Write )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign cxx_wr_valid = cxx_decode && wr_stb;
    assign cxx_enb      = cxx_wr_valid;
    assign cxx_offset = block_offset+'h0;
    assign cxx_decode  = (address[test515_address_width-1 : 0]    == cxx_offset[test515_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : XFCDS
    // HW ACCESS  :  READ-WRITE                          WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                cxx_xfcds_q  <= 32'd0;
            end
        else
            begin
            if (cxx_xfcds_in_enb)   // XFCDS : HW Write
                begin
                    cxx_xfcds_q <= cxx_xfcds_in;
                end
            else
                begin
                    
                if (cxx_wr_valid)   // XFCDS : SW Write
                    begin
                        cxx_xfcds_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (cxx_xfcds_q & (~reg_enb[31 : 0]));
                    end
                    
                end  // sw_write_close
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign cxx_xfcds_r  =  cxx_xfcds_q ;    // Field : XFCDS
    
    
    assign cxx_rd_data = cxx_decode ? {cxx_xfcds_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG_NAME1
    // ADDRESS       :  block_offset+'h4                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : xcz  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reg_name1_wr_valid = reg_name1_decode && wr_stb;
    assign reg_name1_enb      = reg_name1_wr_valid;
    assign reg_name1_offset = block_offset+'h4;
    assign reg_name1_decode  = (address[test515_address_width-1 : 0]    == reg_name1_offset[test515_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : XCZ
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg_name1_xcz_q  <= 32'd0;
            end
        else
            begin
                
            if (reg_name1_wr_valid)   // XCZ : SW Write
                begin
                    reg_name1_xcz_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (reg_name1_xcz_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg_name1_xcz_r  =  reg_name1_xcz_q ;    // Field : XCZ
    
    
    assign reg_name1_rd_data = reg_name1_decode ? {reg_name1_xcz_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG_NAME2
    // ADDRESS       :  block_offset+'h8                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : xc  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reg_name2_wr_valid = reg_name2_decode && wr_stb;
    assign reg_name2_enb      = reg_name2_wr_valid;
    assign reg_name2_offset = block_offset+'h8;
    assign reg_name2_decode  = (address[test515_address_width-1 : 0]    == reg_name2_offset[test515_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : XC
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg_name2_xc_q  <= 32'd0;
            end
        else
            begin
                
            if (reg_name2_wr_valid)   // XC : SW Write
                begin
                    reg_name2_xc_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (reg_name2_xc_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg_name2_xc_r  =  reg_name2_xc_q ;    // Field : XC
    
    
    assign reg_name2_rd_data = reg_name2_decode ? {reg_name2_xc_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG_NAME3
    // ADDRESS       :  block_offset+'hC                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : xc  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reg_name3_wr_valid = reg_name3_decode && wr_stb;
    assign reg_name3_enb      = reg_name3_wr_valid;
    assign reg_name3_offset = block_offset+'hC;
    assign reg_name3_decode  = (address[test515_address_width-1 : 0]    == reg_name3_offset[test515_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : XC
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg_name3_xc_q  <= 32'd0;
            end
        else
            begin
                
            if (reg_name3_wr_valid)   // XC : SW Write
                begin
                    reg_name3_xc_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (reg_name3_xc_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg_name3_xc_r  =  reg_name3_xc_q ;    // Field : XC
    
    
    assign reg_name3_rd_data = reg_name3_decode ? {reg_name3_xc_q} : 32'b00000000000000000000000000000000;
    
    
    //----------------------------------------------------------------------------------------------------
    // REGISTER      :  REG_NAME4
    // ADDRESS       :  block_offset+'h10                WIDTH : 32
    // HW ACCESS     :  READ-ONLY
    // SW ACCESS     :  READ-WRITE
    //
    // FIELDS   :
    //     31:0 : cxc  ( SW : Read-Write HW : Read-only )
    
    //-----------------------------------------------------------------------------
    // DESCRIPTION  :  NA
    //
    
    
    assign reg_name4_wr_valid = reg_name4_decode && wr_stb;
    assign reg_name4_enb      = reg_name4_wr_valid;
    assign reg_name4_offset = block_offset+'h10;
    assign reg_name4_decode  = (address[test515_address_width-1 : 0]    == reg_name4_offset[test515_address_width-1 : 0] ) ? 1'b1 : 1'b0;
    
    
    //----------------------------------------------------------------------------
    // FIELD  : CXC
    // HW ACCESS  :  READ-ONLY                           WIDTH  :  32
    // SW ACCESS  :  READ-WRITE                          OFFSET :  0
    //-----------------------------------------------------------------
    // DESCRIPTION   :
    //
    
    always @(posedge clk)
        
        begin
        if (!reset_l)
            begin
                
                reg_name4_cxc_q  <= 32'd0;
            end
        else
            begin
                
            if (reg_name4_wr_valid)   // CXC : SW Write
                begin
                    reg_name4_cxc_q <=  ( wr_data[31 : 0] & reg_enb[31 : 0] ) | (reg_name4_cxc_q & (~reg_enb[31 : 0]));
                end
                
            end
    end // always clk
    
    //----------------------------------------------------------------------------
    
    
    // ===================================================
    // HW OUTPUT READ DATA FOR EACH FIELD
    assign reg_name4_cxc_r  =  reg_name4_cxc_q ;    // Field : CXC
    
    
    assign reg_name4_rd_data = reg_name4_decode ? {reg_name4_cxc_q} : 32'b00000000000000000000000000000000;
    
    
    
    
    
    
    
    
    
    
    assign rd_data = cxx_rd_data |
    reg_name1_rd_data |
    reg_name2_rd_data |
    reg_name3_rd_data |
    reg_name4_rd_data ;
    
    
    
    assign request      =  1'b1;
    assign rd_data_vld   =  rd_stb;
    assign rd_wait       =  1'b1;
    
    
endmodule
